import{m as Qy}from"./index-CXkB7Wti.js";import{r as bp,c as ex}from"./three-D_Q1nxF1.js";import"./vendor-lXdfEqoL.js";import"./mui-DvTeEhIk.js";const Rc="153",tx={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},nx={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},d_=0,Fu=1,f_=2,ix=3,sx=0,Nd=1,p_=2,li=3,Fi=0,cn=1,hi=2,rx=2,Di=0,js=1,zu=2,Vu=3,Bu=4,m_=5,Vs=100,g_=101,__=102,ku=103,Gu=104,y_=200,x_=201,v_=202,S_=203,Od=204,Dd=205,b_=206,w_=207,M_=208,A_=209,E_=210,T_=0,C_=1,R_=2,gc=3,P_=4,I_=5,L_=6,N_=7,va=0,O_=1,D_=2,fi=0,U_=1,F_=2,z_=3,V_=4,B_=5,Pc=300,ds=301,fs=302,Ko=303,Jo=304,co=306,Qo=1e3,en=1001,ea=1002,Pt=1003,_c=1004,ox=1004,Xo=1005,ax=1005,It=1006,Ud=1007,lx=1007,ps=1008,cx=1008,Ui=1009,k_=1010,G_=1011,Ic=1012,Fd=1013,Oi=1014,ui=1015,so=1016,zd=1017,Vd=1018,as=1020,H_=1021,Rn=1023,W_=1024,X_=1025,ls=1026,$s=1027,j_=1028,Bd=1029,Y_=1030,kd=1031,Gd=1033,rc=33776,oc=33777,ac=33778,lc=33779,Hu=35840,Wu=35841,Xu=35842,ju=35843,q_=36196,Yu=37492,qu=37496,$u=37808,Zu=37809,Ku=37810,Ju=37811,Qu=37812,ed=37813,td=37814,nd=37815,id=37816,sd=37817,rd=37818,od=37819,ad=37820,ld=37821,cc=36492,$_=36283,cd=36284,hd=36285,ud=36286,Z_=2200,K_=2201,J_=2202,ta=2300,na=2301,hc=2302,ks=2400,Gs=2401,ia=2402,Lc=2500,Hd=2501,hx=0,ux=1,dx=2,Wd=3e3,cs=3001,Q_=3200,e1=3201,_s=0,t1=1,hs="",ot="srgb",Jn="srgb-linear",Xd="display-p3",fx=0,uc=7680,px=7681,mx=7682,gx=7683,_x=34055,yx=34056,xx=5386,vx=512,Sx=513,bx=514,wx=515,Mx=516,Ax=517,Ex=518,n1=519,i1=512,s1=513,r1=514,o1=515,a1=516,l1=517,c1=518,h1=519,sa=35044,Tx=35048,Cx=35040,Rx=35045,Px=35049,Ix=35041,Lx=35046,Nx=35050,Ox=35042,Dx="100",dd="300 es",yc=1035,di=2e3,ra=2001;let Gi=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let s=0,o=i.length;s<o;s++)i[s].call(this,e);e.target=null}}};const Kt=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let wp=1234567;const Ys=Math.PI/180,ro=180/Math.PI;function In(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Kt[r&255]+Kt[r>>8&255]+Kt[r>>16&255]+Kt[r>>24&255]+"-"+Kt[e&255]+Kt[e>>8&255]+"-"+Kt[e>>16&15|64]+Kt[e>>24&255]+"-"+Kt[t&63|128]+Kt[t>>8&255]+"-"+Kt[t>>16&255]+Kt[t>>24&255]+Kt[n&255]+Kt[n>>8&255]+Kt[n>>16&255]+Kt[n>>24&255]).toLowerCase()}function Ct(r,e,t){return Math.max(e,Math.min(t,r))}function jd(r,e){return(r%e+e)%e}function Ux(r,e,t,n,i){return n+(r-e)*(i-n)/(t-e)}function Fx(r,e,t){return r!==e?(t-r)/(e-r):0}function jo(r,e,t){return(1-t)*r+t*e}function zx(r,e,t,n){return jo(r,e,1-Math.exp(-t*n))}function Vx(r,e=1){return e-Math.abs(jd(r,e*2)-e)}function Bx(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*(3-2*r))}function kx(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*r*(r*(r*6-15)+10))}function Gx(r,e){return r+Math.floor(Math.random()*(e-r+1))}function Hx(r,e){return r+Math.random()*(e-r)}function Wx(r){return r*(.5-Math.random())}function Xx(r){r!==void 0&&(wp=r);let e=wp+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function jx(r){return r*Ys}function Yx(r){return r*ro}function fd(r){return(r&r-1)===0&&r!==0}function u1(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function xc(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function qx(r,e,t,n,i){const s=Math.cos,o=Math.sin,a=s(t/2),l=o(t/2),c=s((e+n)/2),h=o((e+n)/2),u=s((e-n)/2),d=o((e-n)/2),f=s((n-e)/2),p=o((n-e)/2);switch(i){case"XYX":r.set(a*h,l*u,l*d,a*c);break;case"YZY":r.set(l*d,a*h,l*u,a*c);break;case"ZXZ":r.set(l*u,l*d,a*h,a*c);break;case"XZX":r.set(a*h,l*p,l*f,a*c);break;case"YXY":r.set(l*f,a*h,l*p,a*c);break;case"ZYZ":r.set(l*p,l*f,a*h,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Pn(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return r/4294967295;case Uint16Array:return r/65535;case Uint8Array:return r/255;case Int32Array:return Math.max(r/2147483647,-1);case Int16Array:return Math.max(r/32767,-1);case Int8Array:return Math.max(r/127,-1);default:throw new Error("Invalid component type.")}}function ct(r,e){switch(e.constructor){case Float32Array:return r;case Uint32Array:return Math.round(r*4294967295);case Uint16Array:return Math.round(r*65535);case Uint8Array:return Math.round(r*255);case Int32Array:return Math.round(r*2147483647);case Int16Array:return Math.round(r*32767);case Int8Array:return Math.round(r*127);default:throw new Error("Invalid component type.")}}const $x={DEG2RAD:Ys,RAD2DEG:ro,generateUUID:In,clamp:Ct,euclideanModulo:jd,mapLinear:Ux,inverseLerp:Fx,lerp:jo,damp:zx,pingpong:Vx,smoothstep:Bx,smootherstep:kx,randInt:Gx,randFloat:Hx,randFloatSpread:Wx,seededRandom:Xx,degToRad:jx,radToDeg:Yx,isPowerOfTwo:fd,ceilPowerOfTwo:u1,floorPowerOfTwo:xc,setQuaternionFromProperEuler:qx,normalize:ct,denormalize:Pn};class Te{constructor(e=0,t=0){Te.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Ct(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),s=this.x-e.x,o=this.y-e.y;return this.x=s*n-o*i+e.x,this.y=s*i+o*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class lt{constructor(e,t,n,i,s,o,a,l,c){lt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,i,s,o,a,l,c)}set(e,t,n,i,s,o,a,l,c){const h=this.elements;return h[0]=e,h[1]=i,h[2]=a,h[3]=t,h[4]=s,h[5]=l,h[6]=n,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,o=n[0],a=n[3],l=n[6],c=n[1],h=n[4],u=n[7],d=n[2],f=n[5],p=n[8],_=i[0],g=i[3],m=i[6],v=i[1],y=i[4],S=i[7],b=i[2],M=i[5],E=i[8];return s[0]=o*_+a*v+l*b,s[3]=o*g+a*y+l*M,s[6]=o*m+a*S+l*E,s[1]=c*_+h*v+u*b,s[4]=c*g+h*y+u*M,s[7]=c*m+h*S+u*E,s[2]=d*_+f*v+p*b,s[5]=d*g+f*y+p*M,s[8]=d*m+f*S+p*E,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8];return t*o*h-t*a*c-n*s*h+n*a*l+i*s*c-i*o*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=h*o-a*c,d=a*l-h*s,f=c*s-o*l,p=t*u+n*d+i*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const _=1/p;return e[0]=u*_,e[1]=(i*c-h*n)*_,e[2]=(a*n-i*o)*_,e[3]=d*_,e[4]=(h*t-i*l)*_,e[5]=(i*s-a*t)*_,e[6]=f*_,e[7]=(n*l-c*t)*_,e[8]=(o*t-n*s)*_,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(n*l,n*c,-n*(l*o+c*a)+o+e,-i*c,i*l,-i*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){return this.premultiply(Th.makeScale(e,t)),this}rotate(e){return this.premultiply(Th.makeRotation(-e)),this}translate(e,t){return this.premultiply(Th.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const Th=new lt;function d1(r){for(let e=r.length-1;e>=0;--e)if(r[e]>=65535)return!0;return!1}const Zx={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function qr(r,e){return new Zx[r](e)}function oa(r){return document.createElementNS("http://www.w3.org/1999/xhtml",r)}const Mp={};function Yo(r){r in Mp||(Mp[r]=!0,console.warn(r))}function Qr(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function Ch(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}const Kx=new lt().fromArray([.8224621,.0331941,.0170827,.177538,.9668058,.0723974,-1e-7,1e-7,.9105199]),Jx=new lt().fromArray([1.2249401,-.0420569,-.0196376,-.2249404,1.0420571,-.0786361,1e-7,0,1.0982735]);function Qx(r){return r.convertSRGBToLinear().applyMatrix3(Jx)}function ev(r){return r.applyMatrix3(Kx).convertLinearToSRGB()}const tv={[Jn]:r=>r,[ot]:r=>r.convertSRGBToLinear(),[Xd]:Qx},nv={[Jn]:r=>r,[ot]:r=>r.convertLinearToSRGB(),[Xd]:ev},Vn={enabled:!0,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(r){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!r},get workingColorSpace(){return Jn},set workingColorSpace(r){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},convert:function(r,e,t){if(this.enabled===!1||e===t||!e||!t)return r;const n=tv[e],i=nv[t];if(n===void 0||i===void 0)throw new Error(`Unsupported color space conversion, "${e}" to "${t}".`);return i(n(r))},fromWorkingColorSpace:function(r,e){return this.convert(r,this.workingColorSpace,e)},toWorkingColorSpace:function(r,e){return this.convert(r,e,this.workingColorSpace)}};let dr;class Yd{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{dr===void 0&&(dr=oa("canvas")),dr.width=e.width,dr.height=e.height;const n=dr.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=dr}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=oa("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),s=i.data;for(let o=0;o<s.length;o++)s[o]=Qr(s[o]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(Qr(t[n]/255)*255):t[n]=Qr(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let iv=0;class Hs{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:iv++}),this.uuid=In(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?s.push(Rh(i[o].image)):s.push(Rh(i[o]))}else s=Rh(i);n.url=s}return t||(e.images[this.uuid]=n),n}}function Rh(r){return typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&r instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&r instanceof ImageBitmap?Yd.getDataURL(r):r.data?{data:Array.from(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let sv=0;class Lt extends Gi{constructor(e=Lt.DEFAULT_IMAGE,t=Lt.DEFAULT_MAPPING,n=en,i=en,s=It,o=ps,a=Rn,l=Ui,c=Lt.DEFAULT_ANISOTROPY,h=hs){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:sv++}),this.uuid=In(),this.name="",this.source=new Hs(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Te(0,0),this.repeat=new Te(1,1),this.center=new Te(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new lt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof h=="string"?this.colorSpace=h:(Yo("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=h===cs?ot:hs),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Pc)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Qo:e.x=e.x-Math.floor(e.x);break;case en:e.x=e.x<0?0:1;break;case ea:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Qo:e.y=e.y-Math.floor(e.y);break;case en:e.y=e.y<0?0:1;break;case ea:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return Yo("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===ot?cs:Wd}set encoding(e){Yo("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===cs?ot:hs}}Lt.DEFAULT_IMAGE=null;Lt.DEFAULT_MAPPING=Pc;Lt.DEFAULT_ANISOTROPY=1;class _t{constructor(e=0,t=0,n=0,i=1){_t.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=this.w,o=e.elements;return this.x=o[0]*t+o[4]*n+o[8]*i+o[12]*s,this.y=o[1]*t+o[5]*n+o[9]*i+o[13]*s,this.z=o[2]*t+o[6]*n+o[10]*i+o[14]*s,this.w=o[3]*t+o[7]*n+o[11]*i+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,s;const l=e.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],_=l[2],g=l[6],m=l[10];if(Math.abs(h-d)<.01&&Math.abs(u-_)<.01&&Math.abs(p-g)<.01){if(Math.abs(h+d)<.1&&Math.abs(u+_)<.1&&Math.abs(p+g)<.1&&Math.abs(c+f+m-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const y=(c+1)/2,S=(f+1)/2,b=(m+1)/2,M=(h+d)/4,E=(u+_)/4,T=(p+g)/4;return y>S&&y>b?y<.01?(n=0,i=.707106781,s=.707106781):(n=Math.sqrt(y),i=M/n,s=E/n):S>b?S<.01?(n=.707106781,i=0,s=.707106781):(i=Math.sqrt(S),n=M/i,s=T/i):b<.01?(n=.707106781,i=.707106781,s=0):(s=Math.sqrt(b),n=E/s,i=T/s),this.set(n,i,s,t),this}let v=Math.sqrt((g-p)*(g-p)+(u-_)*(u-_)+(d-h)*(d-h));return Math.abs(v)<.001&&(v=1),this.x=(g-p)/v,this.y=(u-_)/v,this.z=(d-h)/v,this.w=Math.acos((c+f+m-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Qn extends Gi{constructor(e=1,t=1,n={}){super(),this.isWebGLRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new _t(0,0,e,t),this.scissorTest=!1,this.viewport=new _t(0,0,e,t);const i={width:e,height:t,depth:1};n.encoding!==void 0&&(Yo("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),n.colorSpace=n.encoding===cs?ot:hs),this.texture=new Lt(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:It,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null,this.samples=n.samples!==void 0?n.samples:0}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new Hs(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Nc extends Lt{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Pt,this.minFilter=Pt,this.wrapR=en,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class rv extends Qn{constructor(e=1,t=1,n=1){super(e,t),this.isWebGLArrayRenderTarget=!0,this.depth=n,this.texture=new Nc(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class qd extends Lt{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=Pt,this.minFilter=Pt,this.wrapR=en,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class ov extends Qn{constructor(e=1,t=1,n=1){super(e,t),this.isWebGL3DRenderTarget=!0,this.depth=n,this.texture=new qd(null,e,t,n),this.texture.isRenderTargetTexture=!0}}class av extends Qn{constructor(e=1,t=1,n=1,i={}){super(e,t,i),this.isWebGLMultipleRenderTargets=!0;const s=this.texture;this.texture=[];for(let o=0;o<n;o++)this.texture[o]=s.clone(),this.texture[o].isRenderTargetTexture=!0}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,s=this.texture.length;i<s;i++)this.texture[i].image.width=e,this.texture[i].image.height=t,this.texture[i].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone(),this.texture[t].isRenderTargetTexture=!0;return this}}class yn{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,s,o,a){let l=n[i+0],c=n[i+1],h=n[i+2],u=n[i+3];const d=s[o+0],f=s[o+1],p=s[o+2],_=s[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=u;return}if(a===1){e[t+0]=d,e[t+1]=f,e[t+2]=p,e[t+3]=_;return}if(u!==_||l!==d||c!==f||h!==p){let g=1-a;const m=l*d+c*f+h*p+u*_,v=m>=0?1:-1,y=1-m*m;if(y>Number.EPSILON){const b=Math.sqrt(y),M=Math.atan2(b,m*v);g=Math.sin(g*M)/b,a=Math.sin(a*M)/b}const S=a*v;if(l=l*g+d*S,c=c*g+f*S,h=h*g+p*S,u=u*g+_*S,g===1-a){const b=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=b,c*=b,h*=b,u*=b}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=u}static multiplyQuaternionsFlat(e,t,n,i,s,o){const a=n[i],l=n[i+1],c=n[i+2],h=n[i+3],u=s[o],d=s[o+1],f=s[o+2],p=s[o+3];return e[t]=a*p+h*u+l*f-c*d,e[t+1]=l*p+h*d+c*u-a*f,e[t+2]=c*p+h*f+a*d-l*u,e[t+3]=h*p-a*u-l*d-c*f,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const n=e._x,i=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(n/2),h=a(i/2),u=a(s/2),d=l(n/2),f=l(i/2),p=l(s/2);switch(o){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],s=t[8],o=t[1],a=t[5],l=t[9],c=t[2],h=t[6],u=t[10],d=n+a+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(s-c)*f,this._z=(o-i)*f}else if(n>a&&n>u){const f=2*Math.sqrt(1+n-a-u);this._w=(h-l)/f,this._x=.25*f,this._y=(i+o)/f,this._z=(s+c)/f}else if(a>u){const f=2*Math.sqrt(1+a-n-u);this._w=(s-c)/f,this._x=(i+o)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-n-a);this._w=(o-i)/f,this._x=(s+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Ct(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,s=e._z,o=e._w,a=t._x,l=t._y,c=t._z,h=t._w;return this._x=n*h+o*a+i*c-s*l,this._y=i*h+o*l+s*a-n*c,this._z=s*h+o*c+n*l-i*a,this._w=o*h-n*a-i*l-s*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,s=this._z,o=this._w;let a=o*e._w+n*e._x+i*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=n,this._y=i,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-t;return this._w=f*o+t*this._w,this._x=f*n+t*this._x,this._y=f*i+t*this._y,this._z=f*s+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),u=Math.sin((1-t)*h)/c,d=Math.sin(t*h)/c;return this._w=o*u+this._w*d,this._x=n*u+this._x*d,this._y=i*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),i=2*Math.PI*Math.random(),s=2*Math.PI*Math.random();return this.set(t*Math.cos(i),n*Math.sin(s),n*Math.cos(s),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class F{constructor(e=0,t=0,n=0){F.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Ap.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Ap.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6]*i,this.y=s[1]*t+s[4]*n+s[7]*i,this.z=s[2]*t+s[5]*n+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,s=e.elements,o=1/(s[3]*t+s[7]*n+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*n+s[8]*i+s[12])*o,this.y=(s[1]*t+s[5]*n+s[9]*i+s[13])*o,this.z=(s[2]*t+s[6]*n+s[10]*i+s[14])*o,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*i-a*n,h=l*n+a*t-s*i,u=l*i+s*n-o*t,d=-s*t-o*n-a*i;return this.x=c*l+d*-s+h*-a-u*-o,this.y=h*l+d*-o+u*-s-c*-a,this.z=u*l+d*-a+c*-o-h*-s,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*n+s[8]*i,this.y=s[1]*t+s[5]*n+s[9]*i,this.z=s[2]*t+s[6]*n+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,s=e.z,o=t.x,a=t.y,l=t.z;return this.x=i*l-s*a,this.y=s*o-n*l,this.z=n*a-i*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return Ph.copy(this).projectOnVector(e),this.sub(Ph)}reflect(e){return this.sub(Ph.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Ct(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Ph=new F,Ap=new yn;class _i{constructor(e=new F(1/0,1/0,1/0),t=new F(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(bi.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(bi.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=bi.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){if(e.updateWorldMatrix(!1,!1),e.boundingBox!==void 0)e.boundingBox===null&&e.computeBoundingBox(),fr.copy(e.boundingBox),fr.applyMatrix4(e.matrixWorld),this.union(fr);else{const i=e.geometry;if(i!==void 0)if(t&&i.attributes!==void 0&&i.attributes.position!==void 0){const s=i.attributes.position;for(let o=0,a=s.count;o<a;o++)bi.fromBufferAttribute(s,o).applyMatrix4(e.matrixWorld),this.expandByPoint(bi)}else i.boundingBox===null&&i.computeBoundingBox(),fr.copy(i.boundingBox),fr.applyMatrix4(e.matrixWorld),this.union(fr)}const n=e.children;for(let i=0,s=n.length;i<s;i++)this.expandByObject(n[i],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,bi),bi.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(So),$a.subVectors(this.max,So),pr.subVectors(e.a,So),mr.subVectors(e.b,So),gr.subVectors(e.c,So),ji.subVectors(mr,pr),Yi.subVectors(gr,mr),As.subVectors(pr,gr);let t=[0,-ji.z,ji.y,0,-Yi.z,Yi.y,0,-As.z,As.y,ji.z,0,-ji.x,Yi.z,0,-Yi.x,As.z,0,-As.x,-ji.y,ji.x,0,-Yi.y,Yi.x,0,-As.y,As.x,0];return!Ih(t,pr,mr,gr,$a)||(t=[1,0,0,0,1,0,0,0,1],!Ih(t,pr,mr,gr,$a))?!1:(Za.crossVectors(ji,Yi),t=[Za.x,Za.y,Za.z],Ih(t,pr,mr,gr,$a))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,bi).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(bi).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Si[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Si[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Si[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Si[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Si[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Si[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Si[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Si[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Si),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Si=[new F,new F,new F,new F,new F,new F,new F,new F],bi=new F,fr=new _i,pr=new F,mr=new F,gr=new F,ji=new F,Yi=new F,As=new F,So=new F,$a=new F,Za=new F,Es=new F;function Ih(r,e,t,n,i){for(let s=0,o=r.length-3;s<=o;s+=3){Es.fromArray(r,s);const a=i.x*Math.abs(Es.x)+i.y*Math.abs(Es.y)+i.z*Math.abs(Es.z),l=e.dot(Es),c=t.dot(Es),h=n.dot(Es);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const lv=new _i,bo=new F,Lh=new F;class ni{constructor(e=new F,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):lv.setFromPoints(e).getCenter(n);let i=0;for(let s=0,o=e.length;s<o;s++)i=Math.max(i,n.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;bo.subVectors(e,this.center);const t=bo.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(bo,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Lh.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(bo.copy(e.center).add(Lh)),this.expandByPoint(bo.copy(e.center).sub(Lh))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const wi=new F,Nh=new F,Ka=new F,qi=new F,Oh=new F,Ja=new F,Dh=new F;class ho{constructor(e=new F,t=new F(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,wi)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=wi.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(wi.copy(this.origin).addScaledVector(this.direction,t),wi.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){Nh.copy(e).add(t).multiplyScalar(.5),Ka.copy(t).sub(e).normalize(),qi.copy(this.origin).sub(Nh);const s=e.distanceTo(t)*.5,o=-this.direction.dot(Ka),a=qi.dot(this.direction),l=-qi.dot(Ka),c=qi.lengthSq(),h=Math.abs(1-o*o);let u,d,f,p;if(h>0)if(u=o*l-a,d=o*a-l,p=s*h,u>=0)if(d>=-p)if(d<=p){const _=1/h;u*=_,d*=_,f=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-o*s+a)),d=u>0?-s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-s,-l),s),f=d*(d+2*l)+c):(u=Math.max(0,-(o*s+a)),d=u>0?s:Math.min(Math.max(-s,-l),s),f=-u*u+d*(d+2*l)+c);else d=o>0?-s:s,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;return n&&n.copy(this.origin).addScaledVector(this.direction,u),i&&i.copy(Nh).addScaledVector(Ka,d),f}intersectSphere(e,t){wi.subVectors(e.center,this.origin);const n=wi.dot(this.direction),i=wi.dot(wi)-n*n,s=e.radius*e.radius;if(i>s)return null;const o=Math.sqrt(s-i),a=n-o,l=n+o;return l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,s,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(n=(e.min.x-d.x)*c,i=(e.max.x-d.x)*c):(n=(e.max.x-d.x)*c,i=(e.min.x-d.x)*c),h>=0?(s=(e.min.y-d.y)*h,o=(e.max.y-d.y)*h):(s=(e.max.y-d.y)*h,o=(e.min.y-d.y)*h),n>o||s>i||((s>n||isNaN(n))&&(n=s),(o<i||isNaN(i))&&(i=o),u>=0?(a=(e.min.z-d.z)*u,l=(e.max.z-d.z)*u):(a=(e.max.z-d.z)*u,l=(e.min.z-d.z)*u),n>l||a>i)||((a>n||n!==n)&&(n=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,wi)!==null}intersectTriangle(e,t,n,i,s){Oh.subVectors(t,e),Ja.subVectors(n,e),Dh.crossVectors(Oh,Ja);let o=this.direction.dot(Dh),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;qi.subVectors(this.origin,e);const l=a*this.direction.dot(Ja.crossVectors(qi,Ja));if(l<0)return null;const c=a*this.direction.dot(Oh.cross(qi));if(c<0||l+c>o)return null;const h=-a*qi.dot(Dh);return h<0?null:this.at(h/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class rt{constructor(e,t,n,i,s,o,a,l,c,h,u,d,f,p,_,g){rt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,n,i,s,o,a,l,c,h,u,d,f,p,_,g)}set(e,t,n,i,s,o,a,l,c,h,u,d,f,p,_,g){const m=this.elements;return m[0]=e,m[4]=t,m[8]=n,m[12]=i,m[1]=s,m[5]=o,m[9]=a,m[13]=l,m[2]=c,m[6]=h,m[10]=u,m[14]=d,m[3]=f,m[7]=p,m[11]=_,m[15]=g,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new rt().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/_r.setFromMatrixColumn(e,0).length(),s=1/_r.setFromMatrixColumn(e,1).length(),o=1/_r.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*s,t[5]=n[5]*s,t[6]=n[6]*s,t[7]=0,t[8]=n[8]*o,t[9]=n[9]*o,t[10]=n[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,s=e.z,o=Math.cos(n),a=Math.sin(n),l=Math.cos(i),c=Math.sin(i),h=Math.cos(s),u=Math.sin(s);if(e.order==="XYZ"){const d=o*h,f=o*u,p=a*h,_=a*u;t[0]=l*h,t[4]=-l*u,t[8]=c,t[1]=f+p*c,t[5]=d-_*c,t[9]=-a*l,t[2]=_-d*c,t[6]=p+f*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*h,f=l*u,p=c*h,_=c*u;t[0]=d+_*a,t[4]=p*a-f,t[8]=o*c,t[1]=o*u,t[5]=o*h,t[9]=-a,t[2]=f*a-p,t[6]=_+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*h,f=l*u,p=c*h,_=c*u;t[0]=d-_*a,t[4]=-o*u,t[8]=p+f*a,t[1]=f+p*a,t[5]=o*h,t[9]=_-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*h,f=o*u,p=a*h,_=a*u;t[0]=l*h,t[4]=p*c-f,t[8]=d*c+_,t[1]=l*u,t[5]=_*c+d,t[9]=f*c-p,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,f=o*c,p=a*l,_=a*c;t[0]=l*h,t[4]=_-d*u,t[8]=p*u+f,t[1]=u,t[5]=o*h,t[9]=-a*h,t[2]=-c*h,t[6]=f*u+p,t[10]=d-_*u}else if(e.order==="XZY"){const d=o*l,f=o*c,p=a*l,_=a*c;t[0]=l*h,t[4]=-u,t[8]=c*h,t[1]=d*u+_,t[5]=o*h,t[9]=f*u-p,t[2]=p*u-f,t[6]=a*h,t[10]=_*u+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(cv,e,hv)}lookAt(e,t,n){const i=this.elements;return Mn.subVectors(e,t),Mn.lengthSq()===0&&(Mn.z=1),Mn.normalize(),$i.crossVectors(n,Mn),$i.lengthSq()===0&&(Math.abs(n.z)===1?Mn.x+=1e-4:Mn.z+=1e-4,Mn.normalize(),$i.crossVectors(n,Mn)),$i.normalize(),Qa.crossVectors(Mn,$i),i[0]=$i.x,i[4]=Qa.x,i[8]=Mn.x,i[1]=$i.y,i[5]=Qa.y,i[9]=Mn.y,i[2]=$i.z,i[6]=Qa.z,i[10]=Mn.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,s=this.elements,o=n[0],a=n[4],l=n[8],c=n[12],h=n[1],u=n[5],d=n[9],f=n[13],p=n[2],_=n[6],g=n[10],m=n[14],v=n[3],y=n[7],S=n[11],b=n[15],M=i[0],E=i[4],T=i[8],w=i[12],A=i[1],D=i[5],k=i[9],G=i[13],P=i[2],N=i[6],B=i[10],H=i[14],W=i[3],$=i[7],oe=i[11],Se=i[15];return s[0]=o*M+a*A+l*P+c*W,s[4]=o*E+a*D+l*N+c*$,s[8]=o*T+a*k+l*B+c*oe,s[12]=o*w+a*G+l*H+c*Se,s[1]=h*M+u*A+d*P+f*W,s[5]=h*E+u*D+d*N+f*$,s[9]=h*T+u*k+d*B+f*oe,s[13]=h*w+u*G+d*H+f*Se,s[2]=p*M+_*A+g*P+m*W,s[6]=p*E+_*D+g*N+m*$,s[10]=p*T+_*k+g*B+m*oe,s[14]=p*w+_*G+g*H+m*Se,s[3]=v*M+y*A+S*P+b*W,s[7]=v*E+y*D+S*N+b*$,s[11]=v*T+y*k+S*B+b*oe,s[15]=v*w+y*G+S*H+b*Se,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],h=e[2],u=e[6],d=e[10],f=e[14],p=e[3],_=e[7],g=e[11],m=e[15];return p*(+s*l*u-i*c*u-s*a*d+n*c*d+i*a*f-n*l*f)+_*(+t*l*f-t*c*d+s*o*d-i*o*f+i*c*h-s*l*h)+g*(+t*c*u-t*a*f-s*o*u+n*o*f+s*a*h-n*c*h)+m*(-i*a*h-t*l*u+t*a*d+i*o*u-n*o*d+n*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],h=e[8],u=e[9],d=e[10],f=e[11],p=e[12],_=e[13],g=e[14],m=e[15],v=u*g*c-_*d*c+_*l*f-a*g*f-u*l*m+a*d*m,y=p*d*c-h*g*c-p*l*f+o*g*f+h*l*m-o*d*m,S=h*_*c-p*u*c+p*a*f-o*_*f-h*a*m+o*u*m,b=p*u*l-h*_*l-p*a*d+o*_*d+h*a*g-o*u*g,M=t*v+n*y+i*S+s*b;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const E=1/M;return e[0]=v*E,e[1]=(_*d*s-u*g*s-_*i*f+n*g*f+u*i*m-n*d*m)*E,e[2]=(a*g*s-_*l*s+_*i*c-n*g*c-a*i*m+n*l*m)*E,e[3]=(u*l*s-a*d*s-u*i*c+n*d*c+a*i*f-n*l*f)*E,e[4]=y*E,e[5]=(h*g*s-p*d*s+p*i*f-t*g*f-h*i*m+t*d*m)*E,e[6]=(p*l*s-o*g*s-p*i*c+t*g*c+o*i*m-t*l*m)*E,e[7]=(o*d*s-h*l*s+h*i*c-t*d*c-o*i*f+t*l*f)*E,e[8]=S*E,e[9]=(p*u*s-h*_*s-p*n*f+t*_*f+h*n*m-t*u*m)*E,e[10]=(o*_*s-p*a*s+p*n*c-t*_*c-o*n*m+t*a*m)*E,e[11]=(h*a*s-o*u*s-h*n*c+t*u*c+o*n*f-t*a*f)*E,e[12]=b*E,e[13]=(h*_*i-p*u*i+p*n*d-t*_*d-h*n*g+t*u*g)*E,e[14]=(p*a*i-o*_*i-p*n*l+t*_*l+o*n*g-t*a*g)*E,e[15]=(o*u*i-h*a*i+h*n*l-t*u*l-o*n*d+t*a*d)*E,this}scale(e){const t=this.elements,n=e.x,i=e.y,s=e.z;return t[0]*=n,t[4]*=i,t[8]*=s,t[1]*=n,t[5]*=i,t[9]*=s,t[2]*=n,t[6]*=i,t[10]*=s,t[3]*=n,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),s=1-n,o=e.x,a=e.y,l=e.z,c=s*o,h=s*a;return this.set(c*o+n,c*a-i*l,c*l+i*a,0,c*a+i*l,h*a+n,h*l-i*o,0,c*l-i*a,h*l+i*o,s*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,s,o){return this.set(1,n,s,0,e,1,o,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,s=t._x,o=t._y,a=t._z,l=t._w,c=s+s,h=o+o,u=a+a,d=s*c,f=s*h,p=s*u,_=o*h,g=o*u,m=a*u,v=l*c,y=l*h,S=l*u,b=n.x,M=n.y,E=n.z;return i[0]=(1-(_+m))*b,i[1]=(f+S)*b,i[2]=(p-y)*b,i[3]=0,i[4]=(f-S)*M,i[5]=(1-(d+m))*M,i[6]=(g+v)*M,i[7]=0,i[8]=(p+y)*E,i[9]=(g-v)*E,i[10]=(1-(d+_))*E,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let s=_r.set(i[0],i[1],i[2]).length();const o=_r.set(i[4],i[5],i[6]).length(),a=_r.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Xn.copy(this);const c=1/s,h=1/o,u=1/a;return Xn.elements[0]*=c,Xn.elements[1]*=c,Xn.elements[2]*=c,Xn.elements[4]*=h,Xn.elements[5]*=h,Xn.elements[6]*=h,Xn.elements[8]*=u,Xn.elements[9]*=u,Xn.elements[10]*=u,t.setFromRotationMatrix(Xn),n.x=s,n.y=o,n.z=a,this}makePerspective(e,t,n,i,s,o,a=di){const l=this.elements,c=2*s/(t-e),h=2*s/(n-i),u=(t+e)/(t-e),d=(n+i)/(n-i);let f,p;if(a===di)f=-(o+s)/(o-s),p=-2*o*s/(o-s);else if(a===ra)f=-o/(o-s),p=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=c,l[4]=0,l[8]=u,l[12]=0,l[1]=0,l[5]=h,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=f,l[14]=p,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,n,i,s,o,a=di){const l=this.elements,c=1/(t-e),h=1/(n-i),u=1/(o-s),d=(t+e)*c,f=(n+i)*h;let p,_;if(a===di)p=(o+s)*u,_=-2*u;else if(a===ra)p=s*u,_=-1*u;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-f,l[2]=0,l[6]=0,l[10]=_,l[14]=-p,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const _r=new F,Xn=new rt,cv=new F(0,0,0),hv=new F(1,1,1),$i=new F,Qa=new F,Mn=new F,Ep=new rt,Tp=new yn;class Sa{constructor(e=0,t=0,n=0,i=Sa.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,s=i[0],o=i[4],a=i[8],l=i[1],c=i[5],h=i[9],u=i[2],d=i[6],f=i[10];switch(t){case"XYZ":this._y=Math.asin(Ct(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Ct(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,s),this._z=0);break;case"ZXY":this._x=Math.asin(Ct(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-Ct(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Ct(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-u,s)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-Ct(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return Ep.makeRotationFromQuaternion(e),this.setFromRotationMatrix(Ep,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Tp.setFromEuler(this),this.setFromQuaternion(Tp,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Sa.DEFAULT_ORDER="XYZ";class Oc{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let uv=0;const Cp=new F,yr=new yn,Mi=new rt,el=new F,wo=new F,dv=new F,fv=new yn,Rp=new F(1,0,0),Pp=new F(0,1,0),Ip=new F(0,0,1),pv={type:"added"},Lp={type:"removed"};class mt extends Gi{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:uv++}),this.uuid=In(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=mt.DEFAULT_UP.clone();const e=new F,t=new Sa,n=new yn,i=new F(1,1,1);function s(){n.setFromEuler(t,!1)}function o(){t.setFromQuaternion(n,void 0,!1)}t._onChange(s),n._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new rt},normalMatrix:{value:new lt}}),this.matrix=new rt,this.matrixWorld=new rt,this.matrixAutoUpdate=mt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new Oc,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return yr.setFromAxisAngle(e,t),this.quaternion.multiply(yr),this}rotateOnWorldAxis(e,t){return yr.setFromAxisAngle(e,t),this.quaternion.premultiply(yr),this}rotateX(e){return this.rotateOnAxis(Rp,e)}rotateY(e){return this.rotateOnAxis(Pp,e)}rotateZ(e){return this.rotateOnAxis(Ip,e)}translateOnAxis(e,t){return Cp.copy(e).applyQuaternion(this.quaternion),this.position.add(Cp.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Rp,e)}translateY(e){return this.translateOnAxis(Pp,e)}translateZ(e){return this.translateOnAxis(Ip,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Mi.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?el.copy(e):el.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),wo.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Mi.lookAt(wo,el,this.up):Mi.lookAt(el,wo,this.up),this.quaternion.setFromRotationMatrix(Mi),i&&(Mi.extractRotation(i.matrixWorld),yr.setFromRotationMatrix(Mi),this.quaternion.premultiply(yr.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(pv)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Lp)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Lp)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Mi.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Mi.multiply(e.parent.matrixWorld)),e.applyMatrix4(Mi),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const o=this.children[n].getObjectByProperty(e,t);if(o!==void 0)return o}}getObjectsByProperty(e,t){let n=[];this[e]===t&&n.push(this);for(let i=0,s=this.children.length;i<s;i++){const o=this.children[i].getObjectsByProperty(e,t);o.length>0&&(n=n.concat(o))}return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(wo,e,dv),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(wo,fv,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++){const s=t[n];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.matrixWorldAutoUpdate===!0&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let s=0,o=i.length;s<o;s++){const a=i[s];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const u=l[c];s(e.shapes,u)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));i.material=a}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(s(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),h=o(e.images),u=o(e.shapes),d=o(e.skeletons),f=o(e.animations),p=o(e.nodes);a.length>0&&(n.geometries=a),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),u.length>0&&(n.shapes=u),d.length>0&&(n.skeletons=d),f.length>0&&(n.animations=f),p.length>0&&(n.nodes=p)}return n.object=i,n;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}mt.DEFAULT_UP=new F(0,1,0);mt.DEFAULT_MATRIX_AUTO_UPDATE=!0;mt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const jn=new F,Ai=new F,Uh=new F,Ei=new F,xr=new F,vr=new F,Np=new F,Fh=new F,zh=new F,Vh=new F;let tl=!1,Ws=class Us{constructor(e=new F,t=new F,n=new F){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),jn.subVectors(e,t),i.cross(jn);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,n,i,s){jn.subVectors(i,t),Ai.subVectors(n,t),Uh.subVectors(e,t);const o=jn.dot(jn),a=jn.dot(Ai),l=jn.dot(Uh),c=Ai.dot(Ai),h=Ai.dot(Uh),u=o*c-a*a;if(u===0)return s.set(-2,-1,-1);const d=1/u,f=(c*l-a*h)*d,p=(o*h-a*l)*d;return s.set(1-f-p,p,f)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,Ei),Ei.x>=0&&Ei.y>=0&&Ei.x+Ei.y<=1}static getUV(e,t,n,i,s,o,a,l){return tl===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),tl=!0),this.getInterpolation(e,t,n,i,s,o,a,l)}static getInterpolation(e,t,n,i,s,o,a,l){return this.getBarycoord(e,t,n,i,Ei),l.setScalar(0),l.addScaledVector(s,Ei.x),l.addScaledVector(o,Ei.y),l.addScaledVector(a,Ei.z),l}static isFrontFacing(e,t,n,i){return jn.subVectors(n,t),Ai.subVectors(e,t),jn.cross(Ai).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return jn.subVectors(this.c,this.b),Ai.subVectors(this.a,this.b),jn.cross(Ai).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Us.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Us.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,i,s){return tl===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),tl=!0),Us.getInterpolation(e,this.a,this.b,this.c,t,n,i,s)}getInterpolation(e,t,n,i,s){return Us.getInterpolation(e,this.a,this.b,this.c,t,n,i,s)}containsPoint(e){return Us.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Us.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,s=this.c;let o,a;xr.subVectors(i,n),vr.subVectors(s,n),Fh.subVectors(e,n);const l=xr.dot(Fh),c=vr.dot(Fh);if(l<=0&&c<=0)return t.copy(n);zh.subVectors(e,i);const h=xr.dot(zh),u=vr.dot(zh);if(h>=0&&u<=h)return t.copy(i);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),t.copy(n).addScaledVector(xr,o);Vh.subVectors(e,s);const f=xr.dot(Vh),p=vr.dot(Vh);if(p>=0&&f<=p)return t.copy(s);const _=f*c-l*p;if(_<=0&&c>=0&&p<=0)return a=c/(c-p),t.copy(n).addScaledVector(vr,a);const g=h*p-f*u;if(g<=0&&u-h>=0&&f-p>=0)return Np.subVectors(s,i),a=(u-h)/(u-h+(f-p)),t.copy(i).addScaledVector(Np,a);const m=1/(g+_+d);return o=_*m,a=d*m,t.copy(n).addScaledVector(xr,o).addScaledVector(vr,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}},mv=0;class tn extends Gi{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:mv++}),this.uuid=In(),this.name="",this.type="Material",this.blending=js,this.side=Fi,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=Od,this.blendDst=Dd,this.blendEquation=Vs,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=gc,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=n1,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=uc,this.stencilZFail=uc,this.stencilZPass=uc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==js&&(n.blending=this.blending),this.side!==Fi&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.forceSinglePass===!0&&(n.forceSinglePass=this.forceSinglePass),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(t){const s=i(e.textures),o=i(e.images);s.length>0&&(n.textures=s),o.length>0&&(n.images=o)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let s=0;s!==i;++s)n[s]=t[s].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}const f1={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Yn={h:0,s:0,l:0},nl={h:0,s:0,l:0};function Bh(r,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?r+(e-r)*6*t:t<1/2?e:t<2/3?r+(e-r)*6*(2/3-t):r}class He{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=ot){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Vn.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=Vn.workingColorSpace){return this.r=e,this.g=t,this.b=n,Vn.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=Vn.workingColorSpace){if(e=jd(e,1),t=Ct(t,0,1),n=Ct(n,0,1),t===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+t):n+t-n*t,o=2*n-s;this.r=Bh(o,s,e+1/3),this.g=Bh(o,s,e),this.b=Bh(o,s,e-1/3)}return Vn.toWorkingColorSpace(this,i),this}setStyle(e,t=ot){function n(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return n(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(o===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=ot){const n=f1[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Qr(e.r),this.g=Qr(e.g),this.b=Qr(e.b),this}copyLinearToSRGB(e){return this.r=Ch(e.r),this.g=Ch(e.g),this.b=Ch(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=ot){return Vn.fromWorkingColorSpace(Jt.copy(this),e),Math.round(Ct(Jt.r*255,0,255))*65536+Math.round(Ct(Jt.g*255,0,255))*256+Math.round(Ct(Jt.b*255,0,255))}getHexString(e=ot){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Vn.workingColorSpace){Vn.fromWorkingColorSpace(Jt.copy(this),t);const n=Jt.r,i=Jt.g,s=Jt.b,o=Math.max(n,i,s),a=Math.min(n,i,s);let l,c;const h=(a+o)/2;if(a===o)l=0,c=0;else{const u=o-a;switch(c=h<=.5?u/(o+a):u/(2-o-a),o){case n:l=(i-s)/u+(i<s?6:0);break;case i:l=(s-n)/u+2;break;case s:l=(n-i)/u+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=Vn.workingColorSpace){return Vn.fromWorkingColorSpace(Jt.copy(this),t),e.r=Jt.r,e.g=Jt.g,e.b=Jt.b,e}getStyle(e=ot){Vn.fromWorkingColorSpace(Jt.copy(this),e);const t=Jt.r,n=Jt.g,i=Jt.b;return e!==ot?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(e,t,n){return this.getHSL(Yn),Yn.h+=e,Yn.s+=t,Yn.l+=n,this.setHSL(Yn.h,Yn.s,Yn.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Yn),e.getHSL(nl);const n=jo(Yn.h,nl.h,t),i=jo(Yn.s,nl.s,t),s=jo(Yn.l,nl.l,t);return this.setHSL(n,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,i=this.b,s=e.elements;return this.r=s[0]*t+s[3]*n+s[6]*i,this.g=s[1]*t+s[4]*n+s[7]*i,this.b=s[2]*t+s[5]*n+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const Jt=new He;He.NAMES=f1;class ys extends tn{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new He(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=va,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Ni=gv();function gv(){const r=new ArrayBuffer(4),e=new Float32Array(r),t=new Uint32Array(r),n=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(n[l]=0,n[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(n[l]=1024>>-c-14,n[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(n[l]=c+15<<10,n[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(n[l]=31744,n[l|256]=64512,i[l]=24,i[l|256]=24):(n[l]=31744,n[l|256]=64512,i[l]=13,i[l|256]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;(c&8388608)===0;)c<<=1,h-=8388608;c&=-8388609,h+=947912704,s[l]=c|h}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:t,baseTable:n,shiftTable:i,mantissaTable:s,exponentTable:o,offsetTable:a}}function _n(r){Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),r=Ct(r,-65504,65504),Ni.floatView[0]=r;const e=Ni.uint32View[0],t=e>>23&511;return Ni.baseTable[t]+((e&8388607)>>Ni.shiftTable[t])}function Go(r){const e=r>>10;return Ni.uint32View[0]=Ni.mantissaTable[Ni.offsetTable[e]+(r&1023)]+Ni.exponentTable[e],Ni.floatView[0]}const _v={toHalfFloat:_n,fromHalfFloat:Go},Ot=new F,il=new Te;class vt{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=sa,this.updateRange={offset:0,count:-1},this.gpuType=ui,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)il.fromBufferAttribute(this,t),il.applyMatrix3(e),this.setXY(t,il.x,il.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)Ot.fromBufferAttribute(this,t),Ot.applyMatrix3(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)Ot.fromBufferAttribute(this,t),Ot.applyMatrix4(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Ot.fromBufferAttribute(this,t),Ot.applyNormalMatrix(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Ot.fromBufferAttribute(this,t),Ot.transformDirection(e),this.setXYZ(t,Ot.x,Ot.y,Ot.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Pn(t,this.array)),t}setX(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Pn(t,this.array)),t}setY(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Pn(t,this.array)),t}setZ(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Pn(t,this.array)),t}setW(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array),i=ct(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array),i=ct(i,this.array),s=ct(s,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==sa&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class yv extends vt{constructor(e,t,n){super(new Int8Array(e),t,n)}}class xv extends vt{constructor(e,t,n){super(new Uint8Array(e),t,n)}}class vv extends vt{constructor(e,t,n){super(new Uint8ClampedArray(e),t,n)}}class Sv extends vt{constructor(e,t,n){super(new Int16Array(e),t,n)}}class $d extends vt{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class bv extends vt{constructor(e,t,n){super(new Int32Array(e),t,n)}}class Zd extends vt{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class wv extends vt{constructor(e,t,n){super(new Uint16Array(e),t,n),this.isFloat16BufferAttribute=!0}getX(e){let t=Go(this.array[e*this.itemSize]);return this.normalized&&(t=Pn(t,this.array)),t}setX(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize]=_n(t),this}getY(e){let t=Go(this.array[e*this.itemSize+1]);return this.normalized&&(t=Pn(t,this.array)),t}setY(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize+1]=_n(t),this}getZ(e){let t=Go(this.array[e*this.itemSize+2]);return this.normalized&&(t=Pn(t,this.array)),t}setZ(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize+2]=_n(t),this}getW(e){let t=Go(this.array[e*this.itemSize+3]);return this.normalized&&(t=Pn(t,this.array)),t}setW(e,t){return this.normalized&&(t=ct(t,this.array)),this.array[e*this.itemSize+3]=_n(t),this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array)),this.array[e+0]=_n(t),this.array[e+1]=_n(n),this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array),i=ct(i,this.array)),this.array[e+0]=_n(t),this.array[e+1]=_n(n),this.array[e+2]=_n(i),this}setXYZW(e,t,n,i,s){return e*=this.itemSize,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array),i=ct(i,this.array),s=ct(s,this.array)),this.array[e+0]=_n(t),this.array[e+1]=_n(n),this.array[e+2]=_n(i),this.array[e+3]=_n(s),this}}class je extends vt{constructor(e,t,n){super(new Float32Array(e),t,n)}}class Mv extends vt{constructor(e,t,n){super(new Float64Array(e),t,n)}}let Av=0;const zn=new rt,kh=new mt,Sr=new F,An=new _i,Mo=new _i,Ht=new F;class ht extends Gi{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Av++}),this.uuid=In(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(d1(e)?Zd:$d)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const s=new lt().getNormalMatrix(e);n.applyNormalMatrix(s),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return zn.makeRotationFromQuaternion(e),this.applyMatrix4(zn),this}rotateX(e){return zn.makeRotationX(e),this.applyMatrix4(zn),this}rotateY(e){return zn.makeRotationY(e),this.applyMatrix4(zn),this}rotateZ(e){return zn.makeRotationZ(e),this.applyMatrix4(zn),this}translate(e,t,n){return zn.makeTranslation(e,t,n),this.applyMatrix4(zn),this}scale(e,t,n){return zn.makeScale(e,t,n),this.applyMatrix4(zn),this}lookAt(e){return kh.lookAt(e),kh.updateMatrix(),this.applyMatrix4(kh.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Sr).negate(),this.translate(Sr.x,Sr.y,Sr.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const s=e[n];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new je(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new _i);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new F(-1/0,-1/0,-1/0),new F(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const s=t[n];An.setFromBufferAttribute(s),this.morphTargetsRelative?(Ht.addVectors(this.boundingBox.min,An.min),this.boundingBox.expandByPoint(Ht),Ht.addVectors(this.boundingBox.max,An.max),this.boundingBox.expandByPoint(Ht)):(this.boundingBox.expandByPoint(An.min),this.boundingBox.expandByPoint(An.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ni);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new F,1/0);return}if(e){const n=this.boundingSphere.center;if(An.setFromBufferAttribute(e),t)for(let s=0,o=t.length;s<o;s++){const a=t[s];Mo.setFromBufferAttribute(a),this.morphTargetsRelative?(Ht.addVectors(An.min,Mo.min),An.expandByPoint(Ht),Ht.addVectors(An.max,Mo.max),An.expandByPoint(Ht)):(An.expandByPoint(Mo.min),An.expandByPoint(Mo.max))}An.getCenter(n);let i=0;for(let s=0,o=e.count;s<o;s++)Ht.fromBufferAttribute(e,s),i=Math.max(i,n.distanceToSquared(Ht));if(t)for(let s=0,o=t.length;s<o;s++){const a=t[s],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)Ht.fromBufferAttribute(a,c),l&&(Sr.fromBufferAttribute(e,c),Ht.add(Sr)),i=Math.max(i,n.distanceToSquared(Ht))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,i=t.position.array,s=t.normal.array,o=t.uv.array,a=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new vt(new Float32Array(4*a),4));const l=this.getAttribute("tangent").array,c=[],h=[];for(let A=0;A<a;A++)c[A]=new F,h[A]=new F;const u=new F,d=new F,f=new F,p=new Te,_=new Te,g=new Te,m=new F,v=new F;function y(A,D,k){u.fromArray(i,A*3),d.fromArray(i,D*3),f.fromArray(i,k*3),p.fromArray(o,A*2),_.fromArray(o,D*2),g.fromArray(o,k*2),d.sub(u),f.sub(u),_.sub(p),g.sub(p);const G=1/(_.x*g.y-g.x*_.y);isFinite(G)&&(m.copy(d).multiplyScalar(g.y).addScaledVector(f,-_.y).multiplyScalar(G),v.copy(f).multiplyScalar(_.x).addScaledVector(d,-g.x).multiplyScalar(G),c[A].add(m),c[D].add(m),c[k].add(m),h[A].add(v),h[D].add(v),h[k].add(v))}let S=this.groups;S.length===0&&(S=[{start:0,count:n.length}]);for(let A=0,D=S.length;A<D;++A){const k=S[A],G=k.start,P=k.count;for(let N=G,B=G+P;N<B;N+=3)y(n[N+0],n[N+1],n[N+2])}const b=new F,M=new F,E=new F,T=new F;function w(A){E.fromArray(s,A*3),T.copy(E);const D=c[A];b.copy(D),b.sub(E.multiplyScalar(E.dot(D))).normalize(),M.crossVectors(T,D);const G=M.dot(h[A])<0?-1:1;l[A*4]=b.x,l[A*4+1]=b.y,l[A*4+2]=b.z,l[A*4+3]=G}for(let A=0,D=S.length;A<D;++A){const k=S[A],G=k.start,P=k.count;for(let N=G,B=G+P;N<B;N+=3)w(n[N+0]),w(n[N+1]),w(n[N+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new vt(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let d=0,f=n.count;d<f;d++)n.setXYZ(d,0,0,0);const i=new F,s=new F,o=new F,a=new F,l=new F,c=new F,h=new F,u=new F;if(e)for(let d=0,f=e.count;d<f;d+=3){const p=e.getX(d+0),_=e.getX(d+1),g=e.getX(d+2);i.fromBufferAttribute(t,p),s.fromBufferAttribute(t,_),o.fromBufferAttribute(t,g),h.subVectors(o,s),u.subVectors(i,s),h.cross(u),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,_),c.fromBufferAttribute(n,g),a.add(h),l.add(h),c.add(h),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(_,l.x,l.y,l.z),n.setXYZ(g,c.x,c.y,c.z)}else for(let d=0,f=t.count;d<f;d+=3)i.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),h.subVectors(o,s),u.subVectors(i,s),h.cross(u),n.setXYZ(d+0,h.x,h.y,h.z),n.setXYZ(d+1,h.x,h.y,h.z),n.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(){return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."),this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Ht.fromBufferAttribute(e,t),Ht.normalize(),e.setXYZ(t,Ht.x,Ht.y,Ht.z)}toNonIndexed(){function e(a,l){const c=a.array,h=a.itemSize,u=a.normalized,d=new c.constructor(l.length*h);let f=0,p=0;for(let _=0,g=l.length;_<g;_++){a.isInterleavedBufferAttribute?f=l[_]*a.data.stride+a.offset:f=l[_]*h;for(let m=0;m<h;m++)d[p++]=c[f++]}return new vt(d,h,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new ht,n=this.index.array,i=this.attributes;for(const a in i){const l=i[a],c=e(l,n);t.setAttribute(a,c)}const s=this.morphAttributes;for(const a in s){const l=[],c=s[a];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=e(d,n);l.push(f)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u];h.push(f.toJSON(e.data))}h.length>0&&(i[l]=h,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const h=i[c];this.setAttribute(c,h.clone(t))}const s=e.morphAttributes;for(const c in s){const h=[],u=s[c];for(let d=0,f=u.length;d<f;d++)h.push(u[d].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,h=o.length;c<h;c++){const u=o[c];this.addGroup(u.start,u.count,u.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const Op=new rt,Ts=new ho,sl=new ni,Dp=new F,br=new F,wr=new F,Mr=new F,Gh=new F,rl=new F,ol=new Te,al=new Te,ll=new Te,Up=new F,Fp=new F,zp=new F,cl=new F,hl=new F;let qt=class extends mt{constructor(e=new ht,t=new ys){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,s=n.morphAttributes.position,o=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(s&&a){rl.set(0,0,0);for(let l=0,c=s.length;l<c;l++){const h=a[l],u=s[l];h!==0&&(Gh.fromBufferAttribute(u,e),o?rl.addScaledVector(Gh,h):rl.addScaledVector(Gh.sub(t),h))}t.add(rl)}return t}raycast(e,t){const n=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),sl.copy(n.boundingSphere),sl.applyMatrix4(s),Ts.copy(e.ray).recast(e.near),!(sl.containsPoint(Ts.origin)===!1&&(Ts.intersectSphere(sl,Dp)===null||Ts.origin.distanceToSquared(Dp)>(e.far-e.near)**2))&&(Op.copy(s).invert(),Ts.copy(e.ray).applyMatrix4(Op),!(n.boundingBox!==null&&Ts.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(e,t,Ts)))}_computeIntersections(e,t,n){let i;const s=this.geometry,o=this.material,a=s.index,l=s.attributes.position,c=s.attributes.uv,h=s.attributes.uv1,u=s.attributes.normal,d=s.groups,f=s.drawRange;if(a!==null)if(Array.isArray(o))for(let p=0,_=d.length;p<_;p++){const g=d[p],m=o[g.materialIndex],v=Math.max(g.start,f.start),y=Math.min(a.count,Math.min(g.start+g.count,f.start+f.count));for(let S=v,b=y;S<b;S+=3){const M=a.getX(S),E=a.getX(S+1),T=a.getX(S+2);i=ul(this,m,e,n,c,h,u,M,E,T),i&&(i.faceIndex=Math.floor(S/3),i.face.materialIndex=g.materialIndex,t.push(i))}}else{const p=Math.max(0,f.start),_=Math.min(a.count,f.start+f.count);for(let g=p,m=_;g<m;g+=3){const v=a.getX(g),y=a.getX(g+1),S=a.getX(g+2);i=ul(this,o,e,n,c,h,u,v,y,S),i&&(i.faceIndex=Math.floor(g/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(o))for(let p=0,_=d.length;p<_;p++){const g=d[p],m=o[g.materialIndex],v=Math.max(g.start,f.start),y=Math.min(l.count,Math.min(g.start+g.count,f.start+f.count));for(let S=v,b=y;S<b;S+=3){const M=S,E=S+1,T=S+2;i=ul(this,m,e,n,c,h,u,M,E,T),i&&(i.faceIndex=Math.floor(S/3),i.face.materialIndex=g.materialIndex,t.push(i))}}else{const p=Math.max(0,f.start),_=Math.min(l.count,f.start+f.count);for(let g=p,m=_;g<m;g+=3){const v=g,y=g+1,S=g+2;i=ul(this,o,e,n,c,h,u,v,y,S),i&&(i.faceIndex=Math.floor(g/3),t.push(i))}}}};function Ev(r,e,t,n,i,s,o,a){let l;if(e.side===cn?l=n.intersectTriangle(o,s,i,!0,a):l=n.intersectTriangle(i,s,o,e.side===Fi,a),l===null)return null;hl.copy(a),hl.applyMatrix4(r.matrixWorld);const c=t.ray.origin.distanceTo(hl);return c<t.near||c>t.far?null:{distance:c,point:hl.clone(),object:r}}function ul(r,e,t,n,i,s,o,a,l,c){r.getVertexPosition(a,br),r.getVertexPosition(l,wr),r.getVertexPosition(c,Mr);const h=Ev(r,e,t,n,br,wr,Mr,cl);if(h){i&&(ol.fromBufferAttribute(i,a),al.fromBufferAttribute(i,l),ll.fromBufferAttribute(i,c),h.uv=Ws.getInterpolation(cl,br,wr,Mr,ol,al,ll,new Te)),s&&(ol.fromBufferAttribute(s,a),al.fromBufferAttribute(s,l),ll.fromBufferAttribute(s,c),h.uv1=Ws.getInterpolation(cl,br,wr,Mr,ol,al,ll,new Te),h.uv2=h.uv1),o&&(Up.fromBufferAttribute(o,a),Fp.fromBufferAttribute(o,l),zp.fromBufferAttribute(o,c),h.normal=Ws.getInterpolation(cl,br,wr,Mr,Up,Fp,zp,new F),h.normal.dot(n.direction)>0&&h.normal.multiplyScalar(-1));const u={a,b:l,c,normal:new F,materialIndex:0};Ws.getNormal(br,wr,Mr,u.normal),h.face=u}return h}class xs extends ht{constructor(e=1,t=1,n=1,i=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:s,depthSegments:o};const a=this;i=Math.floor(i),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,n,t,e,o,s,0),p("z","y","x",1,-1,n,t,-e,o,s,1),p("x","z","y",1,1,e,n,t,i,o,2),p("x","z","y",1,-1,e,n,-t,i,o,3),p("x","y","z",1,-1,e,t,n,i,s,4),p("x","y","z",-1,-1,e,t,-n,i,s,5),this.setIndex(l),this.setAttribute("position",new je(c,3)),this.setAttribute("normal",new je(h,3)),this.setAttribute("uv",new je(u,2));function p(_,g,m,v,y,S,b,M,E,T,w){const A=S/E,D=b/T,k=S/2,G=b/2,P=M/2,N=E+1,B=T+1;let H=0,W=0;const $=new F;for(let oe=0;oe<B;oe++){const Se=oe*D-G;for(let K=0;K<N;K++){const ce=K*A-k;$[_]=ce*v,$[g]=Se*y,$[m]=P,c.push($.x,$.y,$.z),$[_]=0,$[g]=0,$[m]=M>0?1:-1,h.push($.x,$.y,$.z),u.push(K/E),u.push(1-oe/T),H+=1}}for(let oe=0;oe<T;oe++)for(let Se=0;Se<E;Se++){const K=d+Se+N*oe,ce=d+Se+N*(oe+1),Z=d+(Se+1)+N*(oe+1),_e=d+(Se+1)+N*oe;l.push(K,ce,_e),l.push(ce,Z,_e),W+=6}a.addGroup(f,W,w),f+=W,d+=H}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new xs(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function oo(r){const e={};for(const t in r){e[t]={};for(const n in r[t]){const i=r[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][n]=null):e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function ln(r){const e={};for(let t=0;t<r.length;t++){const n=oo(r[t]);for(const i in n)e[i]=n[i]}return e}function Tv(r){const e=[];for(let t=0;t<r.length;t++)e.push(r[t].clone());return e}function p1(r){return r.getRenderTarget()===null?r.outputColorSpace:Jn}const m1={clone:oo,merge:ln};var Cv=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Rv=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class gi extends tn{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Cv,this.fragmentShader=Rv,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=oo(e.uniforms),this.uniformsGroups=Tv(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?t.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[i]={type:"m4",value:o.toArray()}:t.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}class Dc extends mt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new rt,this.projectionMatrix=new rt,this.projectionMatrixInverse=new rt,this.coordinateSystem=di}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Yt extends Dc{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=ro*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Ys*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return ro*2*Math.atan(Math.tan(Ys*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,i,s,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Ys*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,s=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;s+=o.offsetX*i/l,t-=o.offsetY*n/c,i*=o.width/l,n*=o.height/c}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-n,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Ar=-90,Er=1;class g1 extends mt{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null;const i=new Yt(Ar,Er,e,t);i.layers=this.layers,this.add(i);const s=new Yt(Ar,Er,e,t);s.layers=this.layers,this.add(s);const o=new Yt(Ar,Er,e,t);o.layers=this.layers,this.add(o);const a=new Yt(Ar,Er,e,t);a.layers=this.layers,this.add(a);const l=new Yt(Ar,Er,e,t);l.layers=this.layers,this.add(l);const c=new Yt(Ar,Er,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[n,i,s,o,a,l]=t;for(const c of t)this.remove(c);if(e===di)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===ra)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[i,s,o,a,l,c]=this.children,h=e.getRenderTarget(),u=e.toneMapping,d=e.xr.enabled;e.toneMapping=fi,e.xr.enabled=!1;const f=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,i),e.setRenderTarget(n,1),e.render(t,s),e.setRenderTarget(n,2),e.render(t,o),e.setRenderTarget(n,3),e.render(t,a),e.setRenderTarget(n,4),e.render(t,l),n.texture.generateMipmaps=f,e.setRenderTarget(n,5),e.render(t,c),e.setRenderTarget(h),e.toneMapping=u,e.xr.enabled=d,n.texture.needsPMREMUpdate=!0}}class ba extends Lt{constructor(e,t,n,i,s,o,a,l,c,h){e=e!==void 0?e:[],t=t!==void 0?t:ds,super(e,t,n,i,s,o,a,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class _1 extends Qn{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];t.encoding!==void 0&&(Yo("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===cs?ot:hs),this.texture=new ba(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:It}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new xs(5,5,5),s=new gi({name:"CubemapFromEquirect",uniforms:oo(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:cn,blending:Di});s.uniforms.tEquirect.value=t;const o=new qt(i,s),a=t.minFilter;return t.minFilter===ps&&(t.minFilter=It),new g1(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,n,i){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,n,i);e.setRenderTarget(s)}}const Hh=new F,Pv=new F,Iv=new lt;class ss{constructor(e=new F(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Hh.subVectors(n,t).cross(Pv.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(Hh),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(e.start).addScaledVector(n,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||Iv.getNormalMatrix(e),i=this.coplanarPoint(Hh).applyMatrix4(e),s=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const Cs=new ni,dl=new F;class Uc{constructor(e=new ss,t=new ss,n=new ss,i=new ss,s=new ss,o=new ss){this.planes=[e,t,n,i,s,o]}set(e,t,n,i,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(n),a[3].copy(i),a[4].copy(s),a[5].copy(o),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=di){const n=this.planes,i=e.elements,s=i[0],o=i[1],a=i[2],l=i[3],c=i[4],h=i[5],u=i[6],d=i[7],f=i[8],p=i[9],_=i[10],g=i[11],m=i[12],v=i[13],y=i[14],S=i[15];if(n[0].setComponents(l-s,d-c,g-f,S-m).normalize(),n[1].setComponents(l+s,d+c,g+f,S+m).normalize(),n[2].setComponents(l+o,d+h,g+p,S+v).normalize(),n[3].setComponents(l-o,d-h,g-p,S-v).normalize(),n[4].setComponents(l-a,d-u,g-_,S-y).normalize(),t===di)n[5].setComponents(l+a,d+u,g+_,S+y).normalize();else if(t===ra)n[5].setComponents(a,u,_,y).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Cs.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Cs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Cs)}intersectsSprite(e){return Cs.center.set(0,0,0),Cs.radius=.7071067811865476,Cs.applyMatrix4(e.matrixWorld),this.intersectsSphere(Cs)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(dl.x=i.normal.x>0?e.max.x:e.min.x,dl.y=i.normal.y>0?e.max.y:e.min.y,dl.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(dl)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function y1(){let r=null,e=!1,t=null,n=null;function i(s,o){t(s,o),n=r.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=r.requestAnimationFrame(i),e=!0)},stop:function(){r.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){r=s}}}function Lv(r,e){const t=e.isWebGL2,n=new WeakMap;function i(c,h){const u=c.array,d=c.usage,f=r.createBuffer();r.bindBuffer(h,f),r.bufferData(h,u,d),c.onUploadCallback();let p;if(u instanceof Float32Array)p=r.FLOAT;else if(u instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)p=r.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else p=r.UNSIGNED_SHORT;else if(u instanceof Int16Array)p=r.SHORT;else if(u instanceof Uint32Array)p=r.UNSIGNED_INT;else if(u instanceof Int32Array)p=r.INT;else if(u instanceof Int8Array)p=r.BYTE;else if(u instanceof Uint8Array)p=r.UNSIGNED_BYTE;else if(u instanceof Uint8ClampedArray)p=r.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+u);return{buffer:f,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function s(c,h,u){const d=h.array,f=h.updateRange;r.bindBuffer(u,c),f.count===-1?r.bufferSubData(u,0,d):(t?r.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):r.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1),h.onUploadCallback()}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),n.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=n.get(c);h&&(r.deleteBuffer(h.buffer),n.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const d=n.get(c);(!d||d.version<c.version)&&n.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=n.get(c);u===void 0?n.set(c,i(c,h)):u.version<c.version&&(s(u.buffer,c,h),u.version=c.version)}return{get:o,remove:a,update:l}}class uo extends ht{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const s=e/2,o=t/2,a=Math.floor(n),l=Math.floor(i),c=a+1,h=l+1,u=e/a,d=t/l,f=[],p=[],_=[],g=[];for(let m=0;m<h;m++){const v=m*d-o;for(let y=0;y<c;y++){const S=y*u-s;p.push(S,-v,0),_.push(0,0,1),g.push(y/a),g.push(1-m/l)}}for(let m=0;m<l;m++)for(let v=0;v<a;v++){const y=v+c*m,S=v+c*(m+1),b=v+1+c*(m+1),M=v+1+c*m;f.push(y,S,M),f.push(S,b,M)}this.setIndex(f),this.setAttribute("position",new je(p,3)),this.setAttribute("normal",new je(_,3)),this.setAttribute("uv",new je(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new uo(e.width,e.height,e.widthSegments,e.heightSegments)}}var Nv=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,Ov=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,Dv=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,Uv=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,Fv=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,zv=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,Vv="vec3 transformed = vec3( position );",Bv=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,kv=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,Gv=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,Hv=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Wv=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Xv=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,jv=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Yv=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,qv=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,$v=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Zv=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Kv=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Jv=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,Qv=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,eS=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,tS=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,nS=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,iS=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,sS=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,rS="gl_FragColor = linearToOutputTexel( gl_FragColor );",oS=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,aS=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,lS=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,cS=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,hS=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,uS=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,dS=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fS=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,pS=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,mS=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gS=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,_S=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,yS=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,xS=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,vS=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,SS=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,bS=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,wS=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,MS=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,AS=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,ES=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,TS=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,CS=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,RS=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,PS=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,IS=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,LS=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,NS=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,OS=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,DS=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,US=`#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,FS=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,zS=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,VS=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,BS=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,kS=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,GS=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,HS=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,WS=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,XS=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,jS=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,YS=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,qS=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,$S=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,ZS=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,KS=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,JS=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,QS=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,eb=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,tb=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,nb=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,ib=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,sb=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,rb=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,ob=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,ab=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,lb=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,cb=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,hb=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,ub=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,db=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,fb=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,pb=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,mb=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,gb=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,_b=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,yb=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,xb=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,vb=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Sb=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,bb=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,wb=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,Mb=`#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Ab=`#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,Eb=`#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,Tb=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const Cb=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Rb=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Pb=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Ib=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Lb=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Nb=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Ob=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Db=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,Ub=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,Fb=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,zb=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,Vb=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Bb=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,kb=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,Gb=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,Hb=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Wb=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Xb=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,jb=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,Yb=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,qb=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,$b=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Zb=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Kb=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Jb=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Qb=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ew=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,tw=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,nw=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,iw=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,sw=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,rw=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ow=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,aw=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,at={alphamap_fragment:Nv,alphamap_pars_fragment:Ov,alphatest_fragment:Dv,alphatest_pars_fragment:Uv,aomap_fragment:Fv,aomap_pars_fragment:zv,begin_vertex:Vv,beginnormal_vertex:Bv,bsdfs:kv,iridescence_fragment:Gv,bumpmap_pars_fragment:Hv,clipping_planes_fragment:Wv,clipping_planes_pars_fragment:Xv,clipping_planes_pars_vertex:jv,clipping_planes_vertex:Yv,color_fragment:qv,color_pars_fragment:$v,color_pars_vertex:Zv,color_vertex:Kv,common:Jv,cube_uv_reflection_fragment:Qv,defaultnormal_vertex:eS,displacementmap_pars_vertex:tS,displacementmap_vertex:nS,emissivemap_fragment:iS,emissivemap_pars_fragment:sS,encodings_fragment:rS,encodings_pars_fragment:oS,envmap_fragment:aS,envmap_common_pars_fragment:lS,envmap_pars_fragment:cS,envmap_pars_vertex:hS,envmap_physical_pars_fragment:bS,envmap_vertex:uS,fog_vertex:dS,fog_pars_vertex:fS,fog_fragment:pS,fog_pars_fragment:mS,gradientmap_pars_fragment:gS,lightmap_fragment:_S,lightmap_pars_fragment:yS,lights_lambert_fragment:xS,lights_lambert_pars_fragment:vS,lights_pars_begin:SS,lights_toon_fragment:wS,lights_toon_pars_fragment:MS,lights_phong_fragment:AS,lights_phong_pars_fragment:ES,lights_physical_fragment:TS,lights_physical_pars_fragment:CS,lights_fragment_begin:RS,lights_fragment_maps:PS,lights_fragment_end:IS,logdepthbuf_fragment:LS,logdepthbuf_pars_fragment:NS,logdepthbuf_pars_vertex:OS,logdepthbuf_vertex:DS,map_fragment:US,map_pars_fragment:FS,map_particle_fragment:zS,map_particle_pars_fragment:VS,metalnessmap_fragment:BS,metalnessmap_pars_fragment:kS,morphcolor_vertex:GS,morphnormal_vertex:HS,morphtarget_pars_vertex:WS,morphtarget_vertex:XS,normal_fragment_begin:jS,normal_fragment_maps:YS,normal_pars_fragment:qS,normal_pars_vertex:$S,normal_vertex:ZS,normalmap_pars_fragment:KS,clearcoat_normal_fragment_begin:JS,clearcoat_normal_fragment_maps:QS,clearcoat_pars_fragment:eb,iridescence_pars_fragment:tb,output_fragment:nb,packing:ib,premultiplied_alpha_fragment:sb,project_vertex:rb,dithering_fragment:ob,dithering_pars_fragment:ab,roughnessmap_fragment:lb,roughnessmap_pars_fragment:cb,shadowmap_pars_fragment:hb,shadowmap_pars_vertex:ub,shadowmap_vertex:db,shadowmask_pars_fragment:fb,skinbase_vertex:pb,skinning_pars_vertex:mb,skinning_vertex:gb,skinnormal_vertex:_b,specularmap_fragment:yb,specularmap_pars_fragment:xb,tonemapping_fragment:vb,tonemapping_pars_fragment:Sb,transmission_fragment:bb,transmission_pars_fragment:wb,uv_pars_fragment:Mb,uv_pars_vertex:Ab,uv_vertex:Eb,worldpos_vertex:Tb,background_vert:Cb,background_frag:Rb,backgroundCube_vert:Pb,backgroundCube_frag:Ib,cube_vert:Lb,cube_frag:Nb,depth_vert:Ob,depth_frag:Db,distanceRGBA_vert:Ub,distanceRGBA_frag:Fb,equirect_vert:zb,equirect_frag:Vb,linedashed_vert:Bb,linedashed_frag:kb,meshbasic_vert:Gb,meshbasic_frag:Hb,meshlambert_vert:Wb,meshlambert_frag:Xb,meshmatcap_vert:jb,meshmatcap_frag:Yb,meshnormal_vert:qb,meshnormal_frag:$b,meshphong_vert:Zb,meshphong_frag:Kb,meshphysical_vert:Jb,meshphysical_frag:Qb,meshtoon_vert:ew,meshtoon_frag:tw,points_vert:nw,points_frag:iw,shadow_vert:sw,shadow_frag:rw,sprite_vert:ow,sprite_frag:aw},ze={common:{diffuse:{value:new He(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new lt},alphaMap:{value:null},alphaMapTransform:{value:new lt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new lt}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new lt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new lt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new lt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new lt},normalScale:{value:new Te(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new lt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new lt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new lt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new lt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new He(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new He(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new lt},alphaTest:{value:0},uvTransform:{value:new lt}},sprite:{diffuse:{value:new He(16777215)},opacity:{value:1},center:{value:new Te(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new lt},alphaMap:{value:null},alphaMapTransform:{value:new lt},alphaTest:{value:0}}},Kn={basic:{uniforms:ln([ze.common,ze.specularmap,ze.envmap,ze.aomap,ze.lightmap,ze.fog]),vertexShader:at.meshbasic_vert,fragmentShader:at.meshbasic_frag},lambert:{uniforms:ln([ze.common,ze.specularmap,ze.envmap,ze.aomap,ze.lightmap,ze.emissivemap,ze.bumpmap,ze.normalmap,ze.displacementmap,ze.fog,ze.lights,{emissive:{value:new He(0)}}]),vertexShader:at.meshlambert_vert,fragmentShader:at.meshlambert_frag},phong:{uniforms:ln([ze.common,ze.specularmap,ze.envmap,ze.aomap,ze.lightmap,ze.emissivemap,ze.bumpmap,ze.normalmap,ze.displacementmap,ze.fog,ze.lights,{emissive:{value:new He(0)},specular:{value:new He(1118481)},shininess:{value:30}}]),vertexShader:at.meshphong_vert,fragmentShader:at.meshphong_frag},standard:{uniforms:ln([ze.common,ze.envmap,ze.aomap,ze.lightmap,ze.emissivemap,ze.bumpmap,ze.normalmap,ze.displacementmap,ze.roughnessmap,ze.metalnessmap,ze.fog,ze.lights,{emissive:{value:new He(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:at.meshphysical_vert,fragmentShader:at.meshphysical_frag},toon:{uniforms:ln([ze.common,ze.aomap,ze.lightmap,ze.emissivemap,ze.bumpmap,ze.normalmap,ze.displacementmap,ze.gradientmap,ze.fog,ze.lights,{emissive:{value:new He(0)}}]),vertexShader:at.meshtoon_vert,fragmentShader:at.meshtoon_frag},matcap:{uniforms:ln([ze.common,ze.bumpmap,ze.normalmap,ze.displacementmap,ze.fog,{matcap:{value:null}}]),vertexShader:at.meshmatcap_vert,fragmentShader:at.meshmatcap_frag},points:{uniforms:ln([ze.points,ze.fog]),vertexShader:at.points_vert,fragmentShader:at.points_frag},dashed:{uniforms:ln([ze.common,ze.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:at.linedashed_vert,fragmentShader:at.linedashed_frag},depth:{uniforms:ln([ze.common,ze.displacementmap]),vertexShader:at.depth_vert,fragmentShader:at.depth_frag},normal:{uniforms:ln([ze.common,ze.bumpmap,ze.normalmap,ze.displacementmap,{opacity:{value:1}}]),vertexShader:at.meshnormal_vert,fragmentShader:at.meshnormal_frag},sprite:{uniforms:ln([ze.sprite,ze.fog]),vertexShader:at.sprite_vert,fragmentShader:at.sprite_frag},background:{uniforms:{uvTransform:{value:new lt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:at.background_vert,fragmentShader:at.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:at.backgroundCube_vert,fragmentShader:at.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:at.cube_vert,fragmentShader:at.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:at.equirect_vert,fragmentShader:at.equirect_frag},distanceRGBA:{uniforms:ln([ze.common,ze.displacementmap,{referencePosition:{value:new F},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:at.distanceRGBA_vert,fragmentShader:at.distanceRGBA_frag},shadow:{uniforms:ln([ze.lights,ze.fog,{color:{value:new He(0)},opacity:{value:1}}]),vertexShader:at.shadow_vert,fragmentShader:at.shadow_frag}};Kn.physical={uniforms:ln([Kn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new lt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new lt},clearcoatNormalScale:{value:new Te(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new lt},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new lt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new lt},sheen:{value:0},sheenColor:{value:new He(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new lt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new lt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new lt},transmissionSamplerSize:{value:new Te},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new lt},attenuationDistance:{value:0},attenuationColor:{value:new He(0)},specularColor:{value:new He(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new lt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new lt},anisotropyVector:{value:new Te},anisotropyMap:{value:null},anisotropyMapTransform:{value:new lt}}]),vertexShader:at.meshphysical_vert,fragmentShader:at.meshphysical_frag};const fl={r:0,b:0,g:0};function lw(r,e,t,n,i,s,o){const a=new He(0);let l=s===!0?0:1,c,h,u=null,d=0,f=null;function p(g,m){let v=!1,y=m.isScene===!0?m.background:null;switch(y&&y.isTexture&&(y=(m.backgroundBlurriness>0?t:e).get(y)),y===null?_(a,l):y&&y.isColor&&(_(y,1),v=!0),r.xr.getEnvironmentBlendMode()){case"opaque":v=!0;break;case"additive":n.buffers.color.setClear(0,0,0,1,o),v=!0;break;case"alpha-blend":n.buffers.color.setClear(0,0,0,0,o),v=!0;break}(r.autoClear||v)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),y&&(y.isCubeTexture||y.mapping===co)?(h===void 0&&(h=new qt(new xs(1,1,1),new gi({name:"BackgroundCubeMaterial",uniforms:oo(Kn.backgroundCube.uniforms),vertexShader:Kn.backgroundCube.vertexShader,fragmentShader:Kn.backgroundCube.fragmentShader,side:cn,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(M,E,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(h)),h.material.uniforms.envMap.value=y,h.material.uniforms.flipEnvMap.value=y.isCubeTexture&&y.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=m.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=m.backgroundIntensity,h.material.toneMapped=y.colorSpace!==ot,(u!==y||d!==y.version||f!==r.toneMapping)&&(h.material.needsUpdate=!0,u=y,d=y.version,f=r.toneMapping),h.layers.enableAll(),g.unshift(h,h.geometry,h.material,0,0,null)):y&&y.isTexture&&(c===void 0&&(c=new qt(new uo(2,2),new gi({name:"BackgroundMaterial",uniforms:oo(Kn.background.uniforms),vertexShader:Kn.background.vertexShader,fragmentShader:Kn.background.fragmentShader,side:Fi,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=y,c.material.uniforms.backgroundIntensity.value=m.backgroundIntensity,c.material.toneMapped=y.colorSpace!==ot,y.matrixAutoUpdate===!0&&y.updateMatrix(),c.material.uniforms.uvTransform.value.copy(y.matrix),(u!==y||d!==y.version||f!==r.toneMapping)&&(c.material.needsUpdate=!0,u=y,d=y.version,f=r.toneMapping),c.layers.enableAll(),g.unshift(c,c.geometry,c.material,0,0,null))}function _(g,m){g.getRGB(fl,p1(r)),n.buffers.color.setClear(fl.r,fl.g,fl.b,m,o)}return{getClearColor:function(){return a},setClearColor:function(g,m=1){a.set(g),l=m,_(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(g){l=g,_(a,l)},render:p}}function cw(r,e,t,n){const i=r.getParameter(r.MAX_VERTEX_ATTRIBS),s=n.isWebGL2?null:e.get("OES_vertex_array_object"),o=n.isWebGL2||s!==null,a={},l=g(null);let c=l,h=!1;function u(P,N,B,H,W){let $=!1;if(o){const oe=_(H,B,N);c!==oe&&(c=oe,f(c.object)),$=m(P,H,B,W),$&&v(P,H,B,W)}else{const oe=N.wireframe===!0;(c.geometry!==H.id||c.program!==B.id||c.wireframe!==oe)&&(c.geometry=H.id,c.program=B.id,c.wireframe=oe,$=!0)}W!==null&&t.update(W,r.ELEMENT_ARRAY_BUFFER),($||h)&&(h=!1,T(P,N,B,H),W!==null&&r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t.get(W).buffer))}function d(){return n.isWebGL2?r.createVertexArray():s.createVertexArrayOES()}function f(P){return n.isWebGL2?r.bindVertexArray(P):s.bindVertexArrayOES(P)}function p(P){return n.isWebGL2?r.deleteVertexArray(P):s.deleteVertexArrayOES(P)}function _(P,N,B){const H=B.wireframe===!0;let W=a[P.id];W===void 0&&(W={},a[P.id]=W);let $=W[N.id];$===void 0&&($={},W[N.id]=$);let oe=$[H];return oe===void 0&&(oe=g(d()),$[H]=oe),oe}function g(P){const N=[],B=[],H=[];for(let W=0;W<i;W++)N[W]=0,B[W]=0,H[W]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:N,enabledAttributes:B,attributeDivisors:H,object:P,attributes:{},index:null}}function m(P,N,B,H){const W=c.attributes,$=N.attributes;let oe=0;const Se=B.getAttributes();for(const K in Se)if(Se[K].location>=0){const Z=W[K];let _e=$[K];if(_e===void 0&&(K==="instanceMatrix"&&P.instanceMatrix&&(_e=P.instanceMatrix),K==="instanceColor"&&P.instanceColor&&(_e=P.instanceColor)),Z===void 0||Z.attribute!==_e||_e&&Z.data!==_e.data)return!0;oe++}return c.attributesNum!==oe||c.index!==H}function v(P,N,B,H){const W={},$=N.attributes;let oe=0;const Se=B.getAttributes();for(const K in Se)if(Se[K].location>=0){let Z=$[K];Z===void 0&&(K==="instanceMatrix"&&P.instanceMatrix&&(Z=P.instanceMatrix),K==="instanceColor"&&P.instanceColor&&(Z=P.instanceColor));const _e={};_e.attribute=Z,Z&&Z.data&&(_e.data=Z.data),W[K]=_e,oe++}c.attributes=W,c.attributesNum=oe,c.index=H}function y(){const P=c.newAttributes;for(let N=0,B=P.length;N<B;N++)P[N]=0}function S(P){b(P,0)}function b(P,N){const B=c.newAttributes,H=c.enabledAttributes,W=c.attributeDivisors;B[P]=1,H[P]===0&&(r.enableVertexAttribArray(P),H[P]=1),W[P]!==N&&((n.isWebGL2?r:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](P,N),W[P]=N)}function M(){const P=c.newAttributes,N=c.enabledAttributes;for(let B=0,H=N.length;B<H;B++)N[B]!==P[B]&&(r.disableVertexAttribArray(B),N[B]=0)}function E(P,N,B,H,W,$,oe){oe===!0?r.vertexAttribIPointer(P,N,B,W,$):r.vertexAttribPointer(P,N,B,H,W,$)}function T(P,N,B,H){if(n.isWebGL2===!1&&(P.isInstancedMesh||H.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;y();const W=H.attributes,$=B.getAttributes(),oe=N.defaultAttributeValues;for(const Se in $){const K=$[Se];if(K.location>=0){let ce=W[Se];if(ce===void 0&&(Se==="instanceMatrix"&&P.instanceMatrix&&(ce=P.instanceMatrix),Se==="instanceColor"&&P.instanceColor&&(ce=P.instanceColor)),ce!==void 0){const Z=ce.normalized,_e=ce.itemSize,xe=t.get(ce);if(xe===void 0)continue;const Ee=xe.buffer,Ne=xe.type,Oe=xe.bytesPerElement,Ve=n.isWebGL2===!0&&(Ne===r.INT||Ne===r.UNSIGNED_INT||ce.gpuType===Fd);if(ce.isInterleavedBufferAttribute){const De=ce.data,z=De.stride,ye=ce.offset;if(De.isInstancedInterleavedBuffer){for(let X=0;X<K.locationSize;X++)b(K.location+X,De.meshPerAttribute);P.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=De.meshPerAttribute*De.count)}else for(let X=0;X<K.locationSize;X++)S(K.location+X);r.bindBuffer(r.ARRAY_BUFFER,Ee);for(let X=0;X<K.locationSize;X++)E(K.location+X,_e/K.locationSize,Ne,Z,z*Oe,(ye+_e/K.locationSize*X)*Oe,Ve)}else{if(ce.isInstancedBufferAttribute){for(let De=0;De<K.locationSize;De++)b(K.location+De,ce.meshPerAttribute);P.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=ce.meshPerAttribute*ce.count)}else for(let De=0;De<K.locationSize;De++)S(K.location+De);r.bindBuffer(r.ARRAY_BUFFER,Ee);for(let De=0;De<K.locationSize;De++)E(K.location+De,_e/K.locationSize,Ne,Z,_e*Oe,_e/K.locationSize*De*Oe,Ve)}}else if(oe!==void 0){const Z=oe[Se];if(Z!==void 0)switch(Z.length){case 2:r.vertexAttrib2fv(K.location,Z);break;case 3:r.vertexAttrib3fv(K.location,Z);break;case 4:r.vertexAttrib4fv(K.location,Z);break;default:r.vertexAttrib1fv(K.location,Z)}}}}M()}function w(){k();for(const P in a){const N=a[P];for(const B in N){const H=N[B];for(const W in H)p(H[W].object),delete H[W];delete N[B]}delete a[P]}}function A(P){if(a[P.id]===void 0)return;const N=a[P.id];for(const B in N){const H=N[B];for(const W in H)p(H[W].object),delete H[W];delete N[B]}delete a[P.id]}function D(P){for(const N in a){const B=a[N];if(B[P.id]===void 0)continue;const H=B[P.id];for(const W in H)p(H[W].object),delete H[W];delete B[P.id]}}function k(){G(),h=!0,c!==l&&(c=l,f(c.object))}function G(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:k,resetDefaultState:G,dispose:w,releaseStatesOfGeometry:A,releaseStatesOfProgram:D,initAttributes:y,enableAttribute:S,disableUnusedAttributes:M}}function hw(r,e,t,n){const i=n.isWebGL2;let s;function o(c){s=c}function a(c,h){r.drawArrays(s,c,h),t.update(h,s,1)}function l(c,h,u){if(u===0)return;let d,f;if(i)d=r,f="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](s,c,h,u),t.update(h,s,u)}this.setMode=o,this.render=a,this.renderInstances=l}function uw(r,e,t){let n;function i(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const E=e.get("EXT_texture_filter_anisotropic");n=r.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function s(E){if(E==="highp"){if(r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.HIGH_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.HIGH_FLOAT).precision>0)return"highp";E="mediump"}return E==="mediump"&&r.getShaderPrecisionFormat(r.VERTEX_SHADER,r.MEDIUM_FLOAT).precision>0&&r.getShaderPrecisionFormat(r.FRAGMENT_SHADER,r.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&r.constructor.name==="WebGL2RenderingContext";let a=t.precision!==void 0?t.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),h=t.logarithmicDepthBuffer===!0,u=r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),d=r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),f=r.getParameter(r.MAX_TEXTURE_SIZE),p=r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),_=r.getParameter(r.MAX_VERTEX_ATTRIBS),g=r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),m=r.getParameter(r.MAX_VARYING_VECTORS),v=r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),y=d>0,S=o||e.has("OES_texture_float"),b=y&&S,M=o?r.getParameter(r.MAX_SAMPLES):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:h,maxTextures:u,maxVertexTextures:d,maxTextureSize:f,maxCubemapSize:p,maxAttributes:_,maxVertexUniforms:g,maxVaryings:m,maxFragmentUniforms:v,vertexTextures:y,floatFragmentTextures:S,floatVertexTextures:b,maxSamples:M}}function dw(r){const e=this;let t=null,n=0,i=!1,s=!1;const o=new ss,a=new lt,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d){const f=u.length!==0||d||n!==0||i;return i=d,n=u.length,f},this.beginShadows=function(){s=!0,h(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(u,d){t=h(u,d,0)},this.setState=function(u,d,f){const p=u.clippingPlanes,_=u.clipIntersection,g=u.clipShadows,m=r.get(u);if(!i||p===null||p.length===0||s&&!g)s?h(null):c();else{const v=s?0:n,y=v*4;let S=m.clippingState||null;l.value=S,S=h(p,d,y,f);for(let b=0;b!==y;++b)S[b]=t[b];m.clippingState=S,this.numIntersection=_?this.numPlanes:0,this.numPlanes+=v}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function h(u,d,f,p){const _=u!==null?u.length:0;let g=null;if(_!==0){if(g=l.value,p!==!0||g===null){const m=f+_*4,v=d.matrixWorldInverse;a.getNormalMatrix(v),(g===null||g.length<m)&&(g=new Float32Array(m));for(let y=0,S=f;y!==_;++y,S+=4)o.copy(u[y]).applyMatrix4(v,a),o.normal.toArray(g,S),g[S+3]=o.constant}l.value=g,l.needsUpdate=!0}return e.numPlanes=_,e.numIntersection=0,g}}function fw(r){let e=new WeakMap;function t(o,a){return a===Ko?o.mapping=ds:a===Jo&&(o.mapping=fs),o}function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Ko||a===Jo)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new _1(l.height/2);return c.fromEquirectangularTexture(r,o),e.set(o,c),o.addEventListener("dispose",i),t(c.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:n,dispose:s}}class Fc extends Dc{constructor(e=-1,t=1,n=1,i=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=n-e,o=n+e,a=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const $r=4,Vp=[.125,.215,.35,.446,.526,.582],Bs=20,Wh=new Fc,Bp=new He;let Xh=null;const Fs=(1+Math.sqrt(5))/2,Tr=1/Fs,kp=[new F(1,1,1),new F(-1,1,1),new F(1,1,-1),new F(-1,1,-1),new F(0,Fs,Tr),new F(0,Fs,-Tr),new F(Tr,0,Fs),new F(-Tr,0,Fs),new F(Fs,Tr,0),new F(-Fs,Tr,0)];class pd{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){Xh=this._renderer.getRenderTarget(),this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,n,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=Wp(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=Hp(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Xh),e.scissorTest=!1,pl(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===ds||e.mapping===fs?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Xh=this._renderer.getRenderTarget();const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:It,minFilter:It,generateMipmaps:!1,type:so,format:Rn,colorSpace:Jn,depthBuffer:!1},i=Gp(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=Gp(e,t,n);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=pw(s)),this._blurMaterial=mw(s,e,t)}return i}_compileMaterial(e){const t=new qt(this._lodPlanes[0],e);this._renderer.compile(t,Wh)}_sceneToCubeUV(e,t,n,i){const a=new Yt(90,1,t,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,u=h.autoClear,d=h.toneMapping;h.getClearColor(Bp),h.toneMapping=fi,h.autoClear=!1;const f=new ys({name:"PMREM.Background",side:cn,depthWrite:!1,depthTest:!1}),p=new qt(new xs,f);let _=!1;const g=e.background;g?g.isColor&&(f.color.copy(g),e.background=null,_=!0):(f.color.copy(Bp),_=!0);for(let m=0;m<6;m++){const v=m%3;v===0?(a.up.set(0,l[m],0),a.lookAt(c[m],0,0)):v===1?(a.up.set(0,0,l[m]),a.lookAt(0,c[m],0)):(a.up.set(0,l[m],0),a.lookAt(0,0,c[m]));const y=this._cubeSize;pl(i,v*y,m>2?y:0,y,y),h.setRenderTarget(i),_&&h.render(p,a),h.render(e,a)}p.geometry.dispose(),p.material.dispose(),h.toneMapping=d,h.autoClear=u,e.background=g}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===ds||e.mapping===fs;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=Wp()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=Hp());const s=i?this._cubemapMaterial:this._equirectMaterial,o=new qt(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;pl(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(o,Wh)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const s=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=kp[(i-1)%kp.length];this._blur(e,i-1,i,s,o)}t.autoClear=n}_blur(e,t,n,i,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,n,i,"latitudinal",s),this._halfBlur(o,e,n,n,i,"longitudinal",s)}_halfBlur(e,t,n,i,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,u=new qt(this._lodPlanes[i],c),d=c.uniforms,f=this._sizeLods[n]-1,p=isFinite(s)?Math.PI/(2*f):2*Math.PI/(2*Bs-1),_=s/p,g=isFinite(s)?1+Math.floor(h*_):Bs;g>Bs&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${Bs}`);const m=[];let v=0;for(let E=0;E<Bs;++E){const T=E/_,w=Math.exp(-T*T/2);m.push(w),E===0?v+=w:E<g&&(v+=2*w)}for(let E=0;E<m.length;E++)m[E]=m[E]/v;d.envMap.value=e.texture,d.samples.value=g,d.weights.value=m,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a);const{_lodMax:y}=this;d.dTheta.value=p,d.mipInt.value=y-n;const S=this._sizeLods[i],b=3*S*(i>y-$r?i-y+$r:0),M=4*(this._cubeSize-S);pl(t,b,M,3*S,2*S),l.setRenderTarget(t),l.render(u,Wh)}}function pw(r){const e=[],t=[],n=[];let i=r;const s=r-$r+1+Vp.length;for(let o=0;o<s;o++){const a=Math.pow(2,i);t.push(a);let l=1/a;o>r-$r?l=Vp[o-r+$r-1]:o===0&&(l=0),n.push(l);const c=1/(a-2),h=-c,u=1+c,d=[h,h,u,h,u,u,h,h,u,u,h,u],f=6,p=6,_=3,g=2,m=1,v=new Float32Array(_*p*f),y=new Float32Array(g*p*f),S=new Float32Array(m*p*f);for(let M=0;M<f;M++){const E=M%3*2/3-1,T=M>2?0:-1,w=[E,T,0,E+2/3,T,0,E+2/3,T+1,0,E,T,0,E+2/3,T+1,0,E,T+1,0];v.set(w,_*p*M),y.set(d,g*p*M);const A=[M,M,M,M,M,M];S.set(A,m*p*M)}const b=new ht;b.setAttribute("position",new vt(v,_)),b.setAttribute("uv",new vt(y,g)),b.setAttribute("faceIndex",new vt(S,m)),e.push(b),i>$r&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function Gp(r,e,t){const n=new Qn(r,e,t);return n.texture.mapping=co,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function pl(r,e,t,n,i){r.viewport.set(e,t,n,i),r.scissor.set(e,t,n,i)}function mw(r,e,t){const n=new Float32Array(Bs),i=new F(0,1,0);return new gi({name:"SphericalGaussianBlur",defines:{n:Bs,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${r}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Kd(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Di,depthTest:!1,depthWrite:!1})}function Hp(){return new gi({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Kd(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Di,depthTest:!1,depthWrite:!1})}function Wp(){return new gi({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Kd(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Di,depthTest:!1,depthWrite:!1})}function Kd(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function gw(r){let e=new WeakMap,t=null;function n(a){if(a&&a.isTexture){const l=a.mapping,c=l===Ko||l===Jo,h=l===ds||l===fs;if(c||h)if(a.isRenderTargetTexture&&a.needsPMREMUpdate===!0){a.needsPMREMUpdate=!1;let u=e.get(a);return t===null&&(t=new pd(r)),u=c?t.fromEquirectangular(a,u):t.fromCubemap(a,u),e.set(a,u),u.texture}else{if(e.has(a))return e.get(a).texture;{const u=a.image;if(c&&u&&u.height>0||h&&u&&i(u)){t===null&&(t=new pd(r));const d=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,d),a.addEventListener("dispose",s),d.texture}else return null}}}return a}function i(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function s(a){const l=a.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:o}}function _w(r){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=r.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const i=t(n);return i===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function yw(r,e,t,n){const i={},s=new WeakMap;function o(u){const d=u.target;d.index!==null&&e.remove(d.index);for(const p in d.attributes)e.remove(d.attributes[p]);for(const p in d.morphAttributes){const _=d.morphAttributes[p];for(let g=0,m=_.length;g<m;g++)e.remove(_[g])}d.removeEventListener("dispose",o),delete i[d.id];const f=s.get(d);f&&(e.remove(f),s.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(u,d){return i[d.id]===!0||(d.addEventListener("dispose",o),i[d.id]=!0,t.memory.geometries++),d}function l(u){const d=u.attributes;for(const p in d)e.update(d[p],r.ARRAY_BUFFER);const f=u.morphAttributes;for(const p in f){const _=f[p];for(let g=0,m=_.length;g<m;g++)e.update(_[g],r.ARRAY_BUFFER)}}function c(u){const d=[],f=u.index,p=u.attributes.position;let _=0;if(f!==null){const v=f.array;_=f.version;for(let y=0,S=v.length;y<S;y+=3){const b=v[y+0],M=v[y+1],E=v[y+2];d.push(b,M,M,E,E,b)}}else{const v=p.array;_=p.version;for(let y=0,S=v.length/3-1;y<S;y+=3){const b=y+0,M=y+1,E=y+2;d.push(b,M,M,E,E,b)}}const g=new(d1(d)?Zd:$d)(d,1);g.version=_;const m=s.get(u);m&&e.remove(m),s.set(u,g)}function h(u){const d=s.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return s.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function xw(r,e,t,n){const i=n.isWebGL2;let s;function o(d){s=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function h(d,f){r.drawElements(s,f,a,d*l),t.update(f,s,1)}function u(d,f,p){if(p===0)return;let _,g;if(i)_=r,g="drawElementsInstanced";else if(_=e.get("ANGLE_instanced_arrays"),g="drawElementsInstancedANGLE",_===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}_[g](s,f,a,d*l,p),t.update(f,s,p)}this.setMode=o,this.setIndex=c,this.render=h,this.renderInstances=u}function vw(r){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(s,o,a){switch(t.calls++,o){case r.TRIANGLES:t.triangles+=a*(s/3);break;case r.LINES:t.lines+=a*(s/2);break;case r.LINE_STRIP:t.lines+=a*(s-1);break;case r.LINE_LOOP:t.lines+=a*s;break;case r.POINTS:t.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}function Sw(r,e){return r[0]-e[0]}function bw(r,e){return Math.abs(e[1])-Math.abs(r[1])}function ww(r,e,t){const n={},i=new Float32Array(8),s=new WeakMap,o=new _t,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,h,u){const d=c.morphTargetInfluences;if(e.isWebGL2===!0){const f=h.morphAttributes.position||h.morphAttributes.normal||h.morphAttributes.color,p=f!==void 0?f.length:0;let _=s.get(h);if(_===void 0||_.count!==p){let v=function(){G.dispose(),s.delete(h),h.removeEventListener("dispose",v)};_!==void 0&&_.texture.dispose();const y=h.morphAttributes.position!==void 0,S=h.morphAttributes.normal!==void 0,b=h.morphAttributes.color!==void 0,M=h.morphAttributes.position||[],E=h.morphAttributes.normal||[],T=h.morphAttributes.color||[];let w=0;y===!0&&(w=1),S===!0&&(w=2),b===!0&&(w=3);let A=h.attributes.position.count*w,D=1;A>e.maxTextureSize&&(D=Math.ceil(A/e.maxTextureSize),A=e.maxTextureSize);const k=new Float32Array(A*D*4*p),G=new Nc(k,A,D,p);G.type=ui,G.needsUpdate=!0;const P=w*4;for(let N=0;N<p;N++){const B=M[N],H=E[N],W=T[N],$=A*D*4*N;for(let oe=0;oe<B.count;oe++){const Se=oe*P;y===!0&&(o.fromBufferAttribute(B,oe),k[$+Se+0]=o.x,k[$+Se+1]=o.y,k[$+Se+2]=o.z,k[$+Se+3]=0),S===!0&&(o.fromBufferAttribute(H,oe),k[$+Se+4]=o.x,k[$+Se+5]=o.y,k[$+Se+6]=o.z,k[$+Se+7]=0),b===!0&&(o.fromBufferAttribute(W,oe),k[$+Se+8]=o.x,k[$+Se+9]=o.y,k[$+Se+10]=o.z,k[$+Se+11]=W.itemSize===4?o.w:1)}}_={count:p,texture:G,size:new Te(A,D)},s.set(h,_),h.addEventListener("dispose",v)}let g=0;for(let v=0;v<d.length;v++)g+=d[v];const m=h.morphTargetsRelative?1:1-g;u.getUniforms().setValue(r,"morphTargetBaseInfluence",m),u.getUniforms().setValue(r,"morphTargetInfluences",d),u.getUniforms().setValue(r,"morphTargetsTexture",_.texture,t),u.getUniforms().setValue(r,"morphTargetsTextureSize",_.size)}else{const f=d===void 0?0:d.length;let p=n[h.id];if(p===void 0||p.length!==f){p=[];for(let y=0;y<f;y++)p[y]=[y,0];n[h.id]=p}for(let y=0;y<f;y++){const S=p[y];S[0]=y,S[1]=d[y]}p.sort(bw);for(let y=0;y<8;y++)y<f&&p[y][1]?(a[y][0]=p[y][0],a[y][1]=p[y][1]):(a[y][0]=Number.MAX_SAFE_INTEGER,a[y][1]=0);a.sort(Sw);const _=h.morphAttributes.position,g=h.morphAttributes.normal;let m=0;for(let y=0;y<8;y++){const S=a[y],b=S[0],M=S[1];b!==Number.MAX_SAFE_INTEGER&&M?(_&&h.getAttribute("morphTarget"+y)!==_[b]&&h.setAttribute("morphTarget"+y,_[b]),g&&h.getAttribute("morphNormal"+y)!==g[b]&&h.setAttribute("morphNormal"+y,g[b]),i[y]=M,m+=M):(_&&h.hasAttribute("morphTarget"+y)===!0&&h.deleteAttribute("morphTarget"+y),g&&h.hasAttribute("morphNormal"+y)===!0&&h.deleteAttribute("morphNormal"+y),i[y]=0)}const v=h.morphTargetsRelative?1:1-m;u.getUniforms().setValue(r,"morphTargetBaseInfluence",v),u.getUniforms().setValue(r,"morphTargetInfluences",i)}}return{update:l}}function Mw(r,e,t,n){let i=new WeakMap;function s(l){const c=n.render.frame,h=l.geometry,u=e.get(l,h);return i.get(u)!==c&&(e.update(u),i.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,r.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,r.ARRAY_BUFFER)),u}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:s,dispose:o}}const x1=new Lt,v1=new Nc,S1=new qd,b1=new ba,Xp=[],jp=[],Yp=new Float32Array(16),qp=new Float32Array(9),$p=new Float32Array(4);function fo(r,e,t){const n=r[0];if(n<=0||n>0)return r;const i=e*t;let s=Xp[i];if(s===void 0&&(s=new Float32Array(i),Xp[i]=s),e!==0){n.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=t,r[o].toArray(s,a)}return s}function zt(r,e){if(r.length!==e.length)return!1;for(let t=0,n=r.length;t<n;t++)if(r[t]!==e[t])return!1;return!0}function Vt(r,e){for(let t=0,n=e.length;t<n;t++)r[t]=e[t]}function zc(r,e){let t=jp[e];t===void 0&&(t=new Int32Array(e),jp[e]=t);for(let n=0;n!==e;++n)t[n]=r.allocateTextureUnit();return t}function Aw(r,e){const t=this.cache;t[0]!==e&&(r.uniform1f(this.addr,e),t[0]=e)}function Ew(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(zt(t,e))return;r.uniform2fv(this.addr,e),Vt(t,e)}}function Tw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(zt(t,e))return;r.uniform3fv(this.addr,e),Vt(t,e)}}function Cw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(zt(t,e))return;r.uniform4fv(this.addr,e),Vt(t,e)}}function Rw(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(zt(t,e))return;r.uniformMatrix2fv(this.addr,!1,e),Vt(t,e)}else{if(zt(t,n))return;$p.set(n),r.uniformMatrix2fv(this.addr,!1,$p),Vt(t,n)}}function Pw(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(zt(t,e))return;r.uniformMatrix3fv(this.addr,!1,e),Vt(t,e)}else{if(zt(t,n))return;qp.set(n),r.uniformMatrix3fv(this.addr,!1,qp),Vt(t,n)}}function Iw(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(zt(t,e))return;r.uniformMatrix4fv(this.addr,!1,e),Vt(t,e)}else{if(zt(t,n))return;Yp.set(n),r.uniformMatrix4fv(this.addr,!1,Yp),Vt(t,n)}}function Lw(r,e){const t=this.cache;t[0]!==e&&(r.uniform1i(this.addr,e),t[0]=e)}function Nw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(zt(t,e))return;r.uniform2iv(this.addr,e),Vt(t,e)}}function Ow(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(zt(t,e))return;r.uniform3iv(this.addr,e),Vt(t,e)}}function Dw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(zt(t,e))return;r.uniform4iv(this.addr,e),Vt(t,e)}}function Uw(r,e){const t=this.cache;t[0]!==e&&(r.uniform1ui(this.addr,e),t[0]=e)}function Fw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(zt(t,e))return;r.uniform2uiv(this.addr,e),Vt(t,e)}}function zw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(zt(t,e))return;r.uniform3uiv(this.addr,e),Vt(t,e)}}function Vw(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(zt(t,e))return;r.uniform4uiv(this.addr,e),Vt(t,e)}}function Bw(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2D(e||x1,i)}function kw(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||S1,i)}function Gw(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||b1,i)}function Hw(r,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(r.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||v1,i)}function Ww(r){switch(r){case 5126:return Aw;case 35664:return Ew;case 35665:return Tw;case 35666:return Cw;case 35674:return Rw;case 35675:return Pw;case 35676:return Iw;case 5124:case 35670:return Lw;case 35667:case 35671:return Nw;case 35668:case 35672:return Ow;case 35669:case 35673:return Dw;case 5125:return Uw;case 36294:return Fw;case 36295:return zw;case 36296:return Vw;case 35678:case 36198:case 36298:case 36306:case 35682:return Bw;case 35679:case 36299:case 36307:return kw;case 35680:case 36300:case 36308:case 36293:return Gw;case 36289:case 36303:case 36311:case 36292:return Hw}}function Xw(r,e){r.uniform1fv(this.addr,e)}function jw(r,e){const t=fo(e,this.size,2);r.uniform2fv(this.addr,t)}function Yw(r,e){const t=fo(e,this.size,3);r.uniform3fv(this.addr,t)}function qw(r,e){const t=fo(e,this.size,4);r.uniform4fv(this.addr,t)}function $w(r,e){const t=fo(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,t)}function Zw(r,e){const t=fo(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,t)}function Kw(r,e){const t=fo(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,t)}function Jw(r,e){r.uniform1iv(this.addr,e)}function Qw(r,e){r.uniform2iv(this.addr,e)}function eM(r,e){r.uniform3iv(this.addr,e)}function tM(r,e){r.uniform4iv(this.addr,e)}function nM(r,e){r.uniform1uiv(this.addr,e)}function iM(r,e){r.uniform2uiv(this.addr,e)}function sM(r,e){r.uniform3uiv(this.addr,e)}function rM(r,e){r.uniform4uiv(this.addr,e)}function oM(r,e,t){const n=this.cache,i=e.length,s=zc(t,i);zt(n,s)||(r.uniform1iv(this.addr,s),Vt(n,s));for(let o=0;o!==i;++o)t.setTexture2D(e[o]||x1,s[o])}function aM(r,e,t){const n=this.cache,i=e.length,s=zc(t,i);zt(n,s)||(r.uniform1iv(this.addr,s),Vt(n,s));for(let o=0;o!==i;++o)t.setTexture3D(e[o]||S1,s[o])}function lM(r,e,t){const n=this.cache,i=e.length,s=zc(t,i);zt(n,s)||(r.uniform1iv(this.addr,s),Vt(n,s));for(let o=0;o!==i;++o)t.setTextureCube(e[o]||b1,s[o])}function cM(r,e,t){const n=this.cache,i=e.length,s=zc(t,i);zt(n,s)||(r.uniform1iv(this.addr,s),Vt(n,s));for(let o=0;o!==i;++o)t.setTexture2DArray(e[o]||v1,s[o])}function hM(r){switch(r){case 5126:return Xw;case 35664:return jw;case 35665:return Yw;case 35666:return qw;case 35674:return $w;case 35675:return Zw;case 35676:return Kw;case 5124:case 35670:return Jw;case 35667:case 35671:return Qw;case 35668:case 35672:return eM;case 35669:case 35673:return tM;case 5125:return nM;case 36294:return iM;case 36295:return sM;case 36296:return rM;case 35678:case 36198:case 36298:case 36306:case 35682:return oM;case 35679:case 36299:case 36307:return aM;case 35680:case 36300:case 36308:case 36293:return lM;case 36289:case 36303:case 36311:case 36292:return cM}}class uM{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=Ww(t.type)}}class dM{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=hM(t.type)}}class fM{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let s=0,o=i.length;s!==o;++s){const a=i[s];a.setValue(e,t[a.id],n)}}}const jh=/(\w+)(\])?(\[|\.)?/g;function Zp(r,e){r.seq.push(e),r.map[e.id]=e}function pM(r,e,t){const n=r.name,i=n.length;for(jh.lastIndex=0;;){const s=jh.exec(n),o=jh.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){Zp(t,c===void 0?new uM(a,r,e):new dM(a,r,e));break}else{let u=t.map[a];u===void 0&&(u=new fM(a),Zp(t,u)),t=u}}}class dc{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const s=e.getActiveUniform(t,i),o=e.getUniformLocation(t,s.name);pM(s,o,this)}}setValue(e,t,n,i){const s=this.map[t];s!==void 0&&s.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let s=0,o=t.length;s!==o;++s){const a=t[s],l=n[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,s=e.length;i!==s;++i){const o=e[i];o.id in t&&n.push(o)}return n}}function Kp(r,e,t){const n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),n}let mM=0;function gM(r,e){const t=r.split(`
`),n=[],i=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let o=i;o<s;o++){const a=o+1;n.push(`${a===e?">":" "} ${a}: ${t[o]}`)}return n.join(`
`)}function _M(r){switch(r){case Jn:return["Linear","( value )"];case ot:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",r),["Linear","( value )"]}}function Jp(r,e,t){const n=r.getShaderParameter(e,r.COMPILE_STATUS),i=r.getShaderInfoLog(e).trim();if(n&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const o=parseInt(s[1]);return t.toUpperCase()+`

`+i+`

`+gM(r.getShaderSource(e),o)}else return i}function yM(r,e){const t=_M(e);return"vec4 "+r+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function xM(r,e){let t;switch(e){case U_:t="Linear";break;case F_:t="Reinhard";break;case z_:t="OptimizedCineon";break;case V_:t="ACESFilmic";break;case B_:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+r+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function vM(r){return[r.extensionDerivatives||r.envMapCubeUVHeight||r.bumpMap||r.normalMapTangentSpace||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap||r.transmission)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Ho).join(`
`)}function SM(r){const e=[];for(const t in r){const n=r[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function bM(r,e){const t={},n=r.getProgramParameter(e,r.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const s=r.getActiveAttrib(e,i),o=s.name;let a=1;s.type===r.FLOAT_MAT2&&(a=2),s.type===r.FLOAT_MAT3&&(a=3),s.type===r.FLOAT_MAT4&&(a=4),t[o]={type:s.type,location:r.getAttribLocation(e,o),locationSize:a}}return t}function Ho(r){return r!==""}function Qp(r,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function em(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const wM=/^[ \t]*#include +<([\w\d./]+)>/gm;function md(r){return r.replace(wM,MM)}function MM(r,e){const t=at[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return md(t)}const AM=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function tm(r){return r.replace(AM,EM)}function EM(r,e,t,n){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function nm(r){let e="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function TM(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===Nd?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===p_?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===li&&(e="SHADOWMAP_TYPE_VSM"),e}function CM(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case ds:case fs:e="ENVMAP_TYPE_CUBE";break;case co:e="ENVMAP_TYPE_CUBE_UV";break}return e}function RM(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case fs:e="ENVMAP_MODE_REFRACTION";break}return e}function PM(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case va:e="ENVMAP_BLENDING_MULTIPLY";break;case O_:e="ENVMAP_BLENDING_MIX";break;case D_:e="ENVMAP_BLENDING_ADD";break}return e}function IM(r){const e=r.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),112)),texelHeight:n,maxMip:t}}function LM(r,e,t,n){const i=r.getContext(),s=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=TM(t),c=CM(t),h=RM(t),u=PM(t),d=IM(t),f=t.isWebGL2?"":vM(t),p=SM(s),_=i.createProgram();let g,m,v=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(g=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p].filter(Ho).join(`
`),g.length>0&&(g+=`
`),m=[f,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p].filter(Ho).join(`
`),m.length>0&&(m+=`
`)):(g=[nm(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Ho).join(`
`),m=[f,nm(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+u:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==fi?"#define TONE_MAPPING":"",t.toneMapping!==fi?at.tonemapping_pars_fragment:"",t.toneMapping!==fi?xM("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",at.encodings_pars_fragment,yM("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Ho).join(`
`)),o=md(o),o=Qp(o,t),o=em(o,t),a=md(a),a=Qp(a,t),a=em(a,t),o=tm(o),a=tm(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(v=`#version 300 es
`,g=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+g,m=["#define varying in",t.glslVersion===dd?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===dd?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+m);const y=v+g+o,S=v+m+a,b=Kp(i,i.VERTEX_SHADER,y),M=Kp(i,i.FRAGMENT_SHADER,S);if(i.attachShader(_,b),i.attachShader(_,M),t.index0AttributeName!==void 0?i.bindAttribLocation(_,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(_,0,"position"),i.linkProgram(_),r.debug.checkShaderErrors){const w=i.getProgramInfoLog(_).trim(),A=i.getShaderInfoLog(b).trim(),D=i.getShaderInfoLog(M).trim();let k=!0,G=!0;if(i.getProgramParameter(_,i.LINK_STATUS)===!1)if(k=!1,typeof r.debug.onShaderError=="function")r.debug.onShaderError(i,_,b,M);else{const P=Jp(i,b,"vertex"),N=Jp(i,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(_,i.VALIDATE_STATUS)+`

Program Info Log: `+w+`
`+P+`
`+N)}else w!==""?console.warn("THREE.WebGLProgram: Program Info Log:",w):(A===""||D==="")&&(G=!1);G&&(this.diagnostics={runnable:k,programLog:w,vertexShader:{log:A,prefix:g},fragmentShader:{log:D,prefix:m}})}i.deleteShader(b),i.deleteShader(M);let E;this.getUniforms=function(){return E===void 0&&(E=new dc(i,_)),E};let T;return this.getAttributes=function(){return T===void 0&&(T=bM(i,_)),T},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(_),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=mM++,this.cacheKey=e,this.usedTimes=1,this.program=_,this.vertexShader=b,this.fragmentShader=M,this}let NM=0;class OM{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),s=this._getShaderStage(n),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new DM(e),t.set(e,n)),n}}class DM{constructor(e){this.id=NM++,this.code=e,this.usedTimes=0}}function UM(r,e,t,n,i,s,o){const a=new Oc,l=new OM,c=[],h=i.isWebGL2,u=i.logarithmicDepthBuffer,d=i.vertexTextures;let f=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function _(w){return w===0?"uv":`uv${w}`}function g(w,A,D,k,G){const P=k.fog,N=G.geometry,B=w.isMeshStandardMaterial?k.environment:null,H=(w.isMeshStandardMaterial?t:e).get(w.envMap||B),W=H&&H.mapping===co?H.image.height:null,$=p[w.type];w.precision!==null&&(f=i.getMaxPrecision(w.precision),f!==w.precision&&console.warn("THREE.WebGLProgram.getParameters:",w.precision,"not supported, using",f,"instead."));const oe=N.morphAttributes.position||N.morphAttributes.normal||N.morphAttributes.color,Se=oe!==void 0?oe.length:0;let K=0;N.morphAttributes.position!==void 0&&(K=1),N.morphAttributes.normal!==void 0&&(K=2),N.morphAttributes.color!==void 0&&(K=3);let ce,Z,_e,xe;if($){const We=Kn[$];ce=We.vertexShader,Z=We.fragmentShader}else ce=w.vertexShader,Z=w.fragmentShader,l.update(w),_e=l.getVertexShaderID(w),xe=l.getFragmentShaderID(w);const Ee=r.getRenderTarget(),Ne=G.isInstancedMesh===!0,Oe=!!w.map,Ve=!!w.matcap,De=!!H,z=!!w.aoMap,ye=!!w.lightMap,X=!!w.bumpMap,ie=!!w.normalMap,ne=!!w.displacementMap,Ae=!!w.emissiveMap,Pe=!!w.metalnessMap,Ie=!!w.roughnessMap,Ge=w.anisotropy>0,Ye=w.clearcoat>0,et=w.iridescence>0,U=w.sheen>0,I=w.transmission>0,fe=Ge&&!!w.anisotropyMap,Ce=Ye&&!!w.clearcoatMap,Re=Ye&&!!w.clearcoatNormalMap,Ue=Ye&&!!w.clearcoatRoughnessMap,ke=et&&!!w.iridescenceMap,C=et&&!!w.iridescenceThicknessMap,R=U&&!!w.sheenColorMap,O=U&&!!w.sheenRoughnessMap,j=!!w.specularMap,q=!!w.specularColorMap,he=!!w.specularIntensityMap,ee=I&&!!w.transmissionMap,we=I&&!!w.thicknessMap,Le=!!w.gradientMap,V=!!w.alphaMap,Me=w.alphaTest>0,se=!!w.extensions,ae=!!N.attributes.uv1,ge=!!N.attributes.uv2,Fe=!!N.attributes.uv3;return{isWebGL2:h,shaderID:$,shaderType:w.type,shaderName:w.name,vertexShader:ce,fragmentShader:Z,defines:w.defines,customVertexShaderID:_e,customFragmentShaderID:xe,isRawShaderMaterial:w.isRawShaderMaterial===!0,glslVersion:w.glslVersion,precision:f,instancing:Ne,instancingColor:Ne&&G.instanceColor!==null,supportsVertexTextures:d,outputColorSpace:Ee===null?r.outputColorSpace:Ee.isXRRenderTarget===!0?Ee.texture.colorSpace:Jn,map:Oe,matcap:Ve,envMap:De,envMapMode:De&&H.mapping,envMapCubeUVHeight:W,aoMap:z,lightMap:ye,bumpMap:X,normalMap:ie,displacementMap:d&&ne,emissiveMap:Ae,normalMapObjectSpace:ie&&w.normalMapType===t1,normalMapTangentSpace:ie&&w.normalMapType===_s,metalnessMap:Pe,roughnessMap:Ie,anisotropy:Ge,anisotropyMap:fe,clearcoat:Ye,clearcoatMap:Ce,clearcoatNormalMap:Re,clearcoatRoughnessMap:Ue,iridescence:et,iridescenceMap:ke,iridescenceThicknessMap:C,sheen:U,sheenColorMap:R,sheenRoughnessMap:O,specularMap:j,specularColorMap:q,specularIntensityMap:he,transmission:I,transmissionMap:ee,thicknessMap:we,gradientMap:Le,opaque:w.transparent===!1&&w.blending===js,alphaMap:V,alphaTest:Me,combine:w.combine,mapUv:Oe&&_(w.map.channel),aoMapUv:z&&_(w.aoMap.channel),lightMapUv:ye&&_(w.lightMap.channel),bumpMapUv:X&&_(w.bumpMap.channel),normalMapUv:ie&&_(w.normalMap.channel),displacementMapUv:ne&&_(w.displacementMap.channel),emissiveMapUv:Ae&&_(w.emissiveMap.channel),metalnessMapUv:Pe&&_(w.metalnessMap.channel),roughnessMapUv:Ie&&_(w.roughnessMap.channel),anisotropyMapUv:fe&&_(w.anisotropyMap.channel),clearcoatMapUv:Ce&&_(w.clearcoatMap.channel),clearcoatNormalMapUv:Re&&_(w.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Ue&&_(w.clearcoatRoughnessMap.channel),iridescenceMapUv:ke&&_(w.iridescenceMap.channel),iridescenceThicknessMapUv:C&&_(w.iridescenceThicknessMap.channel),sheenColorMapUv:R&&_(w.sheenColorMap.channel),sheenRoughnessMapUv:O&&_(w.sheenRoughnessMap.channel),specularMapUv:j&&_(w.specularMap.channel),specularColorMapUv:q&&_(w.specularColorMap.channel),specularIntensityMapUv:he&&_(w.specularIntensityMap.channel),transmissionMapUv:ee&&_(w.transmissionMap.channel),thicknessMapUv:we&&_(w.thicknessMap.channel),alphaMapUv:V&&_(w.alphaMap.channel),vertexTangents:!!N.attributes.tangent&&(ie||Ge),vertexColors:w.vertexColors,vertexAlphas:w.vertexColors===!0&&!!N.attributes.color&&N.attributes.color.itemSize===4,vertexUv1s:ae,vertexUv2s:ge,vertexUv3s:Fe,pointsUvs:G.isPoints===!0&&!!N.attributes.uv&&(Oe||V),fog:!!P,useFog:w.fog===!0,fogExp2:P&&P.isFogExp2,flatShading:w.flatShading===!0,sizeAttenuation:w.sizeAttenuation===!0,logarithmicDepthBuffer:u,skinning:G.isSkinnedMesh===!0,morphTargets:N.morphAttributes.position!==void 0,morphNormals:N.morphAttributes.normal!==void 0,morphColors:N.morphAttributes.color!==void 0,morphTargetsCount:Se,morphTextureStride:K,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numSpotLightMaps:A.spotLightMap.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numSpotLightShadowsWithMaps:A.numSpotLightShadowsWithMaps,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:w.dithering,shadowMapEnabled:r.shadowMap.enabled&&D.length>0,shadowMapType:r.shadowMap.type,toneMapping:w.toneMapped?r.toneMapping:fi,useLegacyLights:r.useLegacyLights,premultipliedAlpha:w.premultipliedAlpha,doubleSided:w.side===hi,flipSided:w.side===cn,useDepthPacking:w.depthPacking>=0,depthPacking:w.depthPacking||0,index0AttributeName:w.index0AttributeName,extensionDerivatives:se&&w.extensions.derivatives===!0,extensionFragDepth:se&&w.extensions.fragDepth===!0,extensionDrawBuffers:se&&w.extensions.drawBuffers===!0,extensionShaderTextureLOD:se&&w.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:h||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||n.has("EXT_shader_texture_lod"),customProgramCacheKey:w.customProgramCacheKey()}}function m(w){const A=[];if(w.shaderID?A.push(w.shaderID):(A.push(w.customVertexShaderID),A.push(w.customFragmentShaderID)),w.defines!==void 0)for(const D in w.defines)A.push(D),A.push(w.defines[D]);return w.isRawShaderMaterial===!1&&(v(A,w),y(A,w),A.push(r.outputColorSpace)),A.push(w.customProgramCacheKey),A.join()}function v(w,A){w.push(A.precision),w.push(A.outputColorSpace),w.push(A.envMapMode),w.push(A.envMapCubeUVHeight),w.push(A.mapUv),w.push(A.alphaMapUv),w.push(A.lightMapUv),w.push(A.aoMapUv),w.push(A.bumpMapUv),w.push(A.normalMapUv),w.push(A.displacementMapUv),w.push(A.emissiveMapUv),w.push(A.metalnessMapUv),w.push(A.roughnessMapUv),w.push(A.anisotropyMapUv),w.push(A.clearcoatMapUv),w.push(A.clearcoatNormalMapUv),w.push(A.clearcoatRoughnessMapUv),w.push(A.iridescenceMapUv),w.push(A.iridescenceThicknessMapUv),w.push(A.sheenColorMapUv),w.push(A.sheenRoughnessMapUv),w.push(A.specularMapUv),w.push(A.specularColorMapUv),w.push(A.specularIntensityMapUv),w.push(A.transmissionMapUv),w.push(A.thicknessMapUv),w.push(A.combine),w.push(A.fogExp2),w.push(A.sizeAttenuation),w.push(A.morphTargetsCount),w.push(A.morphAttributeCount),w.push(A.numDirLights),w.push(A.numPointLights),w.push(A.numSpotLights),w.push(A.numSpotLightMaps),w.push(A.numHemiLights),w.push(A.numRectAreaLights),w.push(A.numDirLightShadows),w.push(A.numPointLightShadows),w.push(A.numSpotLightShadows),w.push(A.numSpotLightShadowsWithMaps),w.push(A.shadowMapType),w.push(A.toneMapping),w.push(A.numClippingPlanes),w.push(A.numClipIntersection),w.push(A.depthPacking)}function y(w,A){a.disableAll(),A.isWebGL2&&a.enable(0),A.supportsVertexTextures&&a.enable(1),A.instancing&&a.enable(2),A.instancingColor&&a.enable(3),A.matcap&&a.enable(4),A.envMap&&a.enable(5),A.normalMapObjectSpace&&a.enable(6),A.normalMapTangentSpace&&a.enable(7),A.clearcoat&&a.enable(8),A.iridescence&&a.enable(9),A.alphaTest&&a.enable(10),A.vertexColors&&a.enable(11),A.vertexAlphas&&a.enable(12),A.vertexUv1s&&a.enable(13),A.vertexUv2s&&a.enable(14),A.vertexUv3s&&a.enable(15),A.vertexTangents&&a.enable(16),A.anisotropy&&a.enable(17),w.push(a.mask),a.disableAll(),A.fog&&a.enable(0),A.useFog&&a.enable(1),A.flatShading&&a.enable(2),A.logarithmicDepthBuffer&&a.enable(3),A.skinning&&a.enable(4),A.morphTargets&&a.enable(5),A.morphNormals&&a.enable(6),A.morphColors&&a.enable(7),A.premultipliedAlpha&&a.enable(8),A.shadowMapEnabled&&a.enable(9),A.useLegacyLights&&a.enable(10),A.doubleSided&&a.enable(11),A.flipSided&&a.enable(12),A.useDepthPacking&&a.enable(13),A.dithering&&a.enable(14),A.transmission&&a.enable(15),A.sheen&&a.enable(16),A.opaque&&a.enable(17),A.pointsUvs&&a.enable(18),w.push(a.mask)}function S(w){const A=p[w.type];let D;if(A){const k=Kn[A];D=m1.clone(k.uniforms)}else D=w.uniforms;return D}function b(w,A){let D;for(let k=0,G=c.length;k<G;k++){const P=c[k];if(P.cacheKey===A){D=P,++D.usedTimes;break}}return D===void 0&&(D=new LM(r,A,w,s),c.push(D)),D}function M(w){if(--w.usedTimes===0){const A=c.indexOf(w);c[A]=c[c.length-1],c.pop(),w.destroy()}}function E(w){l.remove(w)}function T(){l.dispose()}return{getParameters:g,getProgramCacheKey:m,getUniforms:S,acquireProgram:b,releaseProgram:M,releaseShaderCache:E,programs:c,dispose:T}}function FM(){let r=new WeakMap;function e(s){let o=r.get(s);return o===void 0&&(o={},r.set(s,o)),o}function t(s){r.delete(s)}function n(s,o,a){r.get(s)[o]=a}function i(){r=new WeakMap}return{get:e,remove:t,update:n,dispose:i}}function zM(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function im(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function sm(){const r=[];let e=0;const t=[],n=[],i=[];function s(){e=0,t.length=0,n.length=0,i.length=0}function o(u,d,f,p,_,g){let m=r[e];return m===void 0?(m={id:u.id,object:u,geometry:d,material:f,groupOrder:p,renderOrder:u.renderOrder,z:_,group:g},r[e]=m):(m.id=u.id,m.object=u,m.geometry=d,m.material=f,m.groupOrder=p,m.renderOrder=u.renderOrder,m.z=_,m.group=g),e++,m}function a(u,d,f,p,_,g){const m=o(u,d,f,p,_,g);f.transmission>0?n.push(m):f.transparent===!0?i.push(m):t.push(m)}function l(u,d,f,p,_,g){const m=o(u,d,f,p,_,g);f.transmission>0?n.unshift(m):f.transparent===!0?i.unshift(m):t.unshift(m)}function c(u,d){t.length>1&&t.sort(u||zM),n.length>1&&n.sort(d||im),i.length>1&&i.sort(d||im)}function h(){for(let u=e,d=r.length;u<d;u++){const f=r[u];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:t,transmissive:n,transparent:i,init:s,push:a,unshift:l,finish:h,sort:c}}function VM(){let r=new WeakMap;function e(n,i){const s=r.get(n);let o;return s===void 0?(o=new sm,r.set(n,[o])):i>=s.length?(o=new sm,s.push(o)):o=s[i],o}function t(){r=new WeakMap}return{get:e,dispose:t}}function BM(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new F,color:new He};break;case"SpotLight":t={position:new F,direction:new F,color:new He,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new F,color:new He,distance:0,decay:0};break;case"HemisphereLight":t={direction:new F,skyColor:new He,groundColor:new He};break;case"RectAreaLight":t={color:new He,position:new F,halfWidth:new F,halfHeight:new F};break}return r[e.id]=t,t}}}function kM(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Te};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Te};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Te,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=t,t}}}let GM=0;function HM(r,e){return(e.castShadow?2:0)-(r.castShadow?2:0)+(e.map?1:0)-(r.map?1:0)}function WM(r,e){const t=new BM,n=kM(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let h=0;h<9;h++)i.probe.push(new F);const s=new F,o=new rt,a=new rt;function l(h,u){let d=0,f=0,p=0;for(let D=0;D<9;D++)i.probe[D].set(0,0,0);let _=0,g=0,m=0,v=0,y=0,S=0,b=0,M=0,E=0,T=0;h.sort(HM);const w=u===!0?Math.PI:1;for(let D=0,k=h.length;D<k;D++){const G=h[D],P=G.color,N=G.intensity,B=G.distance,H=G.shadow&&G.shadow.map?G.shadow.map.texture:null;if(G.isAmbientLight)d+=P.r*N*w,f+=P.g*N*w,p+=P.b*N*w;else if(G.isLightProbe)for(let W=0;W<9;W++)i.probe[W].addScaledVector(G.sh.coefficients[W],N);else if(G.isDirectionalLight){const W=t.get(G);if(W.color.copy(G.color).multiplyScalar(G.intensity*w),G.castShadow){const $=G.shadow,oe=n.get(G);oe.shadowBias=$.bias,oe.shadowNormalBias=$.normalBias,oe.shadowRadius=$.radius,oe.shadowMapSize=$.mapSize,i.directionalShadow[_]=oe,i.directionalShadowMap[_]=H,i.directionalShadowMatrix[_]=G.shadow.matrix,S++}i.directional[_]=W,_++}else if(G.isSpotLight){const W=t.get(G);W.position.setFromMatrixPosition(G.matrixWorld),W.color.copy(P).multiplyScalar(N*w),W.distance=B,W.coneCos=Math.cos(G.angle),W.penumbraCos=Math.cos(G.angle*(1-G.penumbra)),W.decay=G.decay,i.spot[m]=W;const $=G.shadow;if(G.map&&(i.spotLightMap[E]=G.map,E++,$.updateMatrices(G),G.castShadow&&T++),i.spotLightMatrix[m]=$.matrix,G.castShadow){const oe=n.get(G);oe.shadowBias=$.bias,oe.shadowNormalBias=$.normalBias,oe.shadowRadius=$.radius,oe.shadowMapSize=$.mapSize,i.spotShadow[m]=oe,i.spotShadowMap[m]=H,M++}m++}else if(G.isRectAreaLight){const W=t.get(G);W.color.copy(P).multiplyScalar(N),W.halfWidth.set(G.width*.5,0,0),W.halfHeight.set(0,G.height*.5,0),i.rectArea[v]=W,v++}else if(G.isPointLight){const W=t.get(G);if(W.color.copy(G.color).multiplyScalar(G.intensity*w),W.distance=G.distance,W.decay=G.decay,G.castShadow){const $=G.shadow,oe=n.get(G);oe.shadowBias=$.bias,oe.shadowNormalBias=$.normalBias,oe.shadowRadius=$.radius,oe.shadowMapSize=$.mapSize,oe.shadowCameraNear=$.camera.near,oe.shadowCameraFar=$.camera.far,i.pointShadow[g]=oe,i.pointShadowMap[g]=H,i.pointShadowMatrix[g]=G.shadow.matrix,b++}i.point[g]=W,g++}else if(G.isHemisphereLight){const W=t.get(G);W.skyColor.copy(G.color).multiplyScalar(N*w),W.groundColor.copy(G.groundColor).multiplyScalar(N*w),i.hemi[y]=W,y++}}v>0&&(e.isWebGL2||r.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=ze.LTC_FLOAT_1,i.rectAreaLTC2=ze.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=ze.LTC_HALF_1,i.rectAreaLTC2=ze.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=f,i.ambient[2]=p;const A=i.hash;(A.directionalLength!==_||A.pointLength!==g||A.spotLength!==m||A.rectAreaLength!==v||A.hemiLength!==y||A.numDirectionalShadows!==S||A.numPointShadows!==b||A.numSpotShadows!==M||A.numSpotMaps!==E)&&(i.directional.length=_,i.spot.length=m,i.rectArea.length=v,i.point.length=g,i.hemi.length=y,i.directionalShadow.length=S,i.directionalShadowMap.length=S,i.pointShadow.length=b,i.pointShadowMap.length=b,i.spotShadow.length=M,i.spotShadowMap.length=M,i.directionalShadowMatrix.length=S,i.pointShadowMatrix.length=b,i.spotLightMatrix.length=M+E-T,i.spotLightMap.length=E,i.numSpotLightShadowsWithMaps=T,A.directionalLength=_,A.pointLength=g,A.spotLength=m,A.rectAreaLength=v,A.hemiLength=y,A.numDirectionalShadows=S,A.numPointShadows=b,A.numSpotShadows=M,A.numSpotMaps=E,i.version=GM++)}function c(h,u){let d=0,f=0,p=0,_=0,g=0;const m=u.matrixWorldInverse;for(let v=0,y=h.length;v<y;v++){const S=h[v];if(S.isDirectionalLight){const b=i.directional[d];b.direction.setFromMatrixPosition(S.matrixWorld),s.setFromMatrixPosition(S.target.matrixWorld),b.direction.sub(s),b.direction.transformDirection(m),d++}else if(S.isSpotLight){const b=i.spot[p];b.position.setFromMatrixPosition(S.matrixWorld),b.position.applyMatrix4(m),b.direction.setFromMatrixPosition(S.matrixWorld),s.setFromMatrixPosition(S.target.matrixWorld),b.direction.sub(s),b.direction.transformDirection(m),p++}else if(S.isRectAreaLight){const b=i.rectArea[_];b.position.setFromMatrixPosition(S.matrixWorld),b.position.applyMatrix4(m),a.identity(),o.copy(S.matrixWorld),o.premultiply(m),a.extractRotation(o),b.halfWidth.set(S.width*.5,0,0),b.halfHeight.set(0,S.height*.5,0),b.halfWidth.applyMatrix4(a),b.halfHeight.applyMatrix4(a),_++}else if(S.isPointLight){const b=i.point[f];b.position.setFromMatrixPosition(S.matrixWorld),b.position.applyMatrix4(m),f++}else if(S.isHemisphereLight){const b=i.hemi[g];b.direction.setFromMatrixPosition(S.matrixWorld),b.direction.transformDirection(m),g++}}}return{setup:l,setupView:c,state:i}}function rm(r,e){const t=new WM(r,e),n=[],i=[];function s(){n.length=0,i.length=0}function o(u){n.push(u)}function a(u){i.push(u)}function l(u){t.setup(n,u)}function c(u){t.setupView(n,u)}return{init:s,state:{lightsArray:n,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function XM(r,e){let t=new WeakMap;function n(s,o=0){const a=t.get(s);let l;return a===void 0?(l=new rm(r,e),t.set(s,[l])):o>=a.length?(l=new rm(r,e),a.push(l)):l=a[o],l}function i(){t=new WeakMap}return{get:n,dispose:i}}class Jd extends tn{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=Q_,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class Qd extends tn{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const jM=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,YM=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function qM(r,e,t){let n=new Uc;const i=new Te,s=new Te,o=new _t,a=new Jd({depthPacking:e1}),l=new Qd,c={},h=t.maxTextureSize,u={[Fi]:cn,[cn]:Fi,[hi]:hi},d=new gi({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Te},radius:{value:4}},vertexShader:jM,fragmentShader:YM}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const p=new ht;p.setAttribute("position",new vt(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const _=new qt(p,d),g=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Nd;let m=this.type;this.render=function(b,M,E){if(g.enabled===!1||g.autoUpdate===!1&&g.needsUpdate===!1||b.length===0)return;const T=r.getRenderTarget(),w=r.getActiveCubeFace(),A=r.getActiveMipmapLevel(),D=r.state;D.setBlending(Di),D.buffers.color.setClear(1,1,1,1),D.buffers.depth.setTest(!0),D.setScissorTest(!1);const k=m!==li&&this.type===li,G=m===li&&this.type!==li;for(let P=0,N=b.length;P<N;P++){const B=b[P],H=B.shadow;if(H===void 0){console.warn("THREE.WebGLShadowMap:",B,"has no shadow.");continue}if(H.autoUpdate===!1&&H.needsUpdate===!1)continue;i.copy(H.mapSize);const W=H.getFrameExtents();if(i.multiply(W),s.copy(H.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(s.x=Math.floor(h/W.x),i.x=s.x*W.x,H.mapSize.x=s.x),i.y>h&&(s.y=Math.floor(h/W.y),i.y=s.y*W.y,H.mapSize.y=s.y)),H.map===null||k===!0||G===!0){const oe=this.type!==li?{minFilter:Pt,magFilter:Pt}:{};H.map!==null&&H.map.dispose(),H.map=new Qn(i.x,i.y,oe),H.map.texture.name=B.name+".shadowMap",H.camera.updateProjectionMatrix()}r.setRenderTarget(H.map),r.clear();const $=H.getViewportCount();for(let oe=0;oe<$;oe++){const Se=H.getViewport(oe);o.set(s.x*Se.x,s.y*Se.y,s.x*Se.z,s.y*Se.w),D.viewport(o),H.updateMatrices(B,oe),n=H.getFrustum(),S(M,E,H.camera,B,this.type)}H.isPointLightShadow!==!0&&this.type===li&&v(H,E),H.needsUpdate=!1}m=this.type,g.needsUpdate=!1,r.setRenderTarget(T,w,A)};function v(b,M){const E=e.update(_);d.defines.VSM_SAMPLES!==b.blurSamples&&(d.defines.VSM_SAMPLES=b.blurSamples,f.defines.VSM_SAMPLES=b.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),b.mapPass===null&&(b.mapPass=new Qn(i.x,i.y)),d.uniforms.shadow_pass.value=b.map.texture,d.uniforms.resolution.value=b.mapSize,d.uniforms.radius.value=b.radius,r.setRenderTarget(b.mapPass),r.clear(),r.renderBufferDirect(M,null,E,d,_,null),f.uniforms.shadow_pass.value=b.mapPass.texture,f.uniforms.resolution.value=b.mapSize,f.uniforms.radius.value=b.radius,r.setRenderTarget(b.map),r.clear(),r.renderBufferDirect(M,null,E,f,_,null)}function y(b,M,E,T){let w=null;const A=E.isPointLight===!0?b.customDistanceMaterial:b.customDepthMaterial;if(A!==void 0)w=A;else if(w=E.isPointLight===!0?l:a,r.localClippingEnabled&&M.clipShadows===!0&&Array.isArray(M.clippingPlanes)&&M.clippingPlanes.length!==0||M.displacementMap&&M.displacementScale!==0||M.alphaMap&&M.alphaTest>0||M.map&&M.alphaTest>0){const D=w.uuid,k=M.uuid;let G=c[D];G===void 0&&(G={},c[D]=G);let P=G[k];P===void 0&&(P=w.clone(),G[k]=P),w=P}if(w.visible=M.visible,w.wireframe=M.wireframe,T===li?w.side=M.shadowSide!==null?M.shadowSide:M.side:w.side=M.shadowSide!==null?M.shadowSide:u[M.side],w.alphaMap=M.alphaMap,w.alphaTest=M.alphaTest,w.map=M.map,w.clipShadows=M.clipShadows,w.clippingPlanes=M.clippingPlanes,w.clipIntersection=M.clipIntersection,w.displacementMap=M.displacementMap,w.displacementScale=M.displacementScale,w.displacementBias=M.displacementBias,w.wireframeLinewidth=M.wireframeLinewidth,w.linewidth=M.linewidth,E.isPointLight===!0&&w.isMeshDistanceMaterial===!0){const D=r.properties.get(w);D.light=E}return w}function S(b,M,E,T,w){if(b.visible===!1)return;if(b.layers.test(M.layers)&&(b.isMesh||b.isLine||b.isPoints)&&(b.castShadow||b.receiveShadow&&w===li)&&(!b.frustumCulled||n.intersectsObject(b))){b.modelViewMatrix.multiplyMatrices(E.matrixWorldInverse,b.matrixWorld);const k=e.update(b),G=b.material;if(Array.isArray(G)){const P=k.groups;for(let N=0,B=P.length;N<B;N++){const H=P[N],W=G[H.materialIndex];if(W&&W.visible){const $=y(b,W,T,w);r.renderBufferDirect(E,null,k,$,b,H)}}}else if(G.visible){const P=y(b,G,T,w);r.renderBufferDirect(E,null,k,P,b,null)}}const D=b.children;for(let k=0,G=D.length;k<G;k++)S(D[k],M,E,T,w)}}function $M(r,e,t){const n=t.isWebGL2;function i(){let V=!1;const Me=new _t;let se=null;const ae=new _t(0,0,0,0);return{setMask:function(ge){se!==ge&&!V&&(r.colorMask(ge,ge,ge,ge),se=ge)},setLocked:function(ge){V=ge},setClear:function(ge,Fe,Y,We,J){J===!0&&(ge*=We,Fe*=We,Y*=We),Me.set(ge,Fe,Y,We),ae.equals(Me)===!1&&(r.clearColor(ge,Fe,Y,We),ae.copy(Me))},reset:function(){V=!1,se=null,ae.set(-1,0,0,0)}}}function s(){let V=!1,Me=null,se=null,ae=null;return{setTest:function(ge){ge?Ee(r.DEPTH_TEST):Ne(r.DEPTH_TEST)},setMask:function(ge){Me!==ge&&!V&&(r.depthMask(ge),Me=ge)},setFunc:function(ge){if(se!==ge){switch(ge){case T_:r.depthFunc(r.NEVER);break;case C_:r.depthFunc(r.ALWAYS);break;case R_:r.depthFunc(r.LESS);break;case gc:r.depthFunc(r.LEQUAL);break;case P_:r.depthFunc(r.EQUAL);break;case I_:r.depthFunc(r.GEQUAL);break;case L_:r.depthFunc(r.GREATER);break;case N_:r.depthFunc(r.NOTEQUAL);break;default:r.depthFunc(r.LEQUAL)}se=ge}},setLocked:function(ge){V=ge},setClear:function(ge){ae!==ge&&(r.clearDepth(ge),ae=ge)},reset:function(){V=!1,Me=null,se=null,ae=null}}}function o(){let V=!1,Me=null,se=null,ae=null,ge=null,Fe=null,Y=null,We=null,J=null;return{setTest:function(Qe){V||(Qe?Ee(r.STENCIL_TEST):Ne(r.STENCIL_TEST))},setMask:function(Qe){Me!==Qe&&!V&&(r.stencilMask(Qe),Me=Qe)},setFunc:function(Qe,ue,it){(se!==Qe||ae!==ue||ge!==it)&&(r.stencilFunc(Qe,ue,it),se=Qe,ae=ue,ge=it)},setOp:function(Qe,ue,it){(Fe!==Qe||Y!==ue||We!==it)&&(r.stencilOp(Qe,ue,it),Fe=Qe,Y=ue,We=it)},setLocked:function(Qe){V=Qe},setClear:function(Qe){J!==Qe&&(r.clearStencil(Qe),J=Qe)},reset:function(){V=!1,Me=null,se=null,ae=null,ge=null,Fe=null,Y=null,We=null,J=null}}}const a=new i,l=new s,c=new o,h=new WeakMap,u=new WeakMap;let d={},f={},p=new WeakMap,_=[],g=null,m=!1,v=null,y=null,S=null,b=null,M=null,E=null,T=null,w=!1,A=null,D=null,k=null,G=null,P=null;const N=r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let B=!1,H=0;const W=r.getParameter(r.VERSION);W.indexOf("WebGL")!==-1?(H=parseFloat(/^WebGL (\d)/.exec(W)[1]),B=H>=1):W.indexOf("OpenGL ES")!==-1&&(H=parseFloat(/^OpenGL ES (\d)/.exec(W)[1]),B=H>=2);let $=null,oe={};const Se=r.getParameter(r.SCISSOR_BOX),K=r.getParameter(r.VIEWPORT),ce=new _t().fromArray(Se),Z=new _t().fromArray(K);function _e(V,Me,se,ae){const ge=new Uint8Array(4),Fe=r.createTexture();r.bindTexture(V,Fe),r.texParameteri(V,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(V,r.TEXTURE_MAG_FILTER,r.NEAREST);for(let Y=0;Y<se;Y++)n&&(V===r.TEXTURE_3D||V===r.TEXTURE_2D_ARRAY)?r.texImage3D(Me,0,r.RGBA,1,1,ae,0,r.RGBA,r.UNSIGNED_BYTE,ge):r.texImage2D(Me+Y,0,r.RGBA,1,1,0,r.RGBA,r.UNSIGNED_BYTE,ge);return Fe}const xe={};xe[r.TEXTURE_2D]=_e(r.TEXTURE_2D,r.TEXTURE_2D,1),xe[r.TEXTURE_CUBE_MAP]=_e(r.TEXTURE_CUBE_MAP,r.TEXTURE_CUBE_MAP_POSITIVE_X,6),n&&(xe[r.TEXTURE_2D_ARRAY]=_e(r.TEXTURE_2D_ARRAY,r.TEXTURE_2D_ARRAY,1,1),xe[r.TEXTURE_3D]=_e(r.TEXTURE_3D,r.TEXTURE_3D,1,1)),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),Ee(r.DEPTH_TEST),l.setFunc(gc),ne(!1),Ae(Fu),Ee(r.CULL_FACE),X(Di);function Ee(V){d[V]!==!0&&(r.enable(V),d[V]=!0)}function Ne(V){d[V]!==!1&&(r.disable(V),d[V]=!1)}function Oe(V,Me){return f[V]!==Me?(r.bindFramebuffer(V,Me),f[V]=Me,n&&(V===r.DRAW_FRAMEBUFFER&&(f[r.FRAMEBUFFER]=Me),V===r.FRAMEBUFFER&&(f[r.DRAW_FRAMEBUFFER]=Me)),!0):!1}function Ve(V,Me){let se=_,ae=!1;if(V)if(se=p.get(Me),se===void 0&&(se=[],p.set(Me,se)),V.isWebGLMultipleRenderTargets){const ge=V.texture;if(se.length!==ge.length||se[0]!==r.COLOR_ATTACHMENT0){for(let Fe=0,Y=ge.length;Fe<Y;Fe++)se[Fe]=r.COLOR_ATTACHMENT0+Fe;se.length=ge.length,ae=!0}}else se[0]!==r.COLOR_ATTACHMENT0&&(se[0]=r.COLOR_ATTACHMENT0,ae=!0);else se[0]!==r.BACK&&(se[0]=r.BACK,ae=!0);ae&&(t.isWebGL2?r.drawBuffers(se):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(se))}function De(V){return g!==V?(r.useProgram(V),g=V,!0):!1}const z={[Vs]:r.FUNC_ADD,[g_]:r.FUNC_SUBTRACT,[__]:r.FUNC_REVERSE_SUBTRACT};if(n)z[ku]=r.MIN,z[Gu]=r.MAX;else{const V=e.get("EXT_blend_minmax");V!==null&&(z[ku]=V.MIN_EXT,z[Gu]=V.MAX_EXT)}const ye={[y_]:r.ZERO,[x_]:r.ONE,[v_]:r.SRC_COLOR,[Od]:r.SRC_ALPHA,[E_]:r.SRC_ALPHA_SATURATE,[M_]:r.DST_COLOR,[b_]:r.DST_ALPHA,[S_]:r.ONE_MINUS_SRC_COLOR,[Dd]:r.ONE_MINUS_SRC_ALPHA,[A_]:r.ONE_MINUS_DST_COLOR,[w_]:r.ONE_MINUS_DST_ALPHA};function X(V,Me,se,ae,ge,Fe,Y,We){if(V===Di){m===!0&&(Ne(r.BLEND),m=!1);return}if(m===!1&&(Ee(r.BLEND),m=!0),V!==m_){if(V!==v||We!==w){if((y!==Vs||M!==Vs)&&(r.blendEquation(r.FUNC_ADD),y=Vs,M=Vs),We)switch(V){case js:r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case zu:r.blendFunc(r.ONE,r.ONE);break;case Vu:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case Bu:r.blendFuncSeparate(r.ZERO,r.SRC_COLOR,r.ZERO,r.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",V);break}else switch(V){case js:r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA);break;case zu:r.blendFunc(r.SRC_ALPHA,r.ONE);break;case Vu:r.blendFuncSeparate(r.ZERO,r.ONE_MINUS_SRC_COLOR,r.ZERO,r.ONE);break;case Bu:r.blendFunc(r.ZERO,r.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",V);break}S=null,b=null,E=null,T=null,v=V,w=We}return}ge=ge||Me,Fe=Fe||se,Y=Y||ae,(Me!==y||ge!==M)&&(r.blendEquationSeparate(z[Me],z[ge]),y=Me,M=ge),(se!==S||ae!==b||Fe!==E||Y!==T)&&(r.blendFuncSeparate(ye[se],ye[ae],ye[Fe],ye[Y]),S=se,b=ae,E=Fe,T=Y),v=V,w=!1}function ie(V,Me){V.side===hi?Ne(r.CULL_FACE):Ee(r.CULL_FACE);let se=V.side===cn;Me&&(se=!se),ne(se),V.blending===js&&V.transparent===!1?X(Di):X(V.blending,V.blendEquation,V.blendSrc,V.blendDst,V.blendEquationAlpha,V.blendSrcAlpha,V.blendDstAlpha,V.premultipliedAlpha),l.setFunc(V.depthFunc),l.setTest(V.depthTest),l.setMask(V.depthWrite),a.setMask(V.colorWrite);const ae=V.stencilWrite;c.setTest(ae),ae&&(c.setMask(V.stencilWriteMask),c.setFunc(V.stencilFunc,V.stencilRef,V.stencilFuncMask),c.setOp(V.stencilFail,V.stencilZFail,V.stencilZPass)),Ie(V.polygonOffset,V.polygonOffsetFactor,V.polygonOffsetUnits),V.alphaToCoverage===!0?Ee(r.SAMPLE_ALPHA_TO_COVERAGE):Ne(r.SAMPLE_ALPHA_TO_COVERAGE)}function ne(V){A!==V&&(V?r.frontFace(r.CW):r.frontFace(r.CCW),A=V)}function Ae(V){V!==d_?(Ee(r.CULL_FACE),V!==D&&(V===Fu?r.cullFace(r.BACK):V===f_?r.cullFace(r.FRONT):r.cullFace(r.FRONT_AND_BACK))):Ne(r.CULL_FACE),D=V}function Pe(V){V!==k&&(B&&r.lineWidth(V),k=V)}function Ie(V,Me,se){V?(Ee(r.POLYGON_OFFSET_FILL),(G!==Me||P!==se)&&(r.polygonOffset(Me,se),G=Me,P=se)):Ne(r.POLYGON_OFFSET_FILL)}function Ge(V){V?Ee(r.SCISSOR_TEST):Ne(r.SCISSOR_TEST)}function Ye(V){V===void 0&&(V=r.TEXTURE0+N-1),$!==V&&(r.activeTexture(V),$=V)}function et(V,Me,se){se===void 0&&($===null?se=r.TEXTURE0+N-1:se=$);let ae=oe[se];ae===void 0&&(ae={type:void 0,texture:void 0},oe[se]=ae),(ae.type!==V||ae.texture!==Me)&&($!==se&&(r.activeTexture(se),$=se),r.bindTexture(V,Me||xe[V]),ae.type=V,ae.texture=Me)}function U(){const V=oe[$];V!==void 0&&V.type!==void 0&&(r.bindTexture(V.type,null),V.type=void 0,V.texture=void 0)}function I(){try{r.compressedTexImage2D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function fe(){try{r.compressedTexImage3D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function Ce(){try{r.texSubImage2D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function Re(){try{r.texSubImage3D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function Ue(){try{r.compressedTexSubImage2D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function ke(){try{r.compressedTexSubImage3D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function C(){try{r.texStorage2D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function R(){try{r.texStorage3D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function O(){try{r.texImage2D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function j(){try{r.texImage3D.apply(r,arguments)}catch(V){console.error("THREE.WebGLState:",V)}}function q(V){ce.equals(V)===!1&&(r.scissor(V.x,V.y,V.z,V.w),ce.copy(V))}function he(V){Z.equals(V)===!1&&(r.viewport(V.x,V.y,V.z,V.w),Z.copy(V))}function ee(V,Me){let se=u.get(Me);se===void 0&&(se=new WeakMap,u.set(Me,se));let ae=se.get(V);ae===void 0&&(ae=r.getUniformBlockIndex(Me,V.name),se.set(V,ae))}function we(V,Me){const ae=u.get(Me).get(V);h.get(Me)!==ae&&(r.uniformBlockBinding(Me,ae,V.__bindingPointIndex),h.set(Me,ae))}function Le(){r.disable(r.BLEND),r.disable(r.CULL_FACE),r.disable(r.DEPTH_TEST),r.disable(r.POLYGON_OFFSET_FILL),r.disable(r.SCISSOR_TEST),r.disable(r.STENCIL_TEST),r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),r.blendEquation(r.FUNC_ADD),r.blendFunc(r.ONE,r.ZERO),r.blendFuncSeparate(r.ONE,r.ZERO,r.ONE,r.ZERO),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(r.LESS),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(r.ALWAYS,0,4294967295),r.stencilOp(r.KEEP,r.KEEP,r.KEEP),r.clearStencil(0),r.cullFace(r.BACK),r.frontFace(r.CCW),r.polygonOffset(0,0),r.activeTexture(r.TEXTURE0),r.bindFramebuffer(r.FRAMEBUFFER,null),n===!0&&(r.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),r.bindFramebuffer(r.READ_FRAMEBUFFER,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),d={},$=null,oe={},f={},p=new WeakMap,_=[],g=null,m=!1,v=null,y=null,S=null,b=null,M=null,E=null,T=null,w=!1,A=null,D=null,k=null,G=null,P=null,ce.set(0,0,r.canvas.width,r.canvas.height),Z.set(0,0,r.canvas.width,r.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:Ee,disable:Ne,bindFramebuffer:Oe,drawBuffers:Ve,useProgram:De,setBlending:X,setMaterial:ie,setFlipSided:ne,setCullFace:Ae,setLineWidth:Pe,setPolygonOffset:Ie,setScissorTest:Ge,activeTexture:Ye,bindTexture:et,unbindTexture:U,compressedTexImage2D:I,compressedTexImage3D:fe,texImage2D:O,texImage3D:j,updateUBOMapping:ee,uniformBlockBinding:we,texStorage2D:C,texStorage3D:R,texSubImage2D:Ce,texSubImage3D:Re,compressedTexSubImage2D:Ue,compressedTexSubImage3D:ke,scissor:q,viewport:he,reset:Le}}function ZM(r,e,t,n,i,s,o){const a=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,h=i.maxTextureSize,u=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,f=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),p=new WeakMap;let _;const g=new WeakMap;let m=!1;try{m=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(U,I){return m?new OffscreenCanvas(U,I):oa("canvas")}function y(U,I,fe,Ce){let Re=1;if((U.width>Ce||U.height>Ce)&&(Re=Ce/Math.max(U.width,U.height)),Re<1||I===!0)if(typeof HTMLImageElement<"u"&&U instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&U instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&U instanceof ImageBitmap){const Ue=I?xc:Math.floor,ke=Ue(Re*U.width),C=Ue(Re*U.height);_===void 0&&(_=v(ke,C));const R=fe?v(ke,C):_;return R.width=ke,R.height=C,R.getContext("2d").drawImage(U,0,0,ke,C),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+U.width+"x"+U.height+") to ("+ke+"x"+C+")."),R}else return"data"in U&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+U.width+"x"+U.height+")."),U;return U}function S(U){return fd(U.width)&&fd(U.height)}function b(U){return a?!1:U.wrapS!==en||U.wrapT!==en||U.minFilter!==Pt&&U.minFilter!==It}function M(U,I){return U.generateMipmaps&&I&&U.minFilter!==Pt&&U.minFilter!==It}function E(U){r.generateMipmap(U)}function T(U,I,fe,Ce,Re=!1){if(a===!1)return I;if(U!==null){if(r[U]!==void 0)return r[U];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+U+"'")}let Ue=I;return I===r.RED&&(fe===r.FLOAT&&(Ue=r.R32F),fe===r.HALF_FLOAT&&(Ue=r.R16F),fe===r.UNSIGNED_BYTE&&(Ue=r.R8)),I===r.RG&&(fe===r.FLOAT&&(Ue=r.RG32F),fe===r.HALF_FLOAT&&(Ue=r.RG16F),fe===r.UNSIGNED_BYTE&&(Ue=r.RG8)),I===r.RGBA&&(fe===r.FLOAT&&(Ue=r.RGBA32F),fe===r.HALF_FLOAT&&(Ue=r.RGBA16F),fe===r.UNSIGNED_BYTE&&(Ue=Ce===ot&&Re===!1?r.SRGB8_ALPHA8:r.RGBA8),fe===r.UNSIGNED_SHORT_4_4_4_4&&(Ue=r.RGBA4),fe===r.UNSIGNED_SHORT_5_5_5_1&&(Ue=r.RGB5_A1)),(Ue===r.R16F||Ue===r.R32F||Ue===r.RG16F||Ue===r.RG32F||Ue===r.RGBA16F||Ue===r.RGBA32F)&&e.get("EXT_color_buffer_float"),Ue}function w(U,I,fe){return M(U,fe)===!0||U.isFramebufferTexture&&U.minFilter!==Pt&&U.minFilter!==It?Math.log2(Math.max(I.width,I.height))+1:U.mipmaps!==void 0&&U.mipmaps.length>0?U.mipmaps.length:U.isCompressedTexture&&Array.isArray(U.image)?I.mipmaps.length:1}function A(U){return U===Pt||U===_c||U===Xo?r.NEAREST:r.LINEAR}function D(U){const I=U.target;I.removeEventListener("dispose",D),G(I),I.isVideoTexture&&p.delete(I)}function k(U){const I=U.target;I.removeEventListener("dispose",k),N(I)}function G(U){const I=n.get(U);if(I.__webglInit===void 0)return;const fe=U.source,Ce=g.get(fe);if(Ce){const Re=Ce[I.__cacheKey];Re.usedTimes--,Re.usedTimes===0&&P(U),Object.keys(Ce).length===0&&g.delete(fe)}n.remove(U)}function P(U){const I=n.get(U);r.deleteTexture(I.__webglTexture);const fe=U.source,Ce=g.get(fe);delete Ce[I.__cacheKey],o.memory.textures--}function N(U){const I=U.texture,fe=n.get(U),Ce=n.get(I);if(Ce.__webglTexture!==void 0&&(r.deleteTexture(Ce.__webglTexture),o.memory.textures--),U.depthTexture&&U.depthTexture.dispose(),U.isWebGLCubeRenderTarget)for(let Re=0;Re<6;Re++)r.deleteFramebuffer(fe.__webglFramebuffer[Re]),fe.__webglDepthbuffer&&r.deleteRenderbuffer(fe.__webglDepthbuffer[Re]);else{if(r.deleteFramebuffer(fe.__webglFramebuffer),fe.__webglDepthbuffer&&r.deleteRenderbuffer(fe.__webglDepthbuffer),fe.__webglMultisampledFramebuffer&&r.deleteFramebuffer(fe.__webglMultisampledFramebuffer),fe.__webglColorRenderbuffer)for(let Re=0;Re<fe.__webglColorRenderbuffer.length;Re++)fe.__webglColorRenderbuffer[Re]&&r.deleteRenderbuffer(fe.__webglColorRenderbuffer[Re]);fe.__webglDepthRenderbuffer&&r.deleteRenderbuffer(fe.__webglDepthRenderbuffer)}if(U.isWebGLMultipleRenderTargets)for(let Re=0,Ue=I.length;Re<Ue;Re++){const ke=n.get(I[Re]);ke.__webglTexture&&(r.deleteTexture(ke.__webglTexture),o.memory.textures--),n.remove(I[Re])}n.remove(I),n.remove(U)}let B=0;function H(){B=0}function W(){const U=B;return U>=l&&console.warn("THREE.WebGLTextures: Trying to use "+U+" texture units while this GPU supports only "+l),B+=1,U}function $(U){const I=[];return I.push(U.wrapS),I.push(U.wrapT),I.push(U.wrapR||0),I.push(U.magFilter),I.push(U.minFilter),I.push(U.anisotropy),I.push(U.internalFormat),I.push(U.format),I.push(U.type),I.push(U.generateMipmaps),I.push(U.premultiplyAlpha),I.push(U.flipY),I.push(U.unpackAlignment),I.push(U.colorSpace),I.join()}function oe(U,I){const fe=n.get(U);if(U.isVideoTexture&&Ye(U),U.isRenderTargetTexture===!1&&U.version>0&&fe.__version!==U.version){const Ce=U.image;if(Ce===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Ce.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Oe(fe,U,I);return}}t.bindTexture(r.TEXTURE_2D,fe.__webglTexture,r.TEXTURE0+I)}function Se(U,I){const fe=n.get(U);if(U.version>0&&fe.__version!==U.version){Oe(fe,U,I);return}t.bindTexture(r.TEXTURE_2D_ARRAY,fe.__webglTexture,r.TEXTURE0+I)}function K(U,I){const fe=n.get(U);if(U.version>0&&fe.__version!==U.version){Oe(fe,U,I);return}t.bindTexture(r.TEXTURE_3D,fe.__webglTexture,r.TEXTURE0+I)}function ce(U,I){const fe=n.get(U);if(U.version>0&&fe.__version!==U.version){Ve(fe,U,I);return}t.bindTexture(r.TEXTURE_CUBE_MAP,fe.__webglTexture,r.TEXTURE0+I)}const Z={[Qo]:r.REPEAT,[en]:r.CLAMP_TO_EDGE,[ea]:r.MIRRORED_REPEAT},_e={[Pt]:r.NEAREST,[_c]:r.NEAREST_MIPMAP_NEAREST,[Xo]:r.NEAREST_MIPMAP_LINEAR,[It]:r.LINEAR,[Ud]:r.LINEAR_MIPMAP_NEAREST,[ps]:r.LINEAR_MIPMAP_LINEAR},xe={[i1]:r.NEVER,[h1]:r.ALWAYS,[s1]:r.LESS,[o1]:r.LEQUAL,[r1]:r.EQUAL,[c1]:r.GEQUAL,[a1]:r.GREATER,[l1]:r.NOTEQUAL};function Ee(U,I,fe){if(fe?(r.texParameteri(U,r.TEXTURE_WRAP_S,Z[I.wrapS]),r.texParameteri(U,r.TEXTURE_WRAP_T,Z[I.wrapT]),(U===r.TEXTURE_3D||U===r.TEXTURE_2D_ARRAY)&&r.texParameteri(U,r.TEXTURE_WRAP_R,Z[I.wrapR]),r.texParameteri(U,r.TEXTURE_MAG_FILTER,_e[I.magFilter]),r.texParameteri(U,r.TEXTURE_MIN_FILTER,_e[I.minFilter])):(r.texParameteri(U,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(U,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),(U===r.TEXTURE_3D||U===r.TEXTURE_2D_ARRAY)&&r.texParameteri(U,r.TEXTURE_WRAP_R,r.CLAMP_TO_EDGE),(I.wrapS!==en||I.wrapT!==en)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(U,r.TEXTURE_MAG_FILTER,A(I.magFilter)),r.texParameteri(U,r.TEXTURE_MIN_FILTER,A(I.minFilter)),I.minFilter!==Pt&&I.minFilter!==It&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),I.compareFunction&&(r.texParameteri(U,r.TEXTURE_COMPARE_MODE,r.COMPARE_REF_TO_TEXTURE),r.texParameteri(U,r.TEXTURE_COMPARE_FUNC,xe[I.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const Ce=e.get("EXT_texture_filter_anisotropic");if(I.magFilter===Pt||I.minFilter!==Xo&&I.minFilter!==ps||I.type===ui&&e.has("OES_texture_float_linear")===!1||a===!1&&I.type===so&&e.has("OES_texture_half_float_linear")===!1)return;(I.anisotropy>1||n.get(I).__currentAnisotropy)&&(r.texParameterf(U,Ce.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(I.anisotropy,i.getMaxAnisotropy())),n.get(I).__currentAnisotropy=I.anisotropy)}}function Ne(U,I){let fe=!1;U.__webglInit===void 0&&(U.__webglInit=!0,I.addEventListener("dispose",D));const Ce=I.source;let Re=g.get(Ce);Re===void 0&&(Re={},g.set(Ce,Re));const Ue=$(I);if(Ue!==U.__cacheKey){Re[Ue]===void 0&&(Re[Ue]={texture:r.createTexture(),usedTimes:0},o.memory.textures++,fe=!0),Re[Ue].usedTimes++;const ke=Re[U.__cacheKey];ke!==void 0&&(Re[U.__cacheKey].usedTimes--,ke.usedTimes===0&&P(I)),U.__cacheKey=Ue,U.__webglTexture=Re[Ue].texture}return fe}function Oe(U,I,fe){let Ce=r.TEXTURE_2D;(I.isDataArrayTexture||I.isCompressedArrayTexture)&&(Ce=r.TEXTURE_2D_ARRAY),I.isData3DTexture&&(Ce=r.TEXTURE_3D);const Re=Ne(U,I),Ue=I.source;t.bindTexture(Ce,U.__webglTexture,r.TEXTURE0+fe);const ke=n.get(Ue);if(Ue.version!==ke.__version||Re===!0){t.activeTexture(r.TEXTURE0+fe),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,I.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,I.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,r.NONE);const C=b(I)&&S(I.image)===!1;let R=y(I.image,C,!1,h);R=et(I,R);const O=S(R)||a,j=s.convert(I.format,I.colorSpace);let q=s.convert(I.type),he=T(I.internalFormat,j,q,I.colorSpace);Ee(Ce,I,O);let ee;const we=I.mipmaps,Le=a&&I.isVideoTexture!==!0,V=ke.__version===void 0||Re===!0,Me=w(I,R,O);if(I.isDepthTexture)he=r.DEPTH_COMPONENT,a?I.type===ui?he=r.DEPTH_COMPONENT32F:I.type===Oi?he=r.DEPTH_COMPONENT24:I.type===as?he=r.DEPTH24_STENCIL8:he=r.DEPTH_COMPONENT16:I.type===ui&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),I.format===ls&&he===r.DEPTH_COMPONENT&&I.type!==Ic&&I.type!==Oi&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),I.type=Oi,q=s.convert(I.type)),I.format===$s&&he===r.DEPTH_COMPONENT&&(he=r.DEPTH_STENCIL,I.type!==as&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),I.type=as,q=s.convert(I.type))),V&&(Le?t.texStorage2D(r.TEXTURE_2D,1,he,R.width,R.height):t.texImage2D(r.TEXTURE_2D,0,he,R.width,R.height,0,j,q,null));else if(I.isDataTexture)if(we.length>0&&O){Le&&V&&t.texStorage2D(r.TEXTURE_2D,Me,he,we[0].width,we[0].height);for(let se=0,ae=we.length;se<ae;se++)ee=we[se],Le?t.texSubImage2D(r.TEXTURE_2D,se,0,0,ee.width,ee.height,j,q,ee.data):t.texImage2D(r.TEXTURE_2D,se,he,ee.width,ee.height,0,j,q,ee.data);I.generateMipmaps=!1}else Le?(V&&t.texStorage2D(r.TEXTURE_2D,Me,he,R.width,R.height),t.texSubImage2D(r.TEXTURE_2D,0,0,0,R.width,R.height,j,q,R.data)):t.texImage2D(r.TEXTURE_2D,0,he,R.width,R.height,0,j,q,R.data);else if(I.isCompressedTexture)if(I.isCompressedArrayTexture){Le&&V&&t.texStorage3D(r.TEXTURE_2D_ARRAY,Me,he,we[0].width,we[0].height,R.depth);for(let se=0,ae=we.length;se<ae;se++)ee=we[se],I.format!==Rn?j!==null?Le?t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY,se,0,0,0,ee.width,ee.height,R.depth,j,ee.data,0,0):t.compressedTexImage3D(r.TEXTURE_2D_ARRAY,se,he,ee.width,ee.height,R.depth,0,ee.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Le?t.texSubImage3D(r.TEXTURE_2D_ARRAY,se,0,0,0,ee.width,ee.height,R.depth,j,q,ee.data):t.texImage3D(r.TEXTURE_2D_ARRAY,se,he,ee.width,ee.height,R.depth,0,j,q,ee.data)}else{Le&&V&&t.texStorage2D(r.TEXTURE_2D,Me,he,we[0].width,we[0].height);for(let se=0,ae=we.length;se<ae;se++)ee=we[se],I.format!==Rn?j!==null?Le?t.compressedTexSubImage2D(r.TEXTURE_2D,se,0,0,ee.width,ee.height,j,ee.data):t.compressedTexImage2D(r.TEXTURE_2D,se,he,ee.width,ee.height,0,ee.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Le?t.texSubImage2D(r.TEXTURE_2D,se,0,0,ee.width,ee.height,j,q,ee.data):t.texImage2D(r.TEXTURE_2D,se,he,ee.width,ee.height,0,j,q,ee.data)}else if(I.isDataArrayTexture)Le?(V&&t.texStorage3D(r.TEXTURE_2D_ARRAY,Me,he,R.width,R.height,R.depth),t.texSubImage3D(r.TEXTURE_2D_ARRAY,0,0,0,0,R.width,R.height,R.depth,j,q,R.data)):t.texImage3D(r.TEXTURE_2D_ARRAY,0,he,R.width,R.height,R.depth,0,j,q,R.data);else if(I.isData3DTexture)Le?(V&&t.texStorage3D(r.TEXTURE_3D,Me,he,R.width,R.height,R.depth),t.texSubImage3D(r.TEXTURE_3D,0,0,0,0,R.width,R.height,R.depth,j,q,R.data)):t.texImage3D(r.TEXTURE_3D,0,he,R.width,R.height,R.depth,0,j,q,R.data);else if(I.isFramebufferTexture){if(V)if(Le)t.texStorage2D(r.TEXTURE_2D,Me,he,R.width,R.height);else{let se=R.width,ae=R.height;for(let ge=0;ge<Me;ge++)t.texImage2D(r.TEXTURE_2D,ge,he,se,ae,0,j,q,null),se>>=1,ae>>=1}}else if(we.length>0&&O){Le&&V&&t.texStorage2D(r.TEXTURE_2D,Me,he,we[0].width,we[0].height);for(let se=0,ae=we.length;se<ae;se++)ee=we[se],Le?t.texSubImage2D(r.TEXTURE_2D,se,0,0,j,q,ee):t.texImage2D(r.TEXTURE_2D,se,he,j,q,ee);I.generateMipmaps=!1}else Le?(V&&t.texStorage2D(r.TEXTURE_2D,Me,he,R.width,R.height),t.texSubImage2D(r.TEXTURE_2D,0,0,0,j,q,R)):t.texImage2D(r.TEXTURE_2D,0,he,j,q,R);M(I,O)&&E(Ce),ke.__version=Ue.version,I.onUpdate&&I.onUpdate(I)}U.__version=I.version}function Ve(U,I,fe){if(I.image.length!==6)return;const Ce=Ne(U,I),Re=I.source;t.bindTexture(r.TEXTURE_CUBE_MAP,U.__webglTexture,r.TEXTURE0+fe);const Ue=n.get(Re);if(Re.version!==Ue.__version||Ce===!0){t.activeTexture(r.TEXTURE0+fe),r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,I.flipY),r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),r.pixelStorei(r.UNPACK_ALIGNMENT,I.unpackAlignment),r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL,r.NONE);const ke=I.isCompressedTexture||I.image[0].isCompressedTexture,C=I.image[0]&&I.image[0].isDataTexture,R=[];for(let se=0;se<6;se++)!ke&&!C?R[se]=y(I.image[se],!1,!0,c):R[se]=C?I.image[se].image:I.image[se],R[se]=et(I,R[se]);const O=R[0],j=S(O)||a,q=s.convert(I.format,I.colorSpace),he=s.convert(I.type),ee=T(I.internalFormat,q,he,I.colorSpace),we=a&&I.isVideoTexture!==!0,Le=Ue.__version===void 0||Ce===!0;let V=w(I,O,j);Ee(r.TEXTURE_CUBE_MAP,I,j);let Me;if(ke){we&&Le&&t.texStorage2D(r.TEXTURE_CUBE_MAP,V,ee,O.width,O.height);for(let se=0;se<6;se++){Me=R[se].mipmaps;for(let ae=0;ae<Me.length;ae++){const ge=Me[ae];I.format!==Rn?q!==null?we?t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae,0,0,ge.width,ge.height,q,ge.data):t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae,ee,ge.width,ge.height,0,ge.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):we?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae,0,0,ge.width,ge.height,q,he,ge.data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae,ee,ge.width,ge.height,0,q,he,ge.data)}}}else{Me=I.mipmaps,we&&Le&&(Me.length>0&&V++,t.texStorage2D(r.TEXTURE_CUBE_MAP,V,ee,R[0].width,R[0].height));for(let se=0;se<6;se++)if(C){we?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,0,0,0,R[se].width,R[se].height,q,he,R[se].data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,0,ee,R[se].width,R[se].height,0,q,he,R[se].data);for(let ae=0;ae<Me.length;ae++){const Fe=Me[ae].image[se].image;we?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae+1,0,0,Fe.width,Fe.height,q,he,Fe.data):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae+1,ee,Fe.width,Fe.height,0,q,he,Fe.data)}}else{we?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,0,0,0,q,he,R[se]):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,0,ee,q,he,R[se]);for(let ae=0;ae<Me.length;ae++){const ge=Me[ae];we?t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae+1,0,0,q,he,ge.image[se]):t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+se,ae+1,ee,q,he,ge.image[se])}}}M(I,j)&&E(r.TEXTURE_CUBE_MAP),Ue.__version=Re.version,I.onUpdate&&I.onUpdate(I)}U.__version=I.version}function De(U,I,fe,Ce,Re){const Ue=s.convert(fe.format,fe.colorSpace),ke=s.convert(fe.type),C=T(fe.internalFormat,Ue,ke,fe.colorSpace);n.get(I).__hasExternalTextures||(Re===r.TEXTURE_3D||Re===r.TEXTURE_2D_ARRAY?t.texImage3D(Re,0,C,I.width,I.height,I.depth,0,Ue,ke,null):t.texImage2D(Re,0,C,I.width,I.height,0,Ue,ke,null)),t.bindFramebuffer(r.FRAMEBUFFER,U),Ge(I)?d.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,Ce,Re,n.get(fe).__webglTexture,0,Ie(I)):(Re===r.TEXTURE_2D||Re>=r.TEXTURE_CUBE_MAP_POSITIVE_X&&Re<=r.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&r.framebufferTexture2D(r.FRAMEBUFFER,Ce,Re,n.get(fe).__webglTexture,0),t.bindFramebuffer(r.FRAMEBUFFER,null)}function z(U,I,fe){if(r.bindRenderbuffer(r.RENDERBUFFER,U),I.depthBuffer&&!I.stencilBuffer){let Ce=r.DEPTH_COMPONENT16;if(fe||Ge(I)){const Re=I.depthTexture;Re&&Re.isDepthTexture&&(Re.type===ui?Ce=r.DEPTH_COMPONENT32F:Re.type===Oi&&(Ce=r.DEPTH_COMPONENT24));const Ue=Ie(I);Ge(I)?d.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,Ue,Ce,I.width,I.height):r.renderbufferStorageMultisample(r.RENDERBUFFER,Ue,Ce,I.width,I.height)}else r.renderbufferStorage(r.RENDERBUFFER,Ce,I.width,I.height);r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,U)}else if(I.depthBuffer&&I.stencilBuffer){const Ce=Ie(I);fe&&Ge(I)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,Ce,r.DEPTH24_STENCIL8,I.width,I.height):Ge(I)?d.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,Ce,r.DEPTH24_STENCIL8,I.width,I.height):r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_STENCIL,I.width,I.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.RENDERBUFFER,U)}else{const Ce=I.isWebGLMultipleRenderTargets===!0?I.texture:[I.texture];for(let Re=0;Re<Ce.length;Re++){const Ue=Ce[Re],ke=s.convert(Ue.format,Ue.colorSpace),C=s.convert(Ue.type),R=T(Ue.internalFormat,ke,C,Ue.colorSpace),O=Ie(I);fe&&Ge(I)===!1?r.renderbufferStorageMultisample(r.RENDERBUFFER,O,R,I.width,I.height):Ge(I)?d.renderbufferStorageMultisampleEXT(r.RENDERBUFFER,O,R,I.width,I.height):r.renderbufferStorage(r.RENDERBUFFER,R,I.width,I.height)}}r.bindRenderbuffer(r.RENDERBUFFER,null)}function ye(U,I){if(I&&I.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(r.FRAMEBUFFER,U),!(I.depthTexture&&I.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(I.depthTexture).__webglTexture||I.depthTexture.image.width!==I.width||I.depthTexture.image.height!==I.height)&&(I.depthTexture.image.width=I.width,I.depthTexture.image.height=I.height,I.depthTexture.needsUpdate=!0),oe(I.depthTexture,0);const Ce=n.get(I.depthTexture).__webglTexture,Re=Ie(I);if(I.depthTexture.format===ls)Ge(I)?d.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,Ce,0,Re):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.TEXTURE_2D,Ce,0);else if(I.depthTexture.format===$s)Ge(I)?d.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,Ce,0,Re):r.framebufferTexture2D(r.FRAMEBUFFER,r.DEPTH_STENCIL_ATTACHMENT,r.TEXTURE_2D,Ce,0);else throw new Error("Unknown depthTexture format")}function X(U){const I=n.get(U),fe=U.isWebGLCubeRenderTarget===!0;if(U.depthTexture&&!I.__autoAllocateDepthBuffer){if(fe)throw new Error("target.depthTexture not supported in Cube render targets");ye(I.__webglFramebuffer,U)}else if(fe){I.__webglDepthbuffer=[];for(let Ce=0;Ce<6;Ce++)t.bindFramebuffer(r.FRAMEBUFFER,I.__webglFramebuffer[Ce]),I.__webglDepthbuffer[Ce]=r.createRenderbuffer(),z(I.__webglDepthbuffer[Ce],U,!1)}else t.bindFramebuffer(r.FRAMEBUFFER,I.__webglFramebuffer),I.__webglDepthbuffer=r.createRenderbuffer(),z(I.__webglDepthbuffer,U,!1);t.bindFramebuffer(r.FRAMEBUFFER,null)}function ie(U,I,fe){const Ce=n.get(U);I!==void 0&&De(Ce.__webglFramebuffer,U,U.texture,r.COLOR_ATTACHMENT0,r.TEXTURE_2D),fe!==void 0&&X(U)}function ne(U){const I=U.texture,fe=n.get(U),Ce=n.get(I);U.addEventListener("dispose",k),U.isWebGLMultipleRenderTargets!==!0&&(Ce.__webglTexture===void 0&&(Ce.__webglTexture=r.createTexture()),Ce.__version=I.version,o.memory.textures++);const Re=U.isWebGLCubeRenderTarget===!0,Ue=U.isWebGLMultipleRenderTargets===!0,ke=S(U)||a;if(Re){fe.__webglFramebuffer=[];for(let C=0;C<6;C++)fe.__webglFramebuffer[C]=r.createFramebuffer()}else{if(fe.__webglFramebuffer=r.createFramebuffer(),Ue)if(i.drawBuffers){const C=U.texture;for(let R=0,O=C.length;R<O;R++){const j=n.get(C[R]);j.__webglTexture===void 0&&(j.__webglTexture=r.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(a&&U.samples>0&&Ge(U)===!1){const C=Ue?I:[I];fe.__webglMultisampledFramebuffer=r.createFramebuffer(),fe.__webglColorRenderbuffer=[],t.bindFramebuffer(r.FRAMEBUFFER,fe.__webglMultisampledFramebuffer);for(let R=0;R<C.length;R++){const O=C[R];fe.__webglColorRenderbuffer[R]=r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,fe.__webglColorRenderbuffer[R]);const j=s.convert(O.format,O.colorSpace),q=s.convert(O.type),he=T(O.internalFormat,j,q,O.colorSpace,U.isXRRenderTarget===!0),ee=Ie(U);r.renderbufferStorageMultisample(r.RENDERBUFFER,ee,he,U.width,U.height),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+R,r.RENDERBUFFER,fe.__webglColorRenderbuffer[R])}r.bindRenderbuffer(r.RENDERBUFFER,null),U.depthBuffer&&(fe.__webglDepthRenderbuffer=r.createRenderbuffer(),z(fe.__webglDepthRenderbuffer,U,!0)),t.bindFramebuffer(r.FRAMEBUFFER,null)}}if(Re){t.bindTexture(r.TEXTURE_CUBE_MAP,Ce.__webglTexture),Ee(r.TEXTURE_CUBE_MAP,I,ke);for(let C=0;C<6;C++)De(fe.__webglFramebuffer[C],U,I,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+C);M(I,ke)&&E(r.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Ue){const C=U.texture;for(let R=0,O=C.length;R<O;R++){const j=C[R],q=n.get(j);t.bindTexture(r.TEXTURE_2D,q.__webglTexture),Ee(r.TEXTURE_2D,j,ke),De(fe.__webglFramebuffer,U,j,r.COLOR_ATTACHMENT0+R,r.TEXTURE_2D),M(j,ke)&&E(r.TEXTURE_2D)}t.unbindTexture()}else{let C=r.TEXTURE_2D;(U.isWebGL3DRenderTarget||U.isWebGLArrayRenderTarget)&&(a?C=U.isWebGL3DRenderTarget?r.TEXTURE_3D:r.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(C,Ce.__webglTexture),Ee(C,I,ke),De(fe.__webglFramebuffer,U,I,r.COLOR_ATTACHMENT0,C),M(I,ke)&&E(C),t.unbindTexture()}U.depthBuffer&&X(U)}function Ae(U){const I=S(U)||a,fe=U.isWebGLMultipleRenderTargets===!0?U.texture:[U.texture];for(let Ce=0,Re=fe.length;Ce<Re;Ce++){const Ue=fe[Ce];if(M(Ue,I)){const ke=U.isWebGLCubeRenderTarget?r.TEXTURE_CUBE_MAP:r.TEXTURE_2D,C=n.get(Ue).__webglTexture;t.bindTexture(ke,C),E(ke),t.unbindTexture()}}}function Pe(U){if(a&&U.samples>0&&Ge(U)===!1){const I=U.isWebGLMultipleRenderTargets?U.texture:[U.texture],fe=U.width,Ce=U.height;let Re=r.COLOR_BUFFER_BIT;const Ue=[],ke=U.stencilBuffer?r.DEPTH_STENCIL_ATTACHMENT:r.DEPTH_ATTACHMENT,C=n.get(U),R=U.isWebGLMultipleRenderTargets===!0;if(R)for(let O=0;O<I.length;O++)t.bindFramebuffer(r.FRAMEBUFFER,C.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+O,r.RENDERBUFFER,null),t.bindFramebuffer(r.FRAMEBUFFER,C.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+O,r.TEXTURE_2D,null,0);t.bindFramebuffer(r.READ_FRAMEBUFFER,C.__webglMultisampledFramebuffer),t.bindFramebuffer(r.DRAW_FRAMEBUFFER,C.__webglFramebuffer);for(let O=0;O<I.length;O++){Ue.push(r.COLOR_ATTACHMENT0+O),U.depthBuffer&&Ue.push(ke);const j=C.__ignoreDepthValues!==void 0?C.__ignoreDepthValues:!1;if(j===!1&&(U.depthBuffer&&(Re|=r.DEPTH_BUFFER_BIT),U.stencilBuffer&&(Re|=r.STENCIL_BUFFER_BIT)),R&&r.framebufferRenderbuffer(r.READ_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.RENDERBUFFER,C.__webglColorRenderbuffer[O]),j===!0&&(r.invalidateFramebuffer(r.READ_FRAMEBUFFER,[ke]),r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER,[ke])),R){const q=n.get(I[O]).__webglTexture;r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,q,0)}r.blitFramebuffer(0,0,fe,Ce,0,0,fe,Ce,Re,r.NEAREST),f&&r.invalidateFramebuffer(r.READ_FRAMEBUFFER,Ue)}if(t.bindFramebuffer(r.READ_FRAMEBUFFER,null),t.bindFramebuffer(r.DRAW_FRAMEBUFFER,null),R)for(let O=0;O<I.length;O++){t.bindFramebuffer(r.FRAMEBUFFER,C.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0+O,r.RENDERBUFFER,C.__webglColorRenderbuffer[O]);const j=n.get(I[O]).__webglTexture;t.bindFramebuffer(r.FRAMEBUFFER,C.__webglFramebuffer),r.framebufferTexture2D(r.DRAW_FRAMEBUFFER,r.COLOR_ATTACHMENT0+O,r.TEXTURE_2D,j,0)}t.bindFramebuffer(r.DRAW_FRAMEBUFFER,C.__webglMultisampledFramebuffer)}}function Ie(U){return Math.min(u,U.samples)}function Ge(U){const I=n.get(U);return a&&U.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&I.__useRenderToTexture!==!1}function Ye(U){const I=o.render.frame;p.get(U)!==I&&(p.set(U,I),U.update())}function et(U,I){const fe=U.colorSpace,Ce=U.format,Re=U.type;return U.isCompressedTexture===!0||U.format===yc||fe!==Jn&&fe!==hs&&(fe===ot?a===!1?e.has("EXT_sRGB")===!0&&Ce===Rn?(U.format=yc,U.minFilter=It,U.generateMipmaps=!1):I=Yd.sRGBToLinear(I):(Ce!==Rn||Re!==Ui)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",fe)),I}this.allocateTextureUnit=W,this.resetTextureUnits=H,this.setTexture2D=oe,this.setTexture2DArray=Se,this.setTexture3D=K,this.setTextureCube=ce,this.rebindTextures=ie,this.setupRenderTarget=ne,this.updateRenderTargetMipmap=Ae,this.updateMultisampleRenderTarget=Pe,this.setupDepthRenderbuffer=X,this.setupFrameBufferTexture=De,this.useMultisampledRTT=Ge}function w1(r,e,t){const n=t.isWebGL2;function i(s,o=hs){let a;if(s===Ui)return r.UNSIGNED_BYTE;if(s===zd)return r.UNSIGNED_SHORT_4_4_4_4;if(s===Vd)return r.UNSIGNED_SHORT_5_5_5_1;if(s===k_)return r.BYTE;if(s===G_)return r.SHORT;if(s===Ic)return r.UNSIGNED_SHORT;if(s===Fd)return r.INT;if(s===Oi)return r.UNSIGNED_INT;if(s===ui)return r.FLOAT;if(s===so)return n?r.HALF_FLOAT:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(s===H_)return r.ALPHA;if(s===Rn)return r.RGBA;if(s===W_)return r.LUMINANCE;if(s===X_)return r.LUMINANCE_ALPHA;if(s===ls)return r.DEPTH_COMPONENT;if(s===$s)return r.DEPTH_STENCIL;if(s===yc)return a=e.get("EXT_sRGB"),a!==null?a.SRGB_ALPHA_EXT:null;if(s===j_)return r.RED;if(s===Bd)return r.RED_INTEGER;if(s===Y_)return r.RG;if(s===kd)return r.RG_INTEGER;if(s===Gd)return r.RGBA_INTEGER;if(s===rc||s===oc||s===ac||s===lc)if(o===ot)if(a=e.get("WEBGL_compressed_texture_s3tc_srgb"),a!==null){if(s===rc)return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(s===oc)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(s===ac)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(s===lc)return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(s===rc)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===oc)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===ac)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===lc)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===Hu||s===Wu||s===Xu||s===ju)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(s===Hu)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===Wu)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===Xu)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===ju)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===q_)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if(s===Yu||s===qu)if(a=e.get("WEBGL_compressed_texture_etc"),a!==null){if(s===Yu)return o===ot?a.COMPRESSED_SRGB8_ETC2:a.COMPRESSED_RGB8_ETC2;if(s===qu)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:a.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(s===$u||s===Zu||s===Ku||s===Ju||s===Qu||s===ed||s===td||s===nd||s===id||s===sd||s===rd||s===od||s===ad||s===ld)if(a=e.get("WEBGL_compressed_texture_astc"),a!==null){if(s===$u)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:a.COMPRESSED_RGBA_ASTC_4x4_KHR;if(s===Zu)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:a.COMPRESSED_RGBA_ASTC_5x4_KHR;if(s===Ku)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:a.COMPRESSED_RGBA_ASTC_5x5_KHR;if(s===Ju)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:a.COMPRESSED_RGBA_ASTC_6x5_KHR;if(s===Qu)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:a.COMPRESSED_RGBA_ASTC_6x6_KHR;if(s===ed)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:a.COMPRESSED_RGBA_ASTC_8x5_KHR;if(s===td)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:a.COMPRESSED_RGBA_ASTC_8x6_KHR;if(s===nd)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:a.COMPRESSED_RGBA_ASTC_8x8_KHR;if(s===id)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:a.COMPRESSED_RGBA_ASTC_10x5_KHR;if(s===sd)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:a.COMPRESSED_RGBA_ASTC_10x6_KHR;if(s===rd)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:a.COMPRESSED_RGBA_ASTC_10x8_KHR;if(s===od)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:a.COMPRESSED_RGBA_ASTC_10x10_KHR;if(s===ad)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:a.COMPRESSED_RGBA_ASTC_12x10_KHR;if(s===ld)return o===ot?a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:a.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(s===cc)if(a=e.get("EXT_texture_compression_bptc"),a!==null){if(s===cc)return o===ot?a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:a.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(s===$_||s===cd||s===hd||s===ud)if(a=e.get("EXT_texture_compression_rgtc"),a!==null){if(s===cc)return a.COMPRESSED_RED_RGTC1_EXT;if(s===cd)return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(s===hd)return a.COMPRESSED_RED_GREEN_RGTC2_EXT;if(s===ud)return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return s===as?n?r.UNSIGNED_INT_24_8:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null):r[s]!==void 0?r[s]:null}return{convert:i}}class M1 extends Yt{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Zr extends mt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const KM={type:"move"};class Yh{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Zr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Zr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new F,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new F),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Zr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new F,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new F),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,s=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const _ of e.hand.values()){const g=t.getJointPose(_,n),m=this._getHandJoint(c,_);g!==null&&(m.matrix.fromArray(g.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.matrixWorldNeedsUpdate=!0,m.jointRadius=g.radius),m.visible=g!==null}const h=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],d=h.position.distanceTo(u.position),f=.02,p=.005;c.inputState.pinching&&d>f+p?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=f-p&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,n),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&s!==null&&(i=s),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(KM)))}return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new Zr;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}class A1 extends Lt{constructor(e,t,n,i,s,o,a,l,c,h){if(h=h!==void 0?h:ls,h!==ls&&h!==$s)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&h===ls&&(n=Oi),n===void 0&&h===$s&&(n=as),super(null,i,s,o,a,l,h,n,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=a!==void 0?a:Pt,this.minFilter=l!==void 0?l:Pt,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class JM extends Gi{constructor(e,t){super();const n=this;let i=null,s=1,o=null,a="local-floor",l=1,c=null,h=null,u=null,d=null,f=null,p=null;const _=t.getContextAttributes();let g=null,m=null;const v=[],y=[];let S=null;const b=new Yt;b.layers.enable(1),b.viewport=new _t;const M=new Yt;M.layers.enable(2),M.viewport=new _t;const E=[b,M],T=new M1;T.layers.enable(1),T.layers.enable(2);let w=null,A=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getCamera=function(){},this.setUserCamera=function(K){S=K},this.getController=function(K){let ce=v[K];return ce===void 0&&(ce=new Yh,v[K]=ce),ce.getTargetRaySpace()},this.getControllerGrip=function(K){let ce=v[K];return ce===void 0&&(ce=new Yh,v[K]=ce),ce.getGripSpace()},this.getHand=function(K){let ce=v[K];return ce===void 0&&(ce=new Yh,v[K]=ce),ce.getHandSpace()};function D(K){const ce=y.indexOf(K.inputSource);if(ce===-1)return;const Z=v[ce];Z!==void 0&&(Z.update(K.inputSource,K.frame,c||o),Z.dispatchEvent({type:K.type,data:K.inputSource}))}function k(){i.removeEventListener("select",D),i.removeEventListener("selectstart",D),i.removeEventListener("selectend",D),i.removeEventListener("squeeze",D),i.removeEventListener("squeezestart",D),i.removeEventListener("squeezeend",D),i.removeEventListener("end",k),i.removeEventListener("inputsourceschange",G);for(let K=0;K<v.length;K++){const ce=y[K];ce!==null&&(y[K]=null,v[K].disconnect(ce))}w=null,A=null,e.setRenderTarget(g),f=null,d=null,u=null,i=null,m=null,Se.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(K){s=K,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(K){a=K,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(K){c=K},this.getBaseLayer=function(){return d!==null?d:f},this.getBinding=function(){return u},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(K){if(i=K,i!==null){if(g=e.getRenderTarget(),i.addEventListener("select",D),i.addEventListener("selectstart",D),i.addEventListener("selectend",D),i.addEventListener("squeeze",D),i.addEventListener("squeezestart",D),i.addEventListener("squeezeend",D),i.addEventListener("end",k),i.addEventListener("inputsourceschange",G),_.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const ce={antialias:i.renderState.layers===void 0?_.antialias:!0,alpha:!0,depth:_.depth,stencil:_.stencil,framebufferScaleFactor:s};f=new XRWebGLLayer(i,t,ce),i.updateRenderState({baseLayer:f}),m=new Qn(f.framebufferWidth,f.framebufferHeight,{format:Rn,type:Ui,colorSpace:e.outputColorSpace,stencilBuffer:_.stencil})}else{let ce=null,Z=null,_e=null;_.depth&&(_e=_.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,ce=_.stencil?$s:ls,Z=_.stencil?as:Oi);const xe={colorFormat:t.RGBA8,depthFormat:_e,scaleFactor:s};u=new XRWebGLBinding(i,t),d=u.createProjectionLayer(xe),i.updateRenderState({layers:[d]}),m=new Qn(d.textureWidth,d.textureHeight,{format:Rn,type:Ui,depthTexture:new A1(d.textureWidth,d.textureHeight,Z,void 0,void 0,void 0,void 0,void 0,void 0,ce),stencilBuffer:_.stencil,colorSpace:e.outputColorSpace,samples:_.antialias?4:0});const Ee=e.properties.get(m);Ee.__ignoreDepthValues=d.ignoreDepthValues}m.isXRRenderTarget=!0,this.setFoveation(l),c=null,o=await i.requestReferenceSpace(a),Se.setContext(i),Se.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function G(K){for(let ce=0;ce<K.removed.length;ce++){const Z=K.removed[ce],_e=y.indexOf(Z);_e>=0&&(y[_e]=null,v[_e].disconnect(Z))}for(let ce=0;ce<K.added.length;ce++){const Z=K.added[ce];let _e=y.indexOf(Z);if(_e===-1){for(let Ee=0;Ee<v.length;Ee++)if(Ee>=y.length){y.push(Z),_e=Ee;break}else if(y[Ee]===null){y[Ee]=Z,_e=Ee;break}if(_e===-1)break}const xe=v[_e];xe&&xe.connect(Z)}}const P=new F,N=new F;function B(K,ce,Z){P.setFromMatrixPosition(ce.matrixWorld),N.setFromMatrixPosition(Z.matrixWorld);const _e=P.distanceTo(N),xe=ce.projectionMatrix.elements,Ee=Z.projectionMatrix.elements,Ne=xe[14]/(xe[10]-1),Oe=xe[14]/(xe[10]+1),Ve=(xe[9]+1)/xe[5],De=(xe[9]-1)/xe[5],z=(xe[8]-1)/xe[0],ye=(Ee[8]+1)/Ee[0],X=Ne*z,ie=Ne*ye,ne=_e/(-z+ye),Ae=ne*-z;ce.matrixWorld.decompose(K.position,K.quaternion,K.scale),K.translateX(Ae),K.translateZ(ne),K.matrixWorld.compose(K.position,K.quaternion,K.scale),K.matrixWorldInverse.copy(K.matrixWorld).invert();const Pe=Ne+ne,Ie=Oe+ne,Ge=X-Ae,Ye=ie+(_e-Ae),et=Ve*Oe/Ie*Pe,U=De*Oe/Ie*Pe;K.projectionMatrix.makePerspective(Ge,Ye,et,U,Pe,Ie),K.projectionMatrixInverse.copy(K.projectionMatrix).invert()}function H(K,ce){ce===null?K.matrixWorld.copy(K.matrix):K.matrixWorld.multiplyMatrices(ce.matrixWorld,K.matrix),K.matrixWorldInverse.copy(K.matrixWorld).invert()}this.updateCameraXR=function(K){if(i===null)return K;S&&(K=S),T.near=M.near=b.near=K.near,T.far=M.far=b.far=K.far,(w!==T.near||A!==T.far)&&(i.updateRenderState({depthNear:T.near,depthFar:T.far}),w=T.near,A=T.far);const ce=K.parent,Z=T.cameras;H(T,ce);for(let _e=0;_e<Z.length;_e++)H(Z[_e],ce);return Z.length===2?B(T,b,M):T.projectionMatrix.copy(b.projectionMatrix),S&&W(T,ce),T};function W(K,ce){const Z=S;ce===null?Z.matrix.copy(K.matrixWorld):(Z.matrix.copy(ce.matrixWorld),Z.matrix.invert(),Z.matrix.multiply(K.matrixWorld)),Z.matrix.decompose(Z.position,Z.quaternion,Z.scale),Z.updateMatrixWorld(!0);const _e=Z.children;for(let xe=0,Ee=_e.length;xe<Ee;xe++)_e[xe].updateMatrixWorld(!0);Z.projectionMatrix.copy(K.projectionMatrix),Z.projectionMatrixInverse.copy(K.projectionMatrixInverse),Z.isPerspectiveCamera&&(Z.fov=ro*2*Math.atan(1/Z.projectionMatrix.elements[5]),Z.zoom=1)}this.getFoveation=function(){if(!(d===null&&f===null))return l},this.setFoveation=function(K){l=K,d!==null&&(d.fixedFoveation=K),f!==null&&f.fixedFoveation!==void 0&&(f.fixedFoveation=K)};let $=null;function oe(K,ce){if(h=ce.getViewerPose(c||o),p=ce,h!==null){const Z=h.views;f!==null&&(e.setRenderTargetFramebuffer(m,f.framebuffer),e.setRenderTarget(m));let _e=!1;Z.length!==T.cameras.length&&(T.cameras.length=0,_e=!0);for(let xe=0;xe<Z.length;xe++){const Ee=Z[xe];let Ne=null;if(f!==null)Ne=f.getViewport(Ee);else{const Ve=u.getViewSubImage(d,Ee);Ne=Ve.viewport,xe===0&&(e.setRenderTargetTextures(m,Ve.colorTexture,d.ignoreDepthValues?void 0:Ve.depthStencilTexture),e.setRenderTarget(m))}let Oe=E[xe];Oe===void 0&&(Oe=new Yt,Oe.layers.enable(xe),Oe.viewport=new _t,E[xe]=Oe),Oe.matrix.fromArray(Ee.transform.matrix),Oe.matrix.decompose(Oe.position,Oe.quaternion,Oe.scale),Oe.projectionMatrix.fromArray(Ee.projectionMatrix),Oe.projectionMatrixInverse.copy(Oe.projectionMatrix).invert(),Oe.viewport.set(Ne.x,Ne.y,Ne.width,Ne.height),xe===0&&(T.matrix.copy(Oe.matrix),T.matrix.decompose(T.position,T.quaternion,T.scale)),_e===!0&&T.cameras.push(Oe)}}for(let Z=0;Z<v.length;Z++){const _e=y[Z],xe=v[Z];_e!==null&&xe!==void 0&&xe.update(_e,ce,c||o)}$&&$(K,ce),ce.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:ce}),p=null}const Se=new y1;Se.setAnimationLoop(oe),this.setAnimationLoop=function(K){$=K},this.dispose=function(){}}}function QM(r,e){function t(g,m){g.matrixAutoUpdate===!0&&g.updateMatrix(),m.value.copy(g.matrix)}function n(g,m){m.color.getRGB(g.fogColor.value,p1(r)),m.isFog?(g.fogNear.value=m.near,g.fogFar.value=m.far):m.isFogExp2&&(g.fogDensity.value=m.density)}function i(g,m,v,y,S){m.isMeshBasicMaterial||m.isMeshLambertMaterial?s(g,m):m.isMeshToonMaterial?(s(g,m),u(g,m)):m.isMeshPhongMaterial?(s(g,m),h(g,m)):m.isMeshStandardMaterial?(s(g,m),d(g,m),m.isMeshPhysicalMaterial&&f(g,m,S)):m.isMeshMatcapMaterial?(s(g,m),p(g,m)):m.isMeshDepthMaterial?s(g,m):m.isMeshDistanceMaterial?(s(g,m),_(g,m)):m.isMeshNormalMaterial?s(g,m):m.isLineBasicMaterial?(o(g,m),m.isLineDashedMaterial&&a(g,m)):m.isPointsMaterial?l(g,m,v,y):m.isSpriteMaterial?c(g,m):m.isShadowMaterial?(g.color.value.copy(m.color),g.opacity.value=m.opacity):m.isShaderMaterial&&(m.uniformsNeedUpdate=!1)}function s(g,m){g.opacity.value=m.opacity,m.color&&g.diffuse.value.copy(m.color),m.emissive&&g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity),m.map&&(g.map.value=m.map,t(m.map,g.mapTransform)),m.alphaMap&&(g.alphaMap.value=m.alphaMap,t(m.alphaMap,g.alphaMapTransform)),m.bumpMap&&(g.bumpMap.value=m.bumpMap,t(m.bumpMap,g.bumpMapTransform),g.bumpScale.value=m.bumpScale,m.side===cn&&(g.bumpScale.value*=-1)),m.normalMap&&(g.normalMap.value=m.normalMap,t(m.normalMap,g.normalMapTransform),g.normalScale.value.copy(m.normalScale),m.side===cn&&g.normalScale.value.negate()),m.displacementMap&&(g.displacementMap.value=m.displacementMap,t(m.displacementMap,g.displacementMapTransform),g.displacementScale.value=m.displacementScale,g.displacementBias.value=m.displacementBias),m.emissiveMap&&(g.emissiveMap.value=m.emissiveMap,t(m.emissiveMap,g.emissiveMapTransform)),m.specularMap&&(g.specularMap.value=m.specularMap,t(m.specularMap,g.specularMapTransform)),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest);const v=e.get(m).envMap;if(v&&(g.envMap.value=v,g.flipEnvMap.value=v.isCubeTexture&&v.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=m.reflectivity,g.ior.value=m.ior,g.refractionRatio.value=m.refractionRatio),m.lightMap){g.lightMap.value=m.lightMap;const y=r.useLegacyLights===!0?Math.PI:1;g.lightMapIntensity.value=m.lightMapIntensity*y,t(m.lightMap,g.lightMapTransform)}m.aoMap&&(g.aoMap.value=m.aoMap,g.aoMapIntensity.value=m.aoMapIntensity,t(m.aoMap,g.aoMapTransform))}function o(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,m.map&&(g.map.value=m.map,t(m.map,g.mapTransform))}function a(g,m){g.dashSize.value=m.dashSize,g.totalSize.value=m.dashSize+m.gapSize,g.scale.value=m.scale}function l(g,m,v,y){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.size.value=m.size*v,g.scale.value=y*.5,m.map&&(g.map.value=m.map,t(m.map,g.uvTransform)),m.alphaMap&&(g.alphaMap.value=m.alphaMap,t(m.alphaMap,g.alphaMapTransform)),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest)}function c(g,m){g.diffuse.value.copy(m.color),g.opacity.value=m.opacity,g.rotation.value=m.rotation,m.map&&(g.map.value=m.map,t(m.map,g.mapTransform)),m.alphaMap&&(g.alphaMap.value=m.alphaMap,t(m.alphaMap,g.alphaMapTransform)),m.alphaTest>0&&(g.alphaTest.value=m.alphaTest)}function h(g,m){g.specular.value.copy(m.specular),g.shininess.value=Math.max(m.shininess,1e-4)}function u(g,m){m.gradientMap&&(g.gradientMap.value=m.gradientMap)}function d(g,m){g.metalness.value=m.metalness,m.metalnessMap&&(g.metalnessMap.value=m.metalnessMap,t(m.metalnessMap,g.metalnessMapTransform)),g.roughness.value=m.roughness,m.roughnessMap&&(g.roughnessMap.value=m.roughnessMap,t(m.roughnessMap,g.roughnessMapTransform)),e.get(m).envMap&&(g.envMapIntensity.value=m.envMapIntensity)}function f(g,m,v){g.ior.value=m.ior,m.sheen>0&&(g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen),g.sheenRoughness.value=m.sheenRoughness,m.sheenColorMap&&(g.sheenColorMap.value=m.sheenColorMap,t(m.sheenColorMap,g.sheenColorMapTransform)),m.sheenRoughnessMap&&(g.sheenRoughnessMap.value=m.sheenRoughnessMap,t(m.sheenRoughnessMap,g.sheenRoughnessMapTransform))),m.clearcoat>0&&(g.clearcoat.value=m.clearcoat,g.clearcoatRoughness.value=m.clearcoatRoughness,m.clearcoatMap&&(g.clearcoatMap.value=m.clearcoatMap,t(m.clearcoatMap,g.clearcoatMapTransform)),m.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=m.clearcoatRoughnessMap,t(m.clearcoatRoughnessMap,g.clearcoatRoughnessMapTransform)),m.clearcoatNormalMap&&(g.clearcoatNormalMap.value=m.clearcoatNormalMap,t(m.clearcoatNormalMap,g.clearcoatNormalMapTransform),g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale),m.side===cn&&g.clearcoatNormalScale.value.negate())),m.iridescence>0&&(g.iridescence.value=m.iridescence,g.iridescenceIOR.value=m.iridescenceIOR,g.iridescenceThicknessMinimum.value=m.iridescenceThicknessRange[0],g.iridescenceThicknessMaximum.value=m.iridescenceThicknessRange[1],m.iridescenceMap&&(g.iridescenceMap.value=m.iridescenceMap,t(m.iridescenceMap,g.iridescenceMapTransform)),m.iridescenceThicknessMap&&(g.iridescenceThicknessMap.value=m.iridescenceThicknessMap,t(m.iridescenceThicknessMap,g.iridescenceThicknessMapTransform))),m.transmission>0&&(g.transmission.value=m.transmission,g.transmissionSamplerMap.value=v.texture,g.transmissionSamplerSize.value.set(v.width,v.height),m.transmissionMap&&(g.transmissionMap.value=m.transmissionMap,t(m.transmissionMap,g.transmissionMapTransform)),g.thickness.value=m.thickness,m.thicknessMap&&(g.thicknessMap.value=m.thicknessMap,t(m.thicknessMap,g.thicknessMapTransform)),g.attenuationDistance.value=m.attenuationDistance,g.attenuationColor.value.copy(m.attenuationColor)),m.anisotropy>0&&(g.anisotropyVector.value.set(m.anisotropy*Math.cos(m.anisotropyRotation),m.anisotropy*Math.sin(m.anisotropyRotation)),m.anisotropyMap&&(g.anisotropyMap.value=m.anisotropyMap,t(m.anisotropyMap,g.anisotropyMapTransform))),g.specularIntensity.value=m.specularIntensity,g.specularColor.value.copy(m.specularColor),m.specularColorMap&&(g.specularColorMap.value=m.specularColorMap,t(m.specularColorMap,g.specularColorMapTransform)),m.specularIntensityMap&&(g.specularIntensityMap.value=m.specularIntensityMap,t(m.specularIntensityMap,g.specularIntensityMapTransform))}function p(g,m){m.matcap&&(g.matcap.value=m.matcap)}function _(g,m){const v=e.get(m).light;g.referencePosition.value.setFromMatrixPosition(v.matrixWorld),g.nearDistance.value=v.shadow.camera.near,g.farDistance.value=v.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function eA(r,e,t,n){let i={},s={},o=[];const a=t.isWebGL2?r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(v,y){const S=y.program;n.uniformBlockBinding(v,S)}function c(v,y){let S=i[v.id];S===void 0&&(p(v),S=h(v),i[v.id]=S,v.addEventListener("dispose",g));const b=y.program;n.updateUBOMapping(v,b);const M=e.render.frame;s[v.id]!==M&&(d(v),s[v.id]=M)}function h(v){const y=u();v.__bindingPointIndex=y;const S=r.createBuffer(),b=v.__size,M=v.usage;return r.bindBuffer(r.UNIFORM_BUFFER,S),r.bufferData(r.UNIFORM_BUFFER,b,M),r.bindBuffer(r.UNIFORM_BUFFER,null),r.bindBufferBase(r.UNIFORM_BUFFER,y,S),S}function u(){for(let v=0;v<a;v++)if(o.indexOf(v)===-1)return o.push(v),v;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(v){const y=i[v.id],S=v.uniforms,b=v.__cache;r.bindBuffer(r.UNIFORM_BUFFER,y);for(let M=0,E=S.length;M<E;M++){const T=S[M];if(f(T,M,b)===!0){const w=T.__offset,A=Array.isArray(T.value)?T.value:[T.value];let D=0;for(let k=0;k<A.length;k++){const G=A[k],P=_(G);typeof G=="number"?(T.__data[0]=G,r.bufferSubData(r.UNIFORM_BUFFER,w+D,T.__data)):G.isMatrix3?(T.__data[0]=G.elements[0],T.__data[1]=G.elements[1],T.__data[2]=G.elements[2],T.__data[3]=G.elements[0],T.__data[4]=G.elements[3],T.__data[5]=G.elements[4],T.__data[6]=G.elements[5],T.__data[7]=G.elements[0],T.__data[8]=G.elements[6],T.__data[9]=G.elements[7],T.__data[10]=G.elements[8],T.__data[11]=G.elements[0]):(G.toArray(T.__data,D),D+=P.storage/Float32Array.BYTES_PER_ELEMENT)}r.bufferSubData(r.UNIFORM_BUFFER,w,T.__data)}}r.bindBuffer(r.UNIFORM_BUFFER,null)}function f(v,y,S){const b=v.value;if(S[y]===void 0){if(typeof b=="number")S[y]=b;else{const M=Array.isArray(b)?b:[b],E=[];for(let T=0;T<M.length;T++)E.push(M[T].clone());S[y]=E}return!0}else if(typeof b=="number"){if(S[y]!==b)return S[y]=b,!0}else{const M=Array.isArray(S[y])?S[y]:[S[y]],E=Array.isArray(b)?b:[b];for(let T=0;T<M.length;T++){const w=M[T];if(w.equals(E[T])===!1)return w.copy(E[T]),!0}}return!1}function p(v){const y=v.uniforms;let S=0;const b=16;let M=0;for(let E=0,T=y.length;E<T;E++){const w=y[E],A={boundary:0,storage:0},D=Array.isArray(w.value)?w.value:[w.value];for(let k=0,G=D.length;k<G;k++){const P=D[k],N=_(P);A.boundary+=N.boundary,A.storage+=N.storage}if(w.__data=new Float32Array(A.storage/Float32Array.BYTES_PER_ELEMENT),w.__offset=S,E>0){M=S%b;const k=b-M;M!==0&&k-A.boundary<0&&(S+=b-M,w.__offset=S)}S+=A.storage}return M=S%b,M>0&&(S+=b-M),v.__size=S,v.__cache={},this}function _(v){const y={boundary:0,storage:0};return typeof v=="number"?(y.boundary=4,y.storage=4):v.isVector2?(y.boundary=8,y.storage=8):v.isVector3||v.isColor?(y.boundary=16,y.storage=12):v.isVector4?(y.boundary=16,y.storage=16):v.isMatrix3?(y.boundary=48,y.storage=48):v.isMatrix4?(y.boundary=64,y.storage=64):v.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",v),y}function g(v){const y=v.target;y.removeEventListener("dispose",g);const S=o.indexOf(y.__bindingPointIndex);o.splice(S,1),r.deleteBuffer(i[y.id]),delete i[y.id],delete s[y.id]}function m(){for(const v in i)r.deleteBuffer(i[v]);o=[],i={},s={}}return{bind:l,update:c,dispose:m}}function tA(){const r=oa("canvas");return r.style.display="block",r}class E1{constructor(e={}){const{canvas:t=tA(),context:n=null,depth:i=!0,stencil:s=!0,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:u=!1}=e;this.isWebGLRenderer=!0;let d;n!==null?d=n.getContextAttributes().alpha:d=o;const f=new Uint32Array(4),p=new Int32Array(4);let _=null,g=null;const m=[],v=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputColorSpace=ot,this.useLegacyLights=!0,this.toneMapping=fi,this.toneMappingExposure=1;const y=this;let S=!1,b=0,M=0,E=null,T=-1,w=null;const A=new _t,D=new _t;let k=null;const G=new He(0);let P=0,N=t.width,B=t.height,H=1,W=null,$=null;const oe=new _t(0,0,N,B),Se=new _t(0,0,N,B);let K=!1;const ce=new Uc;let Z=!1,_e=!1,xe=null;const Ee=new rt,Ne=new Te,Oe=new F,Ve={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function De(){return E===null?H:1}let z=n;function ye(L,re){for(let me=0;me<L.length;me++){const Q=L[me],pe=t.getContext(Q,re);if(pe!==null)return pe}return null}try{const L={alpha:!0,depth:i,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:u};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Rc}`),t.addEventListener("webglcontextlost",Me,!1),t.addEventListener("webglcontextrestored",se,!1),t.addEventListener("webglcontextcreationerror",ae,!1),z===null){const re=["webgl2","webgl","experimental-webgl"];if(y.isWebGL1Renderer===!0&&re.shift(),z=ye(re,L),z===null)throw ye(re)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}z instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),z.getShaderPrecisionFormat===void 0&&(z.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(L){throw console.error("THREE.WebGLRenderer: "+L.message),L}let X,ie,ne,Ae,Pe,Ie,Ge,Ye,et,U,I,fe,Ce,Re,Ue,ke,C,R,O,j,q,he,ee,we;function Le(){X=new _w(z),ie=new uw(z,X,e),X.init(ie),he=new w1(z,X,ie),ne=new $M(z,X,ie),Ae=new vw(z),Pe=new FM,Ie=new ZM(z,X,ne,Pe,ie,he,Ae),Ge=new fw(y),Ye=new gw(y),et=new Lv(z,ie),ee=new cw(z,X,et,ie),U=new yw(z,et,Ae,ee),I=new Mw(z,U,et,Ae),O=new ww(z,ie,Ie),ke=new dw(Pe),fe=new UM(y,Ge,Ye,X,ie,ee,ke),Ce=new QM(y,Pe),Re=new VM,Ue=new XM(X,ie),R=new lw(y,Ge,Ye,ne,I,d,l),C=new qM(y,I,ie),we=new eA(z,Ae,ie,ne),j=new hw(z,X,Ae,ie),q=new xw(z,X,Ae,ie),Ae.programs=fe.programs,y.capabilities=ie,y.extensions=X,y.properties=Pe,y.renderLists=Re,y.shadowMap=C,y.state=ne,y.info=Ae}Le();const V=new JM(y,z);this.xr=V,this.getContext=function(){return z},this.getContextAttributes=function(){return z.getContextAttributes()},this.forceContextLoss=function(){const L=X.get("WEBGL_lose_context");L&&L.loseContext()},this.forceContextRestore=function(){const L=X.get("WEBGL_lose_context");L&&L.restoreContext()},this.getPixelRatio=function(){return H},this.setPixelRatio=function(L){L!==void 0&&(H=L,this.setSize(N,B,!1))},this.getSize=function(L){return L.set(N,B)},this.setSize=function(L,re,me=!0){if(V.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}N=L,B=re,t.width=Math.floor(L*H),t.height=Math.floor(re*H),me===!0&&(t.style.width=L+"px",t.style.height=re+"px"),this.setViewport(0,0,L,re)},this.getDrawingBufferSize=function(L){return L.set(N*H,B*H).floor()},this.setDrawingBufferSize=function(L,re,me){N=L,B=re,H=me,t.width=Math.floor(L*me),t.height=Math.floor(re*me),this.setViewport(0,0,L,re)},this.getCurrentViewport=function(L){return L.copy(A)},this.getViewport=function(L){return L.copy(oe)},this.setViewport=function(L,re,me,Q){L.isVector4?oe.set(L.x,L.y,L.z,L.w):oe.set(L,re,me,Q),ne.viewport(A.copy(oe).multiplyScalar(H).floor())},this.getScissor=function(L){return L.copy(Se)},this.setScissor=function(L,re,me,Q){L.isVector4?Se.set(L.x,L.y,L.z,L.w):Se.set(L,re,me,Q),ne.scissor(D.copy(Se).multiplyScalar(H).floor())},this.getScissorTest=function(){return K},this.setScissorTest=function(L){ne.setScissorTest(K=L)},this.setOpaqueSort=function(L){W=L},this.setTransparentSort=function(L){$=L},this.getClearColor=function(L){return L.copy(R.getClearColor())},this.setClearColor=function(){R.setClearColor.apply(R,arguments)},this.getClearAlpha=function(){return R.getClearAlpha()},this.setClearAlpha=function(){R.setClearAlpha.apply(R,arguments)},this.clear=function(L=!0,re=!0,me=!0){let Q=0;if(L){let pe=!1;if(E!==null){const Be=E.texture.format;pe=Be===Gd||Be===kd||Be===Bd}if(pe){const Be=E.texture.type,Xe=Be===Ui||Be===Oi||Be===Ic||Be===as||Be===zd||Be===Vd,Ze=R.getClearColor(),$e=R.getClearAlpha(),tt=Ze.r,qe=Ze.g,st=Ze.b,yt=Pe.get(E).__webglFramebuffer;Xe?(f[0]=tt,f[1]=qe,f[2]=st,f[3]=$e,z.clearBufferuiv(z.COLOR,yt,f)):(p[0]=tt,p[1]=qe,p[2]=st,p[3]=$e,z.clearBufferiv(z.COLOR,yt,p))}else Q|=z.COLOR_BUFFER_BIT}re&&(Q|=z.DEPTH_BUFFER_BIT),me&&(Q|=z.STENCIL_BUFFER_BIT),z.clear(Q)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Me,!1),t.removeEventListener("webglcontextrestored",se,!1),t.removeEventListener("webglcontextcreationerror",ae,!1),Re.dispose(),Ue.dispose(),Pe.dispose(),Ge.dispose(),Ye.dispose(),I.dispose(),ee.dispose(),we.dispose(),fe.dispose(),V.dispose(),V.removeEventListener("sessionstart",Qe),V.removeEventListener("sessionend",ue),xe&&(xe.dispose(),xe=null),it.stop()};function Me(L){L.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),S=!0}function se(){console.log("THREE.WebGLRenderer: Context Restored."),S=!1;const L=Ae.autoReset,re=C.enabled,me=C.autoUpdate,Q=C.needsUpdate,pe=C.type;Le(),Ae.autoReset=L,C.enabled=re,C.autoUpdate=me,C.needsUpdate=Q,C.type=pe}function ae(L){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",L.statusMessage)}function ge(L){const re=L.target;re.removeEventListener("dispose",ge),Fe(re)}function Fe(L){Y(L),Pe.remove(L)}function Y(L){const re=Pe.get(L).programs;re!==void 0&&(re.forEach(function(me){fe.releaseProgram(me)}),L.isShaderMaterial&&fe.releaseShaderCache(L))}this.renderBufferDirect=function(L,re,me,Q,pe,Be){re===null&&(re=Ve);const Xe=pe.isMesh&&pe.matrixWorld.determinant()<0,Ze=Wi(L,re,me,Q,pe);ne.setMaterial(Q,Xe);let $e=me.index,tt=1;Q.wireframe===!0&&($e=U.getWireframeAttribute(me),tt=2);const qe=me.drawRange,st=me.attributes.position;let yt=qe.start*tt,wt=(qe.start+qe.count)*tt;Be!==null&&(yt=Math.max(yt,Be.start*tt),wt=Math.min(wt,(Be.start+Be.count)*tt)),$e!==null?(yt=Math.max(yt,0),wt=Math.min(wt,$e.count)):st!=null&&(yt=Math.max(yt,0),wt=Math.min(wt,st.count));const sn=wt-yt;if(sn<0||sn===1/0)return;ee.setup(pe,Q,Ze,me,$e);let bn,Nt=j;if($e!==null&&(bn=et.get($e),Nt=q,Nt.setIndex(bn)),pe.isMesh)Q.wireframe===!0?(ne.setLineWidth(Q.wireframeLinewidth*De()),Nt.setMode(z.LINES)):Nt.setMode(z.TRIANGLES);else if(pe.isLine){let dt=Q.linewidth;dt===void 0&&(dt=1),ne.setLineWidth(dt*De()),pe.isLineSegments?Nt.setMode(z.LINES):pe.isLineLoop?Nt.setMode(z.LINE_LOOP):Nt.setMode(z.LINE_STRIP)}else pe.isPoints?Nt.setMode(z.POINTS):pe.isSprite&&Nt.setMode(z.TRIANGLES);if(pe.isInstancedMesh)Nt.renderInstances(yt,sn,pe.count);else if(me.isInstancedBufferGeometry){const dt=me._maxInstanceCount!==void 0?me._maxInstanceCount:1/0,wh=Math.min(me.instanceCount,dt);Nt.renderInstances(yt,sn,wh)}else Nt.render(yt,sn)},this.compile=function(L,re){function me(Q,pe,Be){Q.transparent===!0&&Q.side===hi&&Q.forceSinglePass===!1?(Q.side=cn,Q.needsUpdate=!0,kt(Q,pe,Be),Q.side=Fi,Q.needsUpdate=!0,kt(Q,pe,Be),Q.side=hi):kt(Q,pe,Be)}g=Ue.get(L),g.init(),v.push(g),L.traverseVisible(function(Q){Q.isLight&&Q.layers.test(re.layers)&&(g.pushLight(Q),Q.castShadow&&g.pushShadow(Q))}),g.setupLights(y.useLegacyLights),L.traverse(function(Q){const pe=Q.material;if(pe)if(Array.isArray(pe))for(let Be=0;Be<pe.length;Be++){const Xe=pe[Be];me(Xe,L,Q)}else me(pe,L,Q)}),v.pop(),g=null};let We=null;function J(L){We&&We(L)}function Qe(){it.stop()}function ue(){it.start()}const it=new y1;it.setAnimationLoop(J),typeof self<"u"&&it.setContext(self),this.setAnimationLoop=function(L){We=L,V.setAnimationLoop(L),L===null?it.stop():it.start()},V.addEventListener("sessionstart",Qe),V.addEventListener("sessionend",ue),this.render=function(L,re){if(re!==void 0&&re.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(S===!0)return;L.matrixWorldAutoUpdate===!0&&L.updateMatrixWorld(),re.parent===null&&re.matrixWorldAutoUpdate===!0&&re.updateMatrixWorld(),V.enabled===!0&&V.isPresenting===!0&&(re=V.updateCameraXR(re)),L.isScene===!0&&L.onBeforeRender(y,L,re,E),g=Ue.get(L,v.length),g.init(),v.push(g),Ee.multiplyMatrices(re.projectionMatrix,re.matrixWorldInverse),ce.setFromProjectionMatrix(Ee),_e=this.localClippingEnabled,Z=ke.init(this.clippingPlanes,_e),_=Re.get(L,m.length),_.init(),m.push(_),Xt(L,re,0,y.sortObjects),_.finish(),y.sortObjects===!0&&_.sort(W,$),Z===!0&&ke.beginShadows();const me=g.state.shadowsArray;if(C.render(me,L,re),Z===!0&&ke.endShadows(),this.info.autoReset===!0&&this.info.reset(),this.info.render.frame++,R.render(_,L),g.setupLights(y.useLegacyLights),re.isArrayCamera){const Q=re.cameras;for(let pe=0,Be=Q.length;pe<Be;pe++){const Xe=Q[pe];$t(_,L,Xe,Xe.viewport)}}else $t(_,L,re);E!==null&&(Ie.updateMultisampleRenderTarget(E),Ie.updateRenderTargetMipmap(E)),L.isScene===!0&&L.onAfterRender(y,L,re),ee.resetDefaultState(),T=-1,w=null,v.pop(),v.length>0?g=v[v.length-1]:g=null,m.pop(),m.length>0?_=m[m.length-1]:_=null};function Xt(L,re,me,Q){if(L.visible===!1)return;if(L.layers.test(re.layers)){if(L.isGroup)me=L.renderOrder;else if(L.isLOD)L.autoUpdate===!0&&L.update(re);else if(L.isLight)g.pushLight(L),L.castShadow&&g.pushShadow(L);else if(L.isSprite){if(!L.frustumCulled||ce.intersectsSprite(L)){Q&&Oe.setFromMatrixPosition(L.matrixWorld).applyMatrix4(Ee);const Xe=I.update(L),Ze=L.material;Ze.visible&&_.push(L,Xe,Ze,me,Oe.z,null)}}else if((L.isMesh||L.isLine||L.isPoints)&&(!L.frustumCulled||ce.intersectsObject(L))){L.isSkinnedMesh&&L.skeleton.frame!==Ae.render.frame&&(L.skeleton.update(),L.skeleton.frame=Ae.render.frame);const Xe=I.update(L),Ze=L.material;if(Q&&(L.boundingSphere!==void 0?(L.boundingSphere===null&&L.computeBoundingSphere(),Oe.copy(L.boundingSphere.center)):(Xe.boundingSphere===null&&Xe.computeBoundingSphere(),Oe.copy(Xe.boundingSphere.center)),Oe.applyMatrix4(L.matrixWorld).applyMatrix4(Ee)),Array.isArray(Ze)){const $e=Xe.groups;for(let tt=0,qe=$e.length;tt<qe;tt++){const st=$e[tt],yt=Ze[st.materialIndex];yt&&yt.visible&&_.push(L,Xe,yt,me,Oe.z,st)}}else Ze.visible&&_.push(L,Xe,Ze,me,Oe.z,null)}}const Be=L.children;for(let Xe=0,Ze=Be.length;Xe<Ze;Xe++)Xt(Be[Xe],re,me,Q)}function $t(L,re,me,Q){const pe=L.opaque,Be=L.transmissive,Xe=L.transparent;g.setupLightsView(me),Z===!0&&ke.setGlobalState(y.clippingPlanes,me),Be.length>0&&Fn(pe,Be,re,me),Q&&ne.viewport(A.copy(Q)),pe.length>0&&Zt(pe,re,me),Be.length>0&&Zt(Be,re,me),Xe.length>0&&Zt(Xe,re,me),ne.buffers.depth.setTest(!0),ne.buffers.depth.setMask(!0),ne.buffers.color.setMask(!0),ne.setPolygonOffset(!1)}function Fn(L,re,me,Q){const pe=ie.isWebGL2;xe===null&&(xe=new Qn(1,1,{generateMipmaps:!0,type:X.has("EXT_color_buffer_half_float")?so:Ui,minFilter:ps,samples:pe&&a===!0?4:0})),y.getDrawingBufferSize(Ne),pe?xe.setSize(Ne.x,Ne.y):xe.setSize(xc(Ne.x),xc(Ne.y));const Be=y.getRenderTarget();y.setRenderTarget(xe),y.getClearColor(G),P=y.getClearAlpha(),P<1&&y.setClearColor(16777215,.5),y.clear();const Xe=y.toneMapping;y.toneMapping=fi,Zt(L,me,Q),Ie.updateMultisampleRenderTarget(xe),Ie.updateRenderTargetMipmap(xe);let Ze=!1;for(let $e=0,tt=re.length;$e<tt;$e++){const qe=re[$e],st=qe.object,yt=qe.geometry,wt=qe.material,sn=qe.group;if(wt.side===hi&&st.layers.test(Q.layers)){const bn=wt.side;wt.side=cn,wt.needsUpdate=!0,xt(st,me,Q,yt,wt,sn),wt.side=bn,wt.needsUpdate=!0,Ze=!0}}Ze===!0&&(Ie.updateMultisampleRenderTarget(xe),Ie.updateRenderTargetMipmap(xe)),y.setRenderTarget(Be),y.setClearColor(G,P),y.toneMapping=Xe}function Zt(L,re,me){const Q=re.isScene===!0?re.overrideMaterial:null;for(let pe=0,Be=L.length;pe<Be;pe++){const Xe=L[pe],Ze=Xe.object,$e=Xe.geometry,tt=Q===null?Xe.material:Q,qe=Xe.group;Ze.layers.test(me.layers)&&xt(Ze,re,me,$e,tt,qe)}}function xt(L,re,me,Q,pe,Be){L.onBeforeRender(y,re,me,Q,pe,Be),L.modelViewMatrix.multiplyMatrices(me.matrixWorldInverse,L.matrixWorld),L.normalMatrix.getNormalMatrix(L.modelViewMatrix),pe.onBeforeRender(y,re,me,Q,L,Be),pe.transparent===!0&&pe.side===hi&&pe.forceSinglePass===!1?(pe.side=cn,pe.needsUpdate=!0,y.renderBufferDirect(me,re,Q,pe,L,Be),pe.side=Fi,pe.needsUpdate=!0,y.renderBufferDirect(me,re,Q,pe,L,Be),pe.side=hi):y.renderBufferDirect(me,re,Q,pe,L,Be),L.onAfterRender(y,re,me,Q,pe,Be)}function kt(L,re,me){re.isScene!==!0&&(re=Ve);const Q=Pe.get(L),pe=g.state.lights,Be=g.state.shadowsArray,Xe=pe.state.version,Ze=fe.getParameters(L,pe.state,Be,re,me),$e=fe.getProgramCacheKey(Ze);let tt=Q.programs;Q.environment=L.isMeshStandardMaterial?re.environment:null,Q.fog=re.fog,Q.envMap=(L.isMeshStandardMaterial?Ye:Ge).get(L.envMap||Q.environment),tt===void 0&&(L.addEventListener("dispose",ge),tt=new Map,Q.programs=tt);let qe=tt.get($e);if(qe!==void 0){if(Q.currentProgram===qe&&Q.lightsStateVersion===Xe)return vi(L,Ze),qe}else Ze.uniforms=fe.getUniforms(L),L.onBuild(me,Ze,y),L.onBeforeCompile(Ze,y),qe=fe.acquireProgram(Ze,$e),tt.set($e,qe),Q.uniforms=Ze.uniforms;const st=Q.uniforms;(!L.isShaderMaterial&&!L.isRawShaderMaterial||L.clipping===!0)&&(st.clippingPlanes=ke.uniform),vi(L,Ze),Q.needsLights=ur(L),Q.lightsStateVersion=Xe,Q.needsLights&&(st.ambientLightColor.value=pe.state.ambient,st.lightProbe.value=pe.state.probe,st.directionalLights.value=pe.state.directional,st.directionalLightShadows.value=pe.state.directionalShadow,st.spotLights.value=pe.state.spot,st.spotLightShadows.value=pe.state.spotShadow,st.rectAreaLights.value=pe.state.rectArea,st.ltc_1.value=pe.state.rectAreaLTC1,st.ltc_2.value=pe.state.rectAreaLTC2,st.pointLights.value=pe.state.point,st.pointLightShadows.value=pe.state.pointShadow,st.hemisphereLights.value=pe.state.hemi,st.directionalShadowMap.value=pe.state.directionalShadowMap,st.directionalShadowMatrix.value=pe.state.directionalShadowMatrix,st.spotShadowMap.value=pe.state.spotShadowMap,st.spotLightMatrix.value=pe.state.spotLightMatrix,st.spotLightMap.value=pe.state.spotLightMap,st.pointShadowMap.value=pe.state.pointShadowMap,st.pointShadowMatrix.value=pe.state.pointShadowMatrix);const yt=qe.getUniforms(),wt=dc.seqWithValue(yt.seq,st);return Q.currentProgram=qe,Q.uniformsList=wt,qe}function vi(L,re){const me=Pe.get(L);me.outputColorSpace=re.outputColorSpace,me.instancing=re.instancing,me.skinning=re.skinning,me.morphTargets=re.morphTargets,me.morphNormals=re.morphNormals,me.morphColors=re.morphColors,me.morphTargetsCount=re.morphTargetsCount,me.numClippingPlanes=re.numClippingPlanes,me.numIntersection=re.numClipIntersection,me.vertexAlphas=re.vertexAlphas,me.vertexTangents=re.vertexTangents,me.toneMapping=re.toneMapping}function Wi(L,re,me,Q,pe){re.isScene!==!0&&(re=Ve),Ie.resetTextureUnits();const Be=re.fog,Xe=Q.isMeshStandardMaterial?re.environment:null,Ze=E===null?y.outputColorSpace:E.isXRRenderTarget===!0?E.texture.colorSpace:Jn,$e=(Q.isMeshStandardMaterial?Ye:Ge).get(Q.envMap||Xe),tt=Q.vertexColors===!0&&!!me.attributes.color&&me.attributes.color.itemSize===4,qe=!!me.attributes.tangent&&(!!Q.normalMap||Q.anisotropy>0),st=!!me.morphAttributes.position,yt=!!me.morphAttributes.normal,wt=!!me.morphAttributes.color,sn=Q.toneMapped?y.toneMapping:fi,bn=me.morphAttributes.position||me.morphAttributes.normal||me.morphAttributes.color,Nt=bn!==void 0?bn.length:0,dt=Pe.get(Q),wh=g.state.lights;if(Z===!0&&(_e===!0||L!==w)){const wn=L===w&&Q.id===T;ke.setState(Q,L,wn)}let Gt=!1;Q.version===dt.__version?(dt.needsLights&&dt.lightsStateVersion!==wh.state.version||dt.outputColorSpace!==Ze||pe.isInstancedMesh&&dt.instancing===!1||!pe.isInstancedMesh&&dt.instancing===!0||pe.isSkinnedMesh&&dt.skinning===!1||!pe.isSkinnedMesh&&dt.skinning===!0||dt.envMap!==$e||Q.fog===!0&&dt.fog!==Be||dt.numClippingPlanes!==void 0&&(dt.numClippingPlanes!==ke.numPlanes||dt.numIntersection!==ke.numIntersection)||dt.vertexAlphas!==tt||dt.vertexTangents!==qe||dt.morphTargets!==st||dt.morphNormals!==yt||dt.morphColors!==wt||dt.toneMapping!==sn||ie.isWebGL2===!0&&dt.morphTargetsCount!==Nt)&&(Gt=!0):(Gt=!0,dt.__version=Q.version);let ws=dt.currentProgram;Gt===!0&&(ws=kt(Q,re,pe));let vp=!1,vo=!1,Mh=!1;const rn=ws.getUniforms(),Ms=dt.uniforms;if(ne.useProgram(ws.program)&&(vp=!0,vo=!0,Mh=!0),Q.id!==T&&(T=Q.id,vo=!0),vp||w!==L){if(rn.setValue(z,"projectionMatrix",L.projectionMatrix),ie.logarithmicDepthBuffer&&rn.setValue(z,"logDepthBufFC",2/(Math.log(L.far+1)/Math.LN2)),w!==L&&(w=L,vo=!0,Mh=!0),Q.isShaderMaterial||Q.isMeshPhongMaterial||Q.isMeshToonMaterial||Q.isMeshStandardMaterial||Q.envMap){const wn=rn.map.cameraPosition;wn!==void 0&&wn.setValue(z,Oe.setFromMatrixPosition(L.matrixWorld))}(Q.isMeshPhongMaterial||Q.isMeshToonMaterial||Q.isMeshLambertMaterial||Q.isMeshBasicMaterial||Q.isMeshStandardMaterial||Q.isShaderMaterial)&&rn.setValue(z,"isOrthographic",L.isOrthographicCamera===!0),(Q.isMeshPhongMaterial||Q.isMeshToonMaterial||Q.isMeshLambertMaterial||Q.isMeshBasicMaterial||Q.isMeshStandardMaterial||Q.isShaderMaterial||Q.isShadowMaterial||pe.isSkinnedMesh)&&rn.setValue(z,"viewMatrix",L.matrixWorldInverse)}if(pe.isSkinnedMesh){rn.setOptional(z,pe,"bindMatrix"),rn.setOptional(z,pe,"bindMatrixInverse");const wn=pe.skeleton;wn&&(ie.floatVertexTextures?(wn.boneTexture===null&&wn.computeBoneTexture(),rn.setValue(z,"boneTexture",wn.boneTexture,Ie),rn.setValue(z,"boneTextureSize",wn.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const Ah=me.morphAttributes;if((Ah.position!==void 0||Ah.normal!==void 0||Ah.color!==void 0&&ie.isWebGL2===!0)&&O.update(pe,me,ws),(vo||dt.receiveShadow!==pe.receiveShadow)&&(dt.receiveShadow=pe.receiveShadow,rn.setValue(z,"receiveShadow",pe.receiveShadow)),Q.isMeshGouraudMaterial&&Q.envMap!==null&&(Ms.envMap.value=$e,Ms.flipEnvMap.value=$e.isCubeTexture&&$e.isRenderTargetTexture===!1?-1:1),vo&&(rn.setValue(z,"toneMappingExposure",y.toneMappingExposure),dt.needsLights&&Xi(Ms,Mh),Be&&Q.fog===!0&&Ce.refreshFogUniforms(Ms,Be),Ce.refreshMaterialUniforms(Ms,Q,H,B,xe),dc.upload(z,dt.uniformsList,Ms,Ie)),Q.isShaderMaterial&&Q.uniformsNeedUpdate===!0&&(dc.upload(z,dt.uniformsList,Ms,Ie),Q.uniformsNeedUpdate=!1),Q.isSpriteMaterial&&rn.setValue(z,"center",pe.center),rn.setValue(z,"modelViewMatrix",pe.modelViewMatrix),rn.setValue(z,"normalMatrix",pe.normalMatrix),rn.setValue(z,"modelMatrix",pe.matrixWorld),Q.isShaderMaterial||Q.isRawShaderMaterial){const wn=Q.uniformsGroups;for(let Eh=0,Jy=wn.length;Eh<Jy;Eh++)if(ie.isWebGL2){const Sp=wn[Eh];we.update(Sp,ws),we.bind(Sp,ws)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return ws}function Xi(L,re){L.ambientLightColor.needsUpdate=re,L.lightProbe.needsUpdate=re,L.directionalLights.needsUpdate=re,L.directionalLightShadows.needsUpdate=re,L.pointLights.needsUpdate=re,L.pointLightShadows.needsUpdate=re,L.spotLights.needsUpdate=re,L.spotLightShadows.needsUpdate=re,L.rectAreaLights.needsUpdate=re,L.hemisphereLights.needsUpdate=re}function ur(L){return L.isMeshLambertMaterial||L.isMeshToonMaterial||L.isMeshPhongMaterial||L.isMeshStandardMaterial||L.isShadowMaterial||L.isShaderMaterial&&L.lights===!0}this.getActiveCubeFace=function(){return b},this.getActiveMipmapLevel=function(){return M},this.getRenderTarget=function(){return E},this.setRenderTargetTextures=function(L,re,me){Pe.get(L.texture).__webglTexture=re,Pe.get(L.depthTexture).__webglTexture=me;const Q=Pe.get(L);Q.__hasExternalTextures=!0,Q.__hasExternalTextures&&(Q.__autoAllocateDepthBuffer=me===void 0,Q.__autoAllocateDepthBuffer||X.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Q.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(L,re){const me=Pe.get(L);me.__webglFramebuffer=re,me.__useDefaultFramebuffer=re===void 0},this.setRenderTarget=function(L,re=0,me=0){E=L,b=re,M=me;let Q=!0,pe=null,Be=!1,Xe=!1;if(L){const $e=Pe.get(L);$e.__useDefaultFramebuffer!==void 0?(ne.bindFramebuffer(z.FRAMEBUFFER,null),Q=!1):$e.__webglFramebuffer===void 0?Ie.setupRenderTarget(L):$e.__hasExternalTextures&&Ie.rebindTextures(L,Pe.get(L.texture).__webglTexture,Pe.get(L.depthTexture).__webglTexture);const tt=L.texture;(tt.isData3DTexture||tt.isDataArrayTexture||tt.isCompressedArrayTexture)&&(Xe=!0);const qe=Pe.get(L).__webglFramebuffer;L.isWebGLCubeRenderTarget?(pe=qe[re],Be=!0):ie.isWebGL2&&L.samples>0&&Ie.useMultisampledRTT(L)===!1?pe=Pe.get(L).__webglMultisampledFramebuffer:pe=qe,A.copy(L.viewport),D.copy(L.scissor),k=L.scissorTest}else A.copy(oe).multiplyScalar(H).floor(),D.copy(Se).multiplyScalar(H).floor(),k=K;if(ne.bindFramebuffer(z.FRAMEBUFFER,pe)&&ie.drawBuffers&&Q&&ne.drawBuffers(L,pe),ne.viewport(A),ne.scissor(D),ne.setScissorTest(k),Be){const $e=Pe.get(L.texture);z.framebufferTexture2D(z.FRAMEBUFFER,z.COLOR_ATTACHMENT0,z.TEXTURE_CUBE_MAP_POSITIVE_X+re,$e.__webglTexture,me)}else if(Xe){const $e=Pe.get(L.texture),tt=re||0;z.framebufferTextureLayer(z.FRAMEBUFFER,z.COLOR_ATTACHMENT0,$e.__webglTexture,me||0,tt)}T=-1},this.readRenderTargetPixels=function(L,re,me,Q,pe,Be,Xe){if(!(L&&L.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ze=Pe.get(L).__webglFramebuffer;if(L.isWebGLCubeRenderTarget&&Xe!==void 0&&(Ze=Ze[Xe]),Ze){ne.bindFramebuffer(z.FRAMEBUFFER,Ze);try{const $e=L.texture,tt=$e.format,qe=$e.type;if(tt!==Rn&&he.convert(tt)!==z.getParameter(z.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const st=qe===so&&(X.has("EXT_color_buffer_half_float")||ie.isWebGL2&&X.has("EXT_color_buffer_float"));if(qe!==Ui&&he.convert(qe)!==z.getParameter(z.IMPLEMENTATION_COLOR_READ_TYPE)&&!(qe===ui&&(ie.isWebGL2||X.has("OES_texture_float")||X.has("WEBGL_color_buffer_float")))&&!st){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}re>=0&&re<=L.width-Q&&me>=0&&me<=L.height-pe&&z.readPixels(re,me,Q,pe,he.convert(tt),he.convert(qe),Be)}finally{const $e=E!==null?Pe.get(E).__webglFramebuffer:null;ne.bindFramebuffer(z.FRAMEBUFFER,$e)}}},this.copyFramebufferToTexture=function(L,re,me=0){const Q=Math.pow(2,-me),pe=Math.floor(re.image.width*Q),Be=Math.floor(re.image.height*Q);Ie.setTexture2D(re,0),z.copyTexSubImage2D(z.TEXTURE_2D,me,0,0,L.x,L.y,pe,Be),ne.unbindTexture()},this.copyTextureToTexture=function(L,re,me,Q=0){const pe=re.image.width,Be=re.image.height,Xe=he.convert(me.format),Ze=he.convert(me.type);Ie.setTexture2D(me,0),z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL,me.flipY),z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL,me.premultiplyAlpha),z.pixelStorei(z.UNPACK_ALIGNMENT,me.unpackAlignment),re.isDataTexture?z.texSubImage2D(z.TEXTURE_2D,Q,L.x,L.y,pe,Be,Xe,Ze,re.image.data):re.isCompressedTexture?z.compressedTexSubImage2D(z.TEXTURE_2D,Q,L.x,L.y,re.mipmaps[0].width,re.mipmaps[0].height,Xe,re.mipmaps[0].data):z.texSubImage2D(z.TEXTURE_2D,Q,L.x,L.y,Xe,Ze,re.image),Q===0&&me.generateMipmaps&&z.generateMipmap(z.TEXTURE_2D),ne.unbindTexture()},this.copyTextureToTexture3D=function(L,re,me,Q,pe=0){if(y.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Be=L.max.x-L.min.x+1,Xe=L.max.y-L.min.y+1,Ze=L.max.z-L.min.z+1,$e=he.convert(Q.format),tt=he.convert(Q.type);let qe;if(Q.isData3DTexture)Ie.setTexture3D(Q,0),qe=z.TEXTURE_3D;else if(Q.isDataArrayTexture)Ie.setTexture2DArray(Q,0),qe=z.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}z.pixelStorei(z.UNPACK_FLIP_Y_WEBGL,Q.flipY),z.pixelStorei(z.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Q.premultiplyAlpha),z.pixelStorei(z.UNPACK_ALIGNMENT,Q.unpackAlignment);const st=z.getParameter(z.UNPACK_ROW_LENGTH),yt=z.getParameter(z.UNPACK_IMAGE_HEIGHT),wt=z.getParameter(z.UNPACK_SKIP_PIXELS),sn=z.getParameter(z.UNPACK_SKIP_ROWS),bn=z.getParameter(z.UNPACK_SKIP_IMAGES),Nt=me.isCompressedTexture?me.mipmaps[0]:me.image;z.pixelStorei(z.UNPACK_ROW_LENGTH,Nt.width),z.pixelStorei(z.UNPACK_IMAGE_HEIGHT,Nt.height),z.pixelStorei(z.UNPACK_SKIP_PIXELS,L.min.x),z.pixelStorei(z.UNPACK_SKIP_ROWS,L.min.y),z.pixelStorei(z.UNPACK_SKIP_IMAGES,L.min.z),me.isDataTexture||me.isData3DTexture?z.texSubImage3D(qe,pe,re.x,re.y,re.z,Be,Xe,Ze,$e,tt,Nt.data):me.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),z.compressedTexSubImage3D(qe,pe,re.x,re.y,re.z,Be,Xe,Ze,$e,Nt.data)):z.texSubImage3D(qe,pe,re.x,re.y,re.z,Be,Xe,Ze,$e,tt,Nt),z.pixelStorei(z.UNPACK_ROW_LENGTH,st),z.pixelStorei(z.UNPACK_IMAGE_HEIGHT,yt),z.pixelStorei(z.UNPACK_SKIP_PIXELS,wt),z.pixelStorei(z.UNPACK_SKIP_ROWS,sn),z.pixelStorei(z.UNPACK_SKIP_IMAGES,bn),pe===0&&Q.generateMipmaps&&z.generateMipmap(qe),ne.unbindTexture()},this.initTexture=function(L){L.isCubeTexture?Ie.setTextureCube(L,0):L.isData3DTexture?Ie.setTexture3D(L,0):L.isDataArrayTexture||L.isCompressedArrayTexture?Ie.setTexture2DArray(L,0):Ie.setTexture2D(L,0),ne.unbindTexture()},this.resetState=function(){b=0,M=0,E=null,ne.reset(),ee.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return di}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(e){console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!e}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===ot?cs:Wd}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===cs?ot:Jn}}class T1 extends E1{}T1.prototype.isWebGL1Renderer=!0;class Vc{constructor(e,t=25e-5){this.isFogExp2=!0,this.name="",this.color=new He(e),this.density=t}clone(){return new Vc(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Bc{constructor(e,t=1,n=1e3){this.isFog=!0,this.name="",this.color=new He(e),this.near=t,this.far=n}clone(){return new Bc(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class C1 extends mt{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}get autoUpdate(){return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate}set autoUpdate(e){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."),this.matrixWorldAutoUpdate=e}}class kc{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=sa,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=In()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=In()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const on=new F;class Zs{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)on.fromBufferAttribute(this,t),on.applyMatrix4(e),this.setXYZ(t,on.x,on.y,on.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)on.fromBufferAttribute(this,t),on.applyNormalMatrix(e),this.setXYZ(t,on.x,on.y,on.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)on.fromBufferAttribute(this,t),on.transformDirection(e),this.setXYZ(t,on.x,on.y,on.z);return this}setX(e,t){return this.normalized&&(t=ct(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=ct(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=ct(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=ct(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Pn(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Pn(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Pn(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Pn(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array),i=ct(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=ct(t,this.array),n=ct(n,this.array),i=ct(i,this.array),s=ct(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new vt(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Zs(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class ef extends tn{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new He(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Cr;const Ao=new F,Rr=new F,Pr=new F,Ir=new Te,Eo=new Te,R1=new rt,ml=new F,To=new F,gl=new F,om=new Te,qh=new Te,am=new Te;class P1 extends mt{constructor(e){if(super(),this.isSprite=!0,this.type="Sprite",Cr===void 0){Cr=new ht;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new kc(t,5);Cr.setIndex([0,1,2,0,2,3]),Cr.setAttribute("position",new Zs(n,3,0,!1)),Cr.setAttribute("uv",new Zs(n,2,3,!1))}this.geometry=Cr,this.material=e!==void 0?e:new ef,this.center=new Te(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Rr.setFromMatrixScale(this.matrixWorld),R1.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Pr.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Rr.multiplyScalar(-Pr.z);const n=this.material.rotation;let i,s;n!==0&&(s=Math.cos(n),i=Math.sin(n));const o=this.center;_l(ml.set(-.5,-.5,0),Pr,o,Rr,i,s),_l(To.set(.5,-.5,0),Pr,o,Rr,i,s),_l(gl.set(.5,.5,0),Pr,o,Rr,i,s),om.set(0,0),qh.set(1,0),am.set(1,1);let a=e.ray.intersectTriangle(ml,To,gl,!1,Ao);if(a===null&&(_l(To.set(-.5,.5,0),Pr,o,Rr,i,s),qh.set(0,1),a=e.ray.intersectTriangle(ml,gl,To,!1,Ao),a===null))return;const l=e.ray.origin.distanceTo(Ao);l<e.near||l>e.far||t.push({distance:l,point:Ao.clone(),uv:Ws.getInterpolation(Ao,ml,To,gl,om,qh,am,new Te),face:null,object:this})}copy(e,t){return super.copy(e,t),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function _l(r,e,t,n,i,s){Ir.subVectors(r,t).addScalar(.5).multiply(n),i!==void 0?(Eo.x=s*Ir.x-i*Ir.y,Eo.y=i*Ir.x+s*Ir.y):Eo.copy(Ir),r.copy(e),r.x+=Eo.x,r.y+=Eo.y,r.applyMatrix4(R1)}const yl=new F,lm=new F;class I1 extends mt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const s=t[n];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,t=0,n=0){t=Math.abs(t);const i=this.levels;let s;for(s=0;s<i.length&&!(t<i[s].distance);s++);return i.splice(s,0,{distance:t,hysteresis:n,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i;n++){let s=t[n].distance;if(t[n].object.visible&&(s-=s*t[n].hysteresis),e<s)break}return t[n-1].object}return null}raycast(e,t){if(this.levels.length>0){yl.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(yl);this.getObjectForDistance(i).raycast(e,t)}}update(e){const t=this.levels;if(t.length>1){yl.setFromMatrixPosition(e.matrixWorld),lm.setFromMatrixPosition(this.matrixWorld);const n=yl.distanceTo(lm)/e.zoom;t[0].object.visible=!0;let i,s;for(i=1,s=t.length;i<s;i++){let o=t[i].distance;if(t[i].object.visible&&(o-=o*t[i].hysteresis),n>=o)t[i-1].object.visible=!1,t[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<s;i++)t[i].object.visible=!1}}toJSON(e){const t=super.toJSON(e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,s=n.length;i<s;i++){const o=n[i];t.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return t}}const cm=new F,hm=new _t,um=new _t,nA=new F,dm=new rt,Lr=new F,$h=new ni,fm=new rt,Zh=new ho;class L1 extends qt{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new rt,this.bindMatrixInverse=new rt,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new _i),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)Lr.fromBufferAttribute(t,n),this.applyBoneTransform(n,Lr),this.boundingBox.expandByPoint(Lr)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new ni),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)Lr.fromBufferAttribute(t,n),this.applyBoneTransform(n,Lr),this.boundingSphere.expandByPoint(Lr)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const n=this.material,i=this.matrixWorld;n!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),$h.copy(this.boundingSphere),$h.applyMatrix4(i),e.ray.intersectsSphere($h)!==!1&&(fm.copy(i).invert(),Zh.copy(e.ray).applyMatrix4(fm),!(this.boundingBox!==null&&Zh.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,Zh)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new _t,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const n=this.skeleton,i=this.geometry;hm.fromBufferAttribute(i.attributes.skinIndex,e),um.fromBufferAttribute(i.attributes.skinWeight,e),cm.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const o=um.getComponent(s);if(o!==0){const a=hm.getComponent(s);dm.multiplyMatrices(n.bones[a].matrixWorld,n.boneInverses[a]),t.addScaledVector(nA.copy(cm).applyMatrix4(dm),o)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class tf extends mt{constructor(){super(),this.isBone=!0,this.type="Bone"}}class eo extends Lt{constructor(e=null,t=1,n=1,i,s,o,a,l,c=Pt,h=Pt,u,d){super(null,o,a,l,c,h,i,s,u,d),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const pm=new rt,iA=new rt;class Gc{constructor(e=[],t=[]){this.uuid=In(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new rt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new rt;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:iA;pm.multiplyMatrices(a,t[s]),pm.toArray(n,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new Gc(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=u1(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new eo(t,e,e,Rn,ui);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const s=e.bones[n];let o=t[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new tf),this.bones.push(o),this.boneInverses.push(new rt().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,s=t.length;i<s;i++){const o=t[i];e.bones.push(o.uuid);const a=n[i];e.boneInverses.push(a.toArray())}return e}}class ao extends vt{constructor(e,t,n,i=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Nr=new rt,mm=new rt,xl=[],gm=new _i,sA=new rt,Co=new qt,Ro=new ni;let N1=class extends qt{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new ao(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<n;i++)this.setMatrixAt(i,sA)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new _i),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,Nr),gm.copy(e.boundingBox).applyMatrix4(Nr),this.boundingBox.union(gm)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new ni),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,Nr),Ro.copy(e.boundingSphere).applyMatrix4(Nr),this.boundingSphere.union(Ro)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,i=this.count;if(Co.geometry=this.geometry,Co.material=this.material,Co.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Ro.copy(this.boundingSphere),Ro.applyMatrix4(n),e.ray.intersectsSphere(Ro)!==!1))for(let s=0;s<i;s++){this.getMatrixAt(s,Nr),mm.multiplyMatrices(n,Nr),Co.matrixWorld=mm,Co.raycast(e,xl);for(let o=0,a=xl.length;o<a;o++){const l=xl[o];l.instanceId=s,l.object=this,t.push(l)}xl.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new ao(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}};class un extends tn{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new He(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const _m=new F,ym=new F,xm=new rt,Kh=new ho,vl=new ni;class ms extends mt{constructor(e=new ht,t=new un){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,s=t.count;i<s;i++)_m.fromBufferAttribute(t,i-1),ym.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=_m.distanceTo(ym);e.setAttribute("lineDistance",new je(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),vl.copy(n.boundingSphere),vl.applyMatrix4(i),vl.radius+=s,e.ray.intersectsSphere(vl)===!1)return;xm.copy(i).invert(),Kh.copy(e.ray).applyMatrix4(xm);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new F,h=new F,u=new F,d=new F,f=this.isLineSegments?2:1,p=n.index,g=n.attributes.position;if(p!==null){const m=Math.max(0,o.start),v=Math.min(p.count,o.start+o.count);for(let y=m,S=v-1;y<S;y+=f){const b=p.getX(y),M=p.getX(y+1);if(c.fromBufferAttribute(g,b),h.fromBufferAttribute(g,M),Kh.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const T=e.ray.origin.distanceTo(d);T<e.near||T>e.far||t.push({distance:T,point:u.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}else{const m=Math.max(0,o.start),v=Math.min(g.count,o.start+o.count);for(let y=m,S=v-1;y<S;y+=f){if(c.fromBufferAttribute(g,y),h.fromBufferAttribute(g,y+1),Kh.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:u.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}const vm=new F,Sm=new F;class yi extends ms{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,s=t.count;i<s;i+=2)vm.fromBufferAttribute(t,i),Sm.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+vm.distanceTo(Sm);e.setAttribute("lineDistance",new je(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class O1 extends ms{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class nf extends tn{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new He(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const bm=new rt,gd=new ho,Sl=new ni,bl=new F;class D1 extends mt{constructor(e=new ht,t=new nf){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,o=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Sl.copy(n.boundingSphere),Sl.applyMatrix4(i),Sl.radius+=s,e.ray.intersectsSphere(Sl)===!1)return;bm.copy(i).invert(),gd.copy(e.ray).applyMatrix4(bm);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=n.index,u=n.attributes.position;if(c!==null){const d=Math.max(0,o.start),f=Math.min(c.count,o.start+o.count);for(let p=d,_=f;p<_;p++){const g=c.getX(p);bl.fromBufferAttribute(u,g),wm(bl,g,l,i,e,t,this)}}else{const d=Math.max(0,o.start),f=Math.min(u.count,o.start+o.count);for(let p=d,_=f;p<_;p++)bl.fromBufferAttribute(u,p),wm(bl,p,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function wm(r,e,t,n,i,s,o){const a=gd.distanceSqToPoint(r);if(a<t){const l=new F;gd.closestPointToPoint(r,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class rA extends Lt{constructor(e,t,n,i,s,o,a,l,c){super(e,t,n,i,s,o,a,l,c),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:It,this.magFilter=s!==void 0?s:It,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,e.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class oA extends Lt{constructor(e,t){super({width:e,height:t}),this.isFramebufferTexture=!0,this.magFilter=Pt,this.minFilter=Pt,this.generateMipmaps=!1,this.needsUpdate=!0}}class sf extends Lt{constructor(e,t,n,i,s,o,a,l,c,h,u,d){super(null,o,a,l,c,h,i,s,u,d),this.isCompressedTexture=!0,this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class aA extends sf{constructor(e,t,n,i,s,o){super(e,t,n,s,o),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=en}}class lA extends Lt{constructor(e,t,n,i,s,o,a,l,c){super(e,t,n,i,s,o,a,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class ii{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),s=0;t.push(0);for(let o=1;o<=e;o++)n=this.getPoint(o/e),s+=n.distanceTo(i),t.push(s),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const s=n.length;let o;t?o=t:o=e*n[s-1];let a=0,l=s-1,c;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),c=n[i]-o,c<0)a=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,n[i]===o)return i/(s-1);const h=n[i],d=n[i+1]-h,f=(o-h)/d;return(i+f)/(s-1)}getTangent(e,t){let i=e-1e-4,s=e+1e-4;i<0&&(i=0),s>1&&(s=1);const o=this.getPoint(i),a=this.getPoint(s),l=t||(o.isVector2?new Te:new F);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new F,i=[],s=[],o=[],a=new F,l=new rt;for(let f=0;f<=e;f++){const p=f/e;i[f]=this.getTangentAt(p,new F)}s[0]=new F,o[0]=new F;let c=Number.MAX_VALUE;const h=Math.abs(i[0].x),u=Math.abs(i[0].y),d=Math.abs(i[0].z);h<=c&&(c=h,n.set(1,0,0)),u<=c&&(c=u,n.set(0,1,0)),d<=c&&n.set(0,0,1),a.crossVectors(i[0],n).normalize(),s[0].crossVectors(i[0],a),o[0].crossVectors(i[0],s[0]);for(let f=1;f<=e;f++){if(s[f]=s[f-1].clone(),o[f]=o[f-1].clone(),a.crossVectors(i[f-1],i[f]),a.length()>Number.EPSILON){a.normalize();const p=Math.acos(Ct(i[f-1].dot(i[f]),-1,1));s[f].applyMatrix4(l.makeRotationAxis(a,p))}o[f].crossVectors(i[f],s[f])}if(t===!0){let f=Math.acos(Ct(s[0].dot(s[e]),-1,1));f/=e,i[0].dot(a.crossVectors(s[0],s[e]))>0&&(f=-f);for(let p=1;p<=e;p++)s[p].applyMatrix4(l.makeRotationAxis(i[p],f*p)),o[p].crossVectors(i[p],s[p])}return{tangents:i,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Hc extends ii{constructor(e=0,t=0,n=1,i=1,s=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const n=t||new Te,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(o?s=0:s=i),this.aClockwise===!0&&!o&&(s===i?s=-i:s=s-i);const a=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const h=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*h-f*u+this.aX,c=d*u+f*h+this.aY}return n.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class U1 extends Hc{constructor(e,t,n,i,s,o){super(e,t,n,n,i,s,o),this.isArcCurve=!0,this.type="ArcCurve"}}function rf(){let r=0,e=0,t=0,n=0;function i(s,o,a,l){r=s,e=a,t=-3*s+3*o-2*a-l,n=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){i(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,h,u){let d=(o-s)/c-(a-s)/(c+h)+(a-o)/h,f=(a-o)/h-(l-o)/(h+u)+(l-a)/u;d*=h,f*=h,i(o,a,d,f)},calc:function(s){const o=s*s,a=o*s;return r+e*s+t*o+n*a}}}const wl=new F,Jh=new rf,Qh=new rf,eu=new rf;class F1 extends ii{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new F){const n=t,i=this.points,s=i.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:l===0&&a===s-1&&(a=s-2,l=1);let c,h;this.closed||a>0?c=i[(a-1)%s]:(wl.subVectors(i[0],i[1]).add(i[0]),c=wl);const u=i[a%s],d=i[(a+1)%s];if(this.closed||a+2<s?h=i[(a+2)%s]:(wl.subVectors(i[s-1],i[s-2]).add(i[s-1]),h=wl),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(u),f),_=Math.pow(u.distanceToSquared(d),f),g=Math.pow(d.distanceToSquared(h),f);_<1e-4&&(_=1),p<1e-4&&(p=_),g<1e-4&&(g=_),Jh.initNonuniformCatmullRom(c.x,u.x,d.x,h.x,p,_,g),Qh.initNonuniformCatmullRom(c.y,u.y,d.y,h.y,p,_,g),eu.initNonuniformCatmullRom(c.z,u.z,d.z,h.z,p,_,g)}else this.curveType==="catmullrom"&&(Jh.initCatmullRom(c.x,u.x,d.x,h.x,this.tension),Qh.initCatmullRom(c.y,u.y,d.y,h.y,this.tension),eu.initCatmullRom(c.z,u.z,d.z,h.z,this.tension));return n.set(Jh.calc(l),Qh.calc(l),eu.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new F().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function Mm(r,e,t,n,i){const s=(n-e)*.5,o=(i-t)*.5,a=r*r,l=r*a;return(2*t-2*n+s+o)*l+(-3*t+3*n-2*s-o)*a+s*r+t}function cA(r,e){const t=1-r;return t*t*e}function hA(r,e){return 2*(1-r)*r*e}function uA(r,e){return r*r*e}function qo(r,e,t,n){return cA(r,e)+hA(r,t)+uA(r,n)}function dA(r,e){const t=1-r;return t*t*t*e}function fA(r,e){const t=1-r;return 3*t*t*r*e}function pA(r,e){return 3*(1-r)*r*r*e}function mA(r,e){return r*r*r*e}function $o(r,e,t,n,i){return dA(r,e)+fA(r,t)+pA(r,n)+mA(r,i)}class of extends ii{constructor(e=new Te,t=new Te,n=new Te,i=new Te){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new Te){const n=t,i=this.v0,s=this.v1,o=this.v2,a=this.v3;return n.set($o(e,i.x,s.x,o.x,a.x),$o(e,i.y,s.y,o.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class z1 extends ii{constructor(e=new F,t=new F,n=new F,i=new F){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new F){const n=t,i=this.v0,s=this.v1,o=this.v2,a=this.v3;return n.set($o(e,i.x,s.x,o.x,a.x),$o(e,i.y,s.y,o.y,a.y),$o(e,i.z,s.z,o.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class Wc extends ii{constructor(e=new Te,t=new Te){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Te){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Te){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class V1 extends ii{constructor(e=new F,t=new F){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new F){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new F){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class af extends ii{constructor(e=new Te,t=new Te,n=new Te){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Te){const n=t,i=this.v0,s=this.v1,o=this.v2;return n.set(qo(e,i.x,s.x,o.x),qo(e,i.y,s.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class lf extends ii{constructor(e=new F,t=new F,n=new F){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new F){const n=t,i=this.v0,s=this.v1,o=this.v2;return n.set(qo(e,i.x,s.x,o.x),qo(e,i.y,s.y,o.y),qo(e,i.z,s.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class cf extends ii{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Te){const n=t,i=this.points,s=(i.length-1)*e,o=Math.floor(s),a=s-o,l=i[o===0?o:o-1],c=i[o],h=i[o>i.length-2?i.length-1:o+1],u=i[o>i.length-3?i.length-1:o+2];return n.set(Mm(a,l.x,c.x,h.x,u.x),Mm(a,l.y,c.y,h.y,u.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new Te().fromArray(i))}return this}}var hf=Object.freeze({__proto__:null,ArcCurve:U1,CatmullRomCurve3:F1,CubicBezierCurve:of,CubicBezierCurve3:z1,EllipseCurve:Hc,LineCurve:Wc,LineCurve3:V1,QuadraticBezierCurve:af,QuadraticBezierCurve3:lf,SplineCurve:cf});class B1 extends ii{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Wc(t,e))}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let s=0;for(;s<i.length;){if(i[s]>=n){const o=i[s]-n,a=this.curves[s],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,t)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,s=this.curves;i<s.length;i++){const o=s[i],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const h=l[c];n&&n.equals(h)||(t.push(h),n=h)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new hf[i.type]().fromJSON(i))}return this}}class aa extends B1{constructor(e){super(),this.type="Path",this.currentPoint=new Te,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new Wc(this.currentPoint.clone(),new Te(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const s=new af(this.currentPoint.clone(),new Te(e,t),new Te(n,i));return this.curves.push(s),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,s,o){const a=new of(this.currentPoint.clone(),new Te(e,t),new Te(n,i),new Te(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new cf(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,s,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,n,i,s,o),this}absarc(e,t,n,i,s,o){return this.absellipse(e,t,n,n,i,s,o),this}ellipse(e,t,n,i,s,o,a,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(e+c,t+h,n,i,s,o,a,l),this}absellipse(e,t,n,i,s,o,a,l){const c=new Hc(e,t,n,i,s,o,a,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class po extends ht{constructor(e=[new Te(0,-.5),new Te(.5,0),new Te(0,.5)],t=12,n=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:t,phiStart:n,phiLength:i},t=Math.floor(t),i=Ct(i,0,Math.PI*2);const s=[],o=[],a=[],l=[],c=[],h=1/t,u=new F,d=new Te,f=new F,p=new F,_=new F;let g=0,m=0;for(let v=0;v<=e.length-1;v++)switch(v){case 0:g=e[v+1].x-e[v].x,m=e[v+1].y-e[v].y,f.x=m*1,f.y=-g,f.z=m*0,_.copy(f),f.normalize(),l.push(f.x,f.y,f.z);break;case e.length-1:l.push(_.x,_.y,_.z);break;default:g=e[v+1].x-e[v].x,m=e[v+1].y-e[v].y,f.x=m*1,f.y=-g,f.z=m*0,p.copy(f),f.x+=_.x,f.y+=_.y,f.z+=_.z,f.normalize(),l.push(f.x,f.y,f.z),_.copy(p)}for(let v=0;v<=t;v++){const y=n+v*h*i,S=Math.sin(y),b=Math.cos(y);for(let M=0;M<=e.length-1;M++){u.x=e[M].x*S,u.y=e[M].y,u.z=e[M].x*b,o.push(u.x,u.y,u.z),d.x=v/t,d.y=M/(e.length-1),a.push(d.x,d.y);const E=l[3*M+0]*S,T=l[3*M+1],w=l[3*M+0]*b;c.push(E,T,w)}}for(let v=0;v<t;v++)for(let y=0;y<e.length-1;y++){const S=y+v*e.length,b=S,M=S+e.length,E=S+e.length+1,T=S+1;s.push(b,M,T),s.push(E,T,M)}this.setIndex(s),this.setAttribute("position",new je(o,3)),this.setAttribute("uv",new je(a,2)),this.setAttribute("normal",new je(c,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new po(e.points,e.segments,e.phiStart,e.phiLength)}}class wa extends po{constructor(e=1,t=1,n=4,i=8){const s=new aa;s.absarc(0,-t/2,e,Math.PI*1.5,0),s.absarc(0,t/2,e,0,Math.PI*.5),super(s.getPoints(n),i),this.type="CapsuleGeometry",this.parameters={radius:e,height:t,capSegments:n,radialSegments:i}}static fromJSON(e){return new wa(e.radius,e.length,e.capSegments,e.radialSegments)}}class Ma extends ht{constructor(e=1,t=32,n=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:t,thetaStart:n,thetaLength:i},t=Math.max(3,t);const s=[],o=[],a=[],l=[],c=new F,h=new Te;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let u=0,d=3;u<=t;u++,d+=3){const f=n+u/t*i;c.x=e*Math.cos(f),c.y=e*Math.sin(f),o.push(c.x,c.y,c.z),a.push(0,0,1),h.x=(o[d]/e+1)/2,h.y=(o[d+1]/e+1)/2,l.push(h.x,h.y)}for(let u=1;u<=t;u++)s.push(u,u+1,0);this.setIndex(s),this.setAttribute("position",new je(o,3)),this.setAttribute("normal",new je(a,3)),this.setAttribute("uv",new je(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ma(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class nr extends ht{constructor(e=1,t=1,n=1,i=32,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;i=Math.floor(i),s=Math.floor(s);const h=[],u=[],d=[],f=[];let p=0;const _=[],g=n/2;let m=0;v(),o===!1&&(e>0&&y(!0),t>0&&y(!1)),this.setIndex(h),this.setAttribute("position",new je(u,3)),this.setAttribute("normal",new je(d,3)),this.setAttribute("uv",new je(f,2));function v(){const S=new F,b=new F;let M=0;const E=(t-e)/n;for(let T=0;T<=s;T++){const w=[],A=T/s,D=A*(t-e)+e;for(let k=0;k<=i;k++){const G=k/i,P=G*l+a,N=Math.sin(P),B=Math.cos(P);b.x=D*N,b.y=-A*n+g,b.z=D*B,u.push(b.x,b.y,b.z),S.set(N,E,B).normalize(),d.push(S.x,S.y,S.z),f.push(G,1-A),w.push(p++)}_.push(w)}for(let T=0;T<i;T++)for(let w=0;w<s;w++){const A=_[w][T],D=_[w+1][T],k=_[w+1][T+1],G=_[w][T+1];h.push(A,D,G),h.push(D,k,G),M+=6}c.addGroup(m,M,0),m+=M}function y(S){const b=p,M=new Te,E=new F;let T=0;const w=S===!0?e:t,A=S===!0?1:-1;for(let k=1;k<=i;k++)u.push(0,g*A,0),d.push(0,A,0),f.push(.5,.5),p++;const D=p;for(let k=0;k<=i;k++){const P=k/i*l+a,N=Math.cos(P),B=Math.sin(P);E.x=w*B,E.y=g*A,E.z=w*N,u.push(E.x,E.y,E.z),d.push(0,A,0),M.x=N*.5+.5,M.y=B*.5*A+.5,f.push(M.x,M.y),p++}for(let k=0;k<i;k++){const G=b+k,P=D+k;S===!0?h.push(P,P+1,G):h.push(P+1,P,G),T+=3}c.addGroup(m,T,S===!0?1:2),m+=T}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new nr(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Aa extends nr{constructor(e=1,t=1,n=32,i=1,s=!1,o=0,a=Math.PI*2){super(0,e,t,n,i,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:t,radialSegments:n,heightSegments:i,openEnded:s,thetaStart:o,thetaLength:a}}static fromJSON(e){return new Aa(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Hi extends ht{constructor(e=[],t=[],n=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:t,radius:n,detail:i};const s=[],o=[];a(i),c(n),h(),this.setAttribute("position",new je(s,3)),this.setAttribute("normal",new je(s.slice(),3)),this.setAttribute("uv",new je(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(v){const y=new F,S=new F,b=new F;for(let M=0;M<t.length;M+=3)f(t[M+0],y),f(t[M+1],S),f(t[M+2],b),l(y,S,b,v)}function l(v,y,S,b){const M=b+1,E=[];for(let T=0;T<=M;T++){E[T]=[];const w=v.clone().lerp(S,T/M),A=y.clone().lerp(S,T/M),D=M-T;for(let k=0;k<=D;k++)k===0&&T===M?E[T][k]=w:E[T][k]=w.clone().lerp(A,k/D)}for(let T=0;T<M;T++)for(let w=0;w<2*(M-T)-1;w++){const A=Math.floor(w/2);w%2===0?(d(E[T][A+1]),d(E[T+1][A]),d(E[T][A])):(d(E[T][A+1]),d(E[T+1][A+1]),d(E[T+1][A]))}}function c(v){const y=new F;for(let S=0;S<s.length;S+=3)y.x=s[S+0],y.y=s[S+1],y.z=s[S+2],y.normalize().multiplyScalar(v),s[S+0]=y.x,s[S+1]=y.y,s[S+2]=y.z}function h(){const v=new F;for(let y=0;y<s.length;y+=3){v.x=s[y+0],v.y=s[y+1],v.z=s[y+2];const S=g(v)/2/Math.PI+.5,b=m(v)/Math.PI+.5;o.push(S,1-b)}p(),u()}function u(){for(let v=0;v<o.length;v+=6){const y=o[v+0],S=o[v+2],b=o[v+4],M=Math.max(y,S,b),E=Math.min(y,S,b);M>.9&&E<.1&&(y<.2&&(o[v+0]+=1),S<.2&&(o[v+2]+=1),b<.2&&(o[v+4]+=1))}}function d(v){s.push(v.x,v.y,v.z)}function f(v,y){const S=v*3;y.x=e[S+0],y.y=e[S+1],y.z=e[S+2]}function p(){const v=new F,y=new F,S=new F,b=new F,M=new Te,E=new Te,T=new Te;for(let w=0,A=0;w<s.length;w+=9,A+=6){v.set(s[w+0],s[w+1],s[w+2]),y.set(s[w+3],s[w+4],s[w+5]),S.set(s[w+6],s[w+7],s[w+8]),M.set(o[A+0],o[A+1]),E.set(o[A+2],o[A+3]),T.set(o[A+4],o[A+5]),b.copy(v).add(y).add(S).divideScalar(3);const D=g(b);_(M,A+0,v,D),_(E,A+2,y,D),_(T,A+4,S,D)}}function _(v,y,S,b){b<0&&v.x===1&&(o[y]=v.x-1),S.x===0&&S.z===0&&(o[y]=b/2/Math.PI+.5)}function g(v){return Math.atan2(v.z,-v.x)}function m(v){return Math.atan2(-v.y,Math.sqrt(v.x*v.x+v.z*v.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Hi(e.vertices,e.indices,e.radius,e.details)}}class Ea extends Hi{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=1/n,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-n,0,-i,n,0,i,-n,0,i,n,-i,-n,0,-i,n,0,i,-n,0,i,n,0,-n,0,-i,n,0,-i,-n,0,i,n,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,t),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ea(e.radius,e.detail)}}const Ml=new F,Al=new F,tu=new F,El=new Ws;class k1 extends ht{constructor(e=null,t=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:t},e!==null){const i=Math.pow(10,4),s=Math.cos(Ys*t),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],h=["a","b","c"],u=new Array(3),d={},f=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:_,b:g,c:m}=El;if(_.fromBufferAttribute(a,c[0]),g.fromBufferAttribute(a,c[1]),m.fromBufferAttribute(a,c[2]),El.getNormal(tu),u[0]=`${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`,u[1]=`${Math.round(g.x*i)},${Math.round(g.y*i)},${Math.round(g.z*i)}`,u[2]=`${Math.round(m.x*i)},${Math.round(m.y*i)},${Math.round(m.z*i)}`,!(u[0]===u[1]||u[1]===u[2]||u[2]===u[0]))for(let v=0;v<3;v++){const y=(v+1)%3,S=u[v],b=u[y],M=El[h[v]],E=El[h[y]],T=`${S}_${b}`,w=`${b}_${S}`;w in d&&d[w]?(tu.dot(d[w].normal)<=s&&(f.push(M.x,M.y,M.z),f.push(E.x,E.y,E.z)),d[w]=null):T in d||(d[T]={index0:c[v],index1:c[y],normal:tu.clone()})}}for(const p in d)if(d[p]){const{index0:_,index1:g}=d[p];Ml.fromBufferAttribute(a,_),Al.fromBufferAttribute(a,g),f.push(Ml.x,Ml.y,Ml.z),f.push(Al.x,Al.y,Al.z)}this.setAttribute("position",new je(f,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class qs extends aa{constructor(e){super(e),this.uuid=In(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new aa().fromJSON(i))}return this}}const gA={triangulate:function(r,e,t=2){const n=e&&e.length,i=n?e[0]*t:r.length;let s=G1(r,0,i,t,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,h,u,d,f;if(n&&(s=SA(r,e,s,t)),r.length>80*t){a=c=r[0],l=h=r[1];for(let p=t;p<i;p+=t)u=r[p],d=r[p+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);f=Math.max(c-a,h-l),f=f!==0?32767/f:0}return la(s,o,t,a,l,f,0),o}};function G1(r,e,t,n,i){let s,o;if(i===LA(r,e,t,n)>0)for(s=e;s<t;s+=n)o=Am(s,r[s],r[s+1],o);else for(s=t-n;s>=e;s-=n)o=Am(s,r[s],r[s+1],o);return o&&Xc(o,o.next)&&(ha(o),o=o.next),o}function Ks(r,e){if(!r)return r;e||(e=r);let t=r,n;do if(n=!1,!t.steiner&&(Xc(t,t.next)||At(t.prev,t,t.next)===0)){if(ha(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function la(r,e,t,n,i,s,o){if(!r)return;!o&&s&&EA(r,n,i,s);let a=r,l,c;for(;r.prev!==r.next;){if(l=r.prev,c=r.next,s?yA(r,n,i,s):_A(r)){e.push(l.i/t|0),e.push(r.i/t|0),e.push(c.i/t|0),ha(r),r=c.next,a=c.next;continue}if(r=c,r===a){o?o===1?(r=xA(Ks(r),e,t),la(r,e,t,n,i,s,2)):o===2&&vA(r,e,t,n,i,s):la(Ks(r),e,t,n,i,s,1);break}}}function _A(r){const e=r.prev,t=r,n=r.next;if(At(e,t,n)>=0)return!1;const i=e.x,s=t.x,o=n.x,a=e.y,l=t.y,c=n.y,h=i<s?i<o?i:o:s<o?s:o,u=a<l?a<c?a:c:l<c?l:c,d=i>s?i>o?i:o:s>o?s:o,f=a>l?a>c?a:c:l>c?l:c;let p=n.next;for(;p!==e;){if(p.x>=h&&p.x<=d&&p.y>=u&&p.y<=f&&Kr(i,a,s,l,o,c,p.x,p.y)&&At(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function yA(r,e,t,n){const i=r.prev,s=r,o=r.next;if(At(i,s,o)>=0)return!1;const a=i.x,l=s.x,c=o.x,h=i.y,u=s.y,d=o.y,f=a<l?a<c?a:c:l<c?l:c,p=h<u?h<d?h:d:u<d?u:d,_=a>l?a>c?a:c:l>c?l:c,g=h>u?h>d?h:d:u>d?u:d,m=_d(f,p,e,t,n),v=_d(_,g,e,t,n);let y=r.prevZ,S=r.nextZ;for(;y&&y.z>=m&&S&&S.z<=v;){if(y.x>=f&&y.x<=_&&y.y>=p&&y.y<=g&&y!==i&&y!==o&&Kr(a,h,l,u,c,d,y.x,y.y)&&At(y.prev,y,y.next)>=0||(y=y.prevZ,S.x>=f&&S.x<=_&&S.y>=p&&S.y<=g&&S!==i&&S!==o&&Kr(a,h,l,u,c,d,S.x,S.y)&&At(S.prev,S,S.next)>=0))return!1;S=S.nextZ}for(;y&&y.z>=m;){if(y.x>=f&&y.x<=_&&y.y>=p&&y.y<=g&&y!==i&&y!==o&&Kr(a,h,l,u,c,d,y.x,y.y)&&At(y.prev,y,y.next)>=0)return!1;y=y.prevZ}for(;S&&S.z<=v;){if(S.x>=f&&S.x<=_&&S.y>=p&&S.y<=g&&S!==i&&S!==o&&Kr(a,h,l,u,c,d,S.x,S.y)&&At(S.prev,S,S.next)>=0)return!1;S=S.nextZ}return!0}function xA(r,e,t){let n=r;do{const i=n.prev,s=n.next.next;!Xc(i,s)&&H1(i,n,n.next,s)&&ca(i,s)&&ca(s,i)&&(e.push(i.i/t|0),e.push(n.i/t|0),e.push(s.i/t|0),ha(n),ha(n.next),n=r=s),n=n.next}while(n!==r);return Ks(n)}function vA(r,e,t,n,i,s){let o=r;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&RA(o,a)){let l=W1(o,a);o=Ks(o,o.next),l=Ks(l,l.next),la(o,e,t,n,i,s,0),la(l,e,t,n,i,s,0);return}a=a.next}o=o.next}while(o!==r)}function SA(r,e,t,n){const i=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*n,l=s<o-1?e[s+1]*n:r.length,c=G1(r,a,l,n,!1),c===c.next&&(c.steiner=!0),i.push(CA(c));for(i.sort(bA),s=0;s<i.length;s++)t=wA(i[s],t);return t}function bA(r,e){return r.x-e.x}function wA(r,e){const t=MA(r,e);if(!t)return e;const n=W1(t,r);return Ks(n,n.next),Ks(t,t.next)}function MA(r,e){let t=e,n=-1/0,i;const s=r.x,o=r.y;do{if(o<=t.y&&o>=t.next.y&&t.next.y!==t.y){const d=t.x+(o-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=s&&d>n&&(n=d,i=t.x<t.next.x?t:t.next,d===s))return i}t=t.next}while(t!==e);if(!i)return null;const a=i,l=i.x,c=i.y;let h=1/0,u;t=i;do s>=t.x&&t.x>=l&&s!==t.x&&Kr(o<c?s:n,o,l,c,o<c?n:s,o,t.x,t.y)&&(u=Math.abs(o-t.y)/(s-t.x),ca(t,r)&&(u<h||u===h&&(t.x>i.x||t.x===i.x&&AA(i,t)))&&(i=t,h=u)),t=t.next;while(t!==a);return i}function AA(r,e){return At(r.prev,r,e.prev)<0&&At(e.next,r,r.next)<0}function EA(r,e,t,n){let i=r;do i.z===0&&(i.z=_d(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==r);i.prevZ.nextZ=null,i.prevZ=null,TA(i)}function TA(r){let e,t,n,i,s,o,a,l,c=1;do{for(t=r,r=null,s=null,o=0;t;){for(o++,n=t,a=0,e=0;e<c&&(a++,n=n.nextZ,!!n);e++);for(l=c;a>0||l>0&&n;)a!==0&&(l===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,a--):(i=n,n=n.nextZ,l--),s?s.nextZ=i:r=i,i.prevZ=s,s=i;t=n}s.nextZ=null,c*=2}while(o>1);return r}function _d(r,e,t,n,i){return r=(r-t)*i|0,e=(e-n)*i|0,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function CA(r){let e=r,t=r;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==r);return t}function Kr(r,e,t,n,i,s,o,a){return(i-o)*(e-a)>=(r-o)*(s-a)&&(r-o)*(n-a)>=(t-o)*(e-a)&&(t-o)*(s-a)>=(i-o)*(n-a)}function RA(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!PA(r,e)&&(ca(r,e)&&ca(e,r)&&IA(r,e)&&(At(r.prev,r,e.prev)||At(r,e.prev,e))||Xc(r,e)&&At(r.prev,r,r.next)>0&&At(e.prev,e,e.next)>0)}function At(r,e,t){return(e.y-r.y)*(t.x-e.x)-(e.x-r.x)*(t.y-e.y)}function Xc(r,e){return r.x===e.x&&r.y===e.y}function H1(r,e,t,n){const i=Cl(At(r,e,t)),s=Cl(At(r,e,n)),o=Cl(At(t,n,r)),a=Cl(At(t,n,e));return!!(i!==s&&o!==a||i===0&&Tl(r,t,e)||s===0&&Tl(r,n,e)||o===0&&Tl(t,r,n)||a===0&&Tl(t,e,n))}function Tl(r,e,t){return e.x<=Math.max(r.x,t.x)&&e.x>=Math.min(r.x,t.x)&&e.y<=Math.max(r.y,t.y)&&e.y>=Math.min(r.y,t.y)}function Cl(r){return r>0?1:r<0?-1:0}function PA(r,e){let t=r;do{if(t.i!==r.i&&t.next.i!==r.i&&t.i!==e.i&&t.next.i!==e.i&&H1(t,t.next,r,e))return!0;t=t.next}while(t!==r);return!1}function ca(r,e){return At(r.prev,r,r.next)<0?At(r,e,r.next)>=0&&At(r,r.prev,e)>=0:At(r,e,r.prev)<0||At(r,r.next,e)<0}function IA(r,e){let t=r,n=!1;const i=(r.x+e.x)/2,s=(r.y+e.y)/2;do t.y>s!=t.next.y>s&&t.next.y!==t.y&&i<(t.next.x-t.x)*(s-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==r);return n}function W1(r,e){const t=new yd(r.i,r.x,r.y),n=new yd(e.i,e.x,e.y),i=r.next,s=e.prev;return r.next=e,e.prev=r,t.next=i,i.prev=t,n.next=t,t.prev=n,s.next=n,n.prev=s,n}function Am(r,e,t,n){const i=new yd(r,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function ha(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function yd(r,e,t){this.i=r,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function LA(r,e,t,n){let i=0;for(let s=e,o=t-n;s<t;s+=n)i+=(r[o]-r[s])*(r[s+1]+r[o+1]),o=s;return i}class pi{static area(e){const t=e.length;let n=0;for(let i=t-1,s=0;s<t;i=s++)n+=e[i].x*e[s].y-e[s].x*e[i].y;return n*.5}static isClockWise(e){return pi.area(e)<0}static triangulateShape(e,t){const n=[],i=[],s=[];Em(e),Tm(n,e);let o=e.length;t.forEach(Em);for(let l=0;l<t.length;l++)i.push(o),o+=t[l].length,Tm(n,t[l]);const a=gA.triangulate(n,i);for(let l=0;l<a.length;l+=3)s.push(a.slice(l,l+3));return s}}function Em(r){const e=r.length;e>2&&r[e-1].equals(r[0])&&r.pop()}function Tm(r,e){for(let t=0;t<e.length;t++)r.push(e[t].x),r.push(e[t].y)}class Ta extends ht{constructor(e=new qs([new Te(.5,.5),new Te(-.5,.5),new Te(-.5,-.5),new Te(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],s=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new je(i,3)),this.setAttribute("uv",new je(s,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,h=t.steps!==void 0?t.steps:1,u=t.depth!==void 0?t.depth:1;let d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,f=t.bevelThickness!==void 0?t.bevelThickness:.2,p=t.bevelSize!==void 0?t.bevelSize:f-.1,_=t.bevelOffset!==void 0?t.bevelOffset:0,g=t.bevelSegments!==void 0?t.bevelSegments:3;const m=t.extrudePath,v=t.UVGenerator!==void 0?t.UVGenerator:NA;let y,S=!1,b,M,E,T;m&&(y=m.getSpacedPoints(h),S=!0,d=!1,b=m.computeFrenetFrames(h,!1),M=new F,E=new F,T=new F),d||(g=0,f=0,p=0,_=0);const w=a.extractPoints(c);let A=w.shape;const D=w.holes;if(!pi.isClockWise(A)){A=A.reverse();for(let z=0,ye=D.length;z<ye;z++){const X=D[z];pi.isClockWise(X)&&(D[z]=X.reverse())}}const G=pi.triangulateShape(A,D),P=A;for(let z=0,ye=D.length;z<ye;z++){const X=D[z];A=A.concat(X)}function N(z,ye,X){return ye||console.error("THREE.ExtrudeGeometry: vec does not exist"),z.clone().addScaledVector(ye,X)}const B=A.length,H=G.length;function W(z,ye,X){let ie,ne,Ae;const Pe=z.x-ye.x,Ie=z.y-ye.y,Ge=X.x-z.x,Ye=X.y-z.y,et=Pe*Pe+Ie*Ie,U=Pe*Ye-Ie*Ge;if(Math.abs(U)>Number.EPSILON){const I=Math.sqrt(et),fe=Math.sqrt(Ge*Ge+Ye*Ye),Ce=ye.x-Ie/I,Re=ye.y+Pe/I,Ue=X.x-Ye/fe,ke=X.y+Ge/fe,C=((Ue-Ce)*Ye-(ke-Re)*Ge)/(Pe*Ye-Ie*Ge);ie=Ce+Pe*C-z.x,ne=Re+Ie*C-z.y;const R=ie*ie+ne*ne;if(R<=2)return new Te(ie,ne);Ae=Math.sqrt(R/2)}else{let I=!1;Pe>Number.EPSILON?Ge>Number.EPSILON&&(I=!0):Pe<-Number.EPSILON?Ge<-Number.EPSILON&&(I=!0):Math.sign(Ie)===Math.sign(Ye)&&(I=!0),I?(ie=-Ie,ne=Pe,Ae=Math.sqrt(et)):(ie=Pe,ne=Ie,Ae=Math.sqrt(et/2))}return new Te(ie/Ae,ne/Ae)}const $=[];for(let z=0,ye=P.length,X=ye-1,ie=z+1;z<ye;z++,X++,ie++)X===ye&&(X=0),ie===ye&&(ie=0),$[z]=W(P[z],P[X],P[ie]);const oe=[];let Se,K=$.concat();for(let z=0,ye=D.length;z<ye;z++){const X=D[z];Se=[];for(let ie=0,ne=X.length,Ae=ne-1,Pe=ie+1;ie<ne;ie++,Ae++,Pe++)Ae===ne&&(Ae=0),Pe===ne&&(Pe=0),Se[ie]=W(X[ie],X[Ae],X[Pe]);oe.push(Se),K=K.concat(Se)}for(let z=0;z<g;z++){const ye=z/g,X=f*Math.cos(ye*Math.PI/2),ie=p*Math.sin(ye*Math.PI/2)+_;for(let ne=0,Ae=P.length;ne<Ae;ne++){const Pe=N(P[ne],$[ne],ie);Ee(Pe.x,Pe.y,-X)}for(let ne=0,Ae=D.length;ne<Ae;ne++){const Pe=D[ne];Se=oe[ne];for(let Ie=0,Ge=Pe.length;Ie<Ge;Ie++){const Ye=N(Pe[Ie],Se[Ie],ie);Ee(Ye.x,Ye.y,-X)}}}const ce=p+_;for(let z=0;z<B;z++){const ye=d?N(A[z],K[z],ce):A[z];S?(E.copy(b.normals[0]).multiplyScalar(ye.x),M.copy(b.binormals[0]).multiplyScalar(ye.y),T.copy(y[0]).add(E).add(M),Ee(T.x,T.y,T.z)):Ee(ye.x,ye.y,0)}for(let z=1;z<=h;z++)for(let ye=0;ye<B;ye++){const X=d?N(A[ye],K[ye],ce):A[ye];S?(E.copy(b.normals[z]).multiplyScalar(X.x),M.copy(b.binormals[z]).multiplyScalar(X.y),T.copy(y[z]).add(E).add(M),Ee(T.x,T.y,T.z)):Ee(X.x,X.y,u/h*z)}for(let z=g-1;z>=0;z--){const ye=z/g,X=f*Math.cos(ye*Math.PI/2),ie=p*Math.sin(ye*Math.PI/2)+_;for(let ne=0,Ae=P.length;ne<Ae;ne++){const Pe=N(P[ne],$[ne],ie);Ee(Pe.x,Pe.y,u+X)}for(let ne=0,Ae=D.length;ne<Ae;ne++){const Pe=D[ne];Se=oe[ne];for(let Ie=0,Ge=Pe.length;Ie<Ge;Ie++){const Ye=N(Pe[Ie],Se[Ie],ie);S?Ee(Ye.x,Ye.y+y[h-1].y,y[h-1].x+X):Ee(Ye.x,Ye.y,u+X)}}}Z(),_e();function Z(){const z=i.length/3;if(d){let ye=0,X=B*ye;for(let ie=0;ie<H;ie++){const ne=G[ie];Ne(ne[2]+X,ne[1]+X,ne[0]+X)}ye=h+g*2,X=B*ye;for(let ie=0;ie<H;ie++){const ne=G[ie];Ne(ne[0]+X,ne[1]+X,ne[2]+X)}}else{for(let ye=0;ye<H;ye++){const X=G[ye];Ne(X[2],X[1],X[0])}for(let ye=0;ye<H;ye++){const X=G[ye];Ne(X[0]+B*h,X[1]+B*h,X[2]+B*h)}}n.addGroup(z,i.length/3-z,0)}function _e(){const z=i.length/3;let ye=0;xe(P,ye),ye+=P.length;for(let X=0,ie=D.length;X<ie;X++){const ne=D[X];xe(ne,ye),ye+=ne.length}n.addGroup(z,i.length/3-z,1)}function xe(z,ye){let X=z.length;for(;--X>=0;){const ie=X;let ne=X-1;ne<0&&(ne=z.length-1);for(let Ae=0,Pe=h+g*2;Ae<Pe;Ae++){const Ie=B*Ae,Ge=B*(Ae+1),Ye=ye+ie+Ie,et=ye+ne+Ie,U=ye+ne+Ge,I=ye+ie+Ge;Oe(Ye,et,U,I)}}}function Ee(z,ye,X){l.push(z),l.push(ye),l.push(X)}function Ne(z,ye,X){Ve(z),Ve(ye),Ve(X);const ie=i.length/3,ne=v.generateTopUV(n,i,ie-3,ie-2,ie-1);De(ne[0]),De(ne[1]),De(ne[2])}function Oe(z,ye,X,ie){Ve(z),Ve(ye),Ve(ie),Ve(ye),Ve(X),Ve(ie);const ne=i.length/3,Ae=v.generateSideWallUV(n,i,ne-6,ne-3,ne-2,ne-1);De(Ae[0]),De(Ae[1]),De(Ae[3]),De(Ae[1]),De(Ae[2]),De(Ae[3])}function Ve(z){i.push(l[z*3+0]),i.push(l[z*3+1]),i.push(l[z*3+2])}function De(z){s.push(z.x),s.push(z.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return OA(t,n,e)}static fromJSON(e,t){const n=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=t[e.shapes[s]];n.push(a)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new hf[i.type]().fromJSON(i)),new Ta(n,e.options)}}const NA={generateTopUV:function(r,e,t,n,i){const s=e[t*3],o=e[t*3+1],a=e[n*3],l=e[n*3+1],c=e[i*3],h=e[i*3+1];return[new Te(s,o),new Te(a,l),new Te(c,h)]},generateSideWallUV:function(r,e,t,n,i,s){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[n*3],h=e[n*3+1],u=e[n*3+2],d=e[i*3],f=e[i*3+1],p=e[i*3+2],_=e[s*3],g=e[s*3+1],m=e[s*3+2];return Math.abs(a-h)<Math.abs(o-c)?[new Te(o,1-l),new Te(c,1-u),new Te(d,1-p),new Te(_,1-m)]:[new Te(a,1-l),new Te(h,1-u),new Te(f,1-p),new Te(g,1-m)]}};function OA(r,e,t){if(t.shapes=[],Array.isArray(r))for(let n=0,i=r.length;n<i;n++){const s=r[n];t.shapes.push(s.uuid)}else t.shapes.push(r.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Ca extends Hi{constructor(e=1,t=0){const n=(1+Math.sqrt(5))/2,i=[-1,n,0,1,n,0,-1,-n,0,1,-n,0,0,-1,n,0,1,n,0,-1,-n,0,1,-n,n,0,-1,n,0,1,-n,0,-1,-n,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,s,e,t),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ca(e.radius,e.detail)}}class mo extends Hi{constructor(e=1,t=0){const n=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(n,i,e,t),this.type="OctahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new mo(e.radius,e.detail)}}class Ra extends ht{constructor(e=.5,t=1,n=32,i=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:t,thetaSegments:n,phiSegments:i,thetaStart:s,thetaLength:o},n=Math.max(3,n),i=Math.max(1,i);const a=[],l=[],c=[],h=[];let u=e;const d=(t-e)/i,f=new F,p=new Te;for(let _=0;_<=i;_++){for(let g=0;g<=n;g++){const m=s+g/n*o;f.x=u*Math.cos(m),f.y=u*Math.sin(m),l.push(f.x,f.y,f.z),c.push(0,0,1),p.x=(f.x/t+1)/2,p.y=(f.y/t+1)/2,h.push(p.x,p.y)}u+=d}for(let _=0;_<i;_++){const g=_*(n+1);for(let m=0;m<n;m++){const v=m+g,y=v,S=v+n+1,b=v+n+2,M=v+1;a.push(y,S,M),a.push(S,b,M)}}this.setIndex(a),this.setAttribute("position",new je(l,3)),this.setAttribute("normal",new je(c,3)),this.setAttribute("uv",new je(h,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Ra(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class Pa extends ht{constructor(e=new qs([new Te(0,.5),new Te(-.5,-.5),new Te(.5,-.5)]),t=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],i=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let h=0;h<e.length;h++)c(e[h]),this.addGroup(a,l,h),a+=l,l=0;this.setIndex(n),this.setAttribute("position",new je(i,3)),this.setAttribute("normal",new je(s,3)),this.setAttribute("uv",new je(o,2));function c(h){const u=i.length/3,d=h.extractPoints(t);let f=d.shape;const p=d.holes;pi.isClockWise(f)===!1&&(f=f.reverse());for(let g=0,m=p.length;g<m;g++){const v=p[g];pi.isClockWise(v)===!0&&(p[g]=v.reverse())}const _=pi.triangulateShape(f,p);for(let g=0,m=p.length;g<m;g++){const v=p[g];f=f.concat(v)}for(let g=0,m=f.length;g<m;g++){const v=f[g];i.push(v.x,v.y,0),s.push(0,0,1),o.push(v.x,v.y)}for(let g=0,m=_.length;g<m;g++){const v=_[g],y=v[0]+u,S=v[1]+u,b=v[2]+u;n.push(y,S,b),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return DA(t,e)}static fromJSON(e,t){const n=[];for(let i=0,s=e.shapes.length;i<s;i++){const o=t[e.shapes[i]];n.push(o)}return new Pa(n,e.curveSegments)}}function DA(r,e){if(e.shapes=[],Array.isArray(r))for(let t=0,n=r.length;t<n;t++){const i=r[t];e.shapes.push(i.uuid)}else e.shapes.push(r.uuid);return e}class go extends ht{constructor(e=1,t=32,n=16,i=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:t,heightSegments:n,phiStart:i,phiLength:s,thetaStart:o,thetaLength:a},t=Math.max(3,Math.floor(t)),n=Math.max(2,Math.floor(n));const l=Math.min(o+a,Math.PI);let c=0;const h=[],u=new F,d=new F,f=[],p=[],_=[],g=[];for(let m=0;m<=n;m++){const v=[],y=m/n;let S=0;m===0&&o===0?S=.5/t:m===n&&l===Math.PI&&(S=-.5/t);for(let b=0;b<=t;b++){const M=b/t;u.x=-e*Math.cos(i+M*s)*Math.sin(o+y*a),u.y=e*Math.cos(o+y*a),u.z=e*Math.sin(i+M*s)*Math.sin(o+y*a),p.push(u.x,u.y,u.z),d.copy(u).normalize(),_.push(d.x,d.y,d.z),g.push(M+S,1-y),v.push(c++)}h.push(v)}for(let m=0;m<n;m++)for(let v=0;v<t;v++){const y=h[m][v+1],S=h[m][v],b=h[m+1][v],M=h[m+1][v+1];(m!==0||o>0)&&f.push(y,S,M),(m!==n-1||l<Math.PI)&&f.push(S,b,M)}this.setIndex(f),this.setAttribute("position",new je(p,3)),this.setAttribute("normal",new je(_,3)),this.setAttribute("uv",new je(g,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new go(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class Ia extends Hi{constructor(e=1,t=0){const n=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(n,i,e,t),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:t}}static fromJSON(e){return new Ia(e.radius,e.detail)}}class La extends ht{constructor(e=1,t=.4,n=12,i=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:t,radialSegments:n,tubularSegments:i,arc:s},n=Math.floor(n),i=Math.floor(i);const o=[],a=[],l=[],c=[],h=new F,u=new F,d=new F;for(let f=0;f<=n;f++)for(let p=0;p<=i;p++){const _=p/i*s,g=f/n*Math.PI*2;u.x=(e+t*Math.cos(g))*Math.cos(_),u.y=(e+t*Math.cos(g))*Math.sin(_),u.z=t*Math.sin(g),a.push(u.x,u.y,u.z),h.x=e*Math.cos(_),h.y=e*Math.sin(_),d.subVectors(u,h).normalize(),l.push(d.x,d.y,d.z),c.push(p/i),c.push(f/n)}for(let f=1;f<=n;f++)for(let p=1;p<=i;p++){const _=(i+1)*f+p-1,g=(i+1)*(f-1)+p-1,m=(i+1)*(f-1)+p,v=(i+1)*f+p;o.push(_,g,v),o.push(g,m,v)}this.setIndex(o),this.setAttribute("position",new je(a,3)),this.setAttribute("normal",new je(l,3)),this.setAttribute("uv",new je(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new La(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class Na extends ht{constructor(e=1,t=.4,n=64,i=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:t,tubularSegments:n,radialSegments:i,p:s,q:o},n=Math.floor(n),i=Math.floor(i);const a=[],l=[],c=[],h=[],u=new F,d=new F,f=new F,p=new F,_=new F,g=new F,m=new F;for(let y=0;y<=n;++y){const S=y/n*s*Math.PI*2;v(S,s,o,e,f),v(S+.01,s,o,e,p),g.subVectors(p,f),m.addVectors(p,f),_.crossVectors(g,m),m.crossVectors(_,g),_.normalize(),m.normalize();for(let b=0;b<=i;++b){const M=b/i*Math.PI*2,E=-t*Math.cos(M),T=t*Math.sin(M);u.x=f.x+(E*m.x+T*_.x),u.y=f.y+(E*m.y+T*_.y),u.z=f.z+(E*m.z+T*_.z),l.push(u.x,u.y,u.z),d.subVectors(u,f).normalize(),c.push(d.x,d.y,d.z),h.push(y/n),h.push(b/i)}}for(let y=1;y<=n;y++)for(let S=1;S<=i;S++){const b=(i+1)*(y-1)+(S-1),M=(i+1)*y+(S-1),E=(i+1)*y+S,T=(i+1)*(y-1)+S;a.push(b,M,T),a.push(M,E,T)}this.setIndex(a),this.setAttribute("position",new je(l,3)),this.setAttribute("normal",new je(c,3)),this.setAttribute("uv",new je(h,2));function v(y,S,b,M,E){const T=Math.cos(y),w=Math.sin(y),A=b/S*y,D=Math.cos(A);E.x=M*(2+D)*.5*T,E.y=M*(2+D)*w*.5,E.z=M*Math.sin(A)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Na(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class Oa extends ht{constructor(e=new lf(new F(-1,-1,0),new F(-1,1,0),new F(1,1,0)),t=64,n=1,i=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:t,radius:n,radialSegments:i,closed:s};const o=e.computeFrenetFrames(t,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new F,l=new F,c=new Te;let h=new F;const u=[],d=[],f=[],p=[];_(),this.setIndex(p),this.setAttribute("position",new je(u,3)),this.setAttribute("normal",new je(d,3)),this.setAttribute("uv",new je(f,2));function _(){for(let y=0;y<t;y++)g(y);g(s===!1?t:0),v(),m()}function g(y){h=e.getPointAt(y/t,h);const S=o.normals[y],b=o.binormals[y];for(let M=0;M<=i;M++){const E=M/i*Math.PI*2,T=Math.sin(E),w=-Math.cos(E);l.x=w*S.x+T*b.x,l.y=w*S.y+T*b.y,l.z=w*S.z+T*b.z,l.normalize(),d.push(l.x,l.y,l.z),a.x=h.x+n*l.x,a.y=h.y+n*l.y,a.z=h.z+n*l.z,u.push(a.x,a.y,a.z)}}function m(){for(let y=1;y<=t;y++)for(let S=1;S<=i;S++){const b=(i+1)*(y-1)+(S-1),M=(i+1)*y+(S-1),E=(i+1)*y+S,T=(i+1)*(y-1)+S;p.push(b,M,T),p.push(M,E,T)}}function v(){for(let y=0;y<=t;y++)for(let S=0;S<=i;S++)c.x=y/t,c.y=S/i,f.push(c.x,c.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new Oa(new hf[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class X1 extends ht{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const t=[],n=new Set,i=new F,s=new F;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,h=l.length;c<h;++c){const u=l[c],d=u.start,f=u.count;for(let p=d,_=d+f;p<_;p+=3)for(let g=0;g<3;g++){const m=a.getX(p+g),v=a.getX(p+(g+1)%3);i.fromBufferAttribute(o,m),s.fromBufferAttribute(o,v),Cm(i,s,n)===!0&&(t.push(i.x,i.y,i.z),t.push(s.x,s.y,s.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const h=3*a+c,u=3*a+(c+1)%3;i.fromBufferAttribute(o,h),s.fromBufferAttribute(o,u),Cm(i,s,n)===!0&&(t.push(i.x,i.y,i.z),t.push(s.x,s.y,s.z))}}this.setAttribute("position",new je(t,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function Cm(r,e,t){const n=`${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;return t.has(n)===!0||t.has(i)===!0?!1:(t.add(n),t.add(i),!0)}var Rm=Object.freeze({__proto__:null,BoxGeometry:xs,CapsuleGeometry:wa,CircleGeometry:Ma,ConeGeometry:Aa,CylinderGeometry:nr,DodecahedronGeometry:Ea,EdgesGeometry:k1,ExtrudeGeometry:Ta,IcosahedronGeometry:Ca,LatheGeometry:po,OctahedronGeometry:mo,PlaneGeometry:uo,PolyhedronGeometry:Hi,RingGeometry:Ra,ShapeGeometry:Pa,SphereGeometry:go,TetrahedronGeometry:Ia,TorusGeometry:La,TorusKnotGeometry:Na,TubeGeometry:Oa,WireframeGeometry:X1});class j1 extends tn{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new He(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Y1 extends gi{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class uf extends tn{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new He(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new He(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=_s,this.normalScale=new Te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class q1 extends uf{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Te(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Ct(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new He(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new He(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new He(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class $1 extends tn{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new He(16777215),this.specular=new He(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new He(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=_s,this.normalScale=new Te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=va,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Z1 extends tn{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new He(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new He(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=_s,this.normalScale=new Te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class K1 extends tn{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=_s,this.normalScale=new Te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class J1 extends tn{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new He(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new He(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=_s,this.normalScale=new Te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=va,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Q1 extends tn{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new He(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=_s,this.normalScale=new Te(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class e0 extends un{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Bn(r,e,t){return df(r)?new r.constructor(r.subarray(e,t!==void 0?t:r.length)):r.slice(e,t)}function Xs(r,e,t){return!r||!t&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)}function df(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)}function t0(r){function e(i,s){return r[i]-r[s]}const t=r.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n}function xd(r,e,t){const n=r.length,i=new r.constructor(n);for(let s=0,o=0;o!==n;++s){const a=t[s]*e;for(let l=0;l!==e;++l)i[o++]=r[a+l]}return i}function ff(r,e,t,n){let i=1,s=r[0];for(;s!==void 0&&s[n]===void 0;)s=r[i++];if(s===void 0)return;let o=s[n];if(o!==void 0)if(Array.isArray(o))do o=s[n],o!==void 0&&(e.push(s.time),t.push.apply(t,o)),s=r[i++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[n],o!==void 0&&(e.push(s.time),o.toArray(t,t.length)),s=r[i++];while(s!==void 0);else do o=s[n],o!==void 0&&(e.push(s.time),t.push(o)),s=r[i++];while(s!==void 0)}function UA(r,e,t,n,i=30){const s=r.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],h=c.getValueSize(),u=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*i;if(!(p<t||p>=n)){u.push(c.times[f]);for(let _=0;_<h;++_)d.push(c.values[f*h+_])}}u.length!==0&&(c.times=Xs(u,c.times.constructor),c.values=Xs(d,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s}function FA(r,e=0,t=r,n=30){n<=0&&(n=30);const i=t.tracks.length,s=e/n;for(let o=0;o<i;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=r.tracks.find(function(m){return m.name===a.name&&m.ValueTypeName===l});if(c===void 0)continue;let h=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=u/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=a.times.length-1;let _;if(s<=a.times[0]){const m=h,v=u-h;_=Bn(a.values,m,v)}else if(s>=a.times[p]){const m=p*u+h,v=m+u-h;_=Bn(a.values,m,v)}else{const m=a.createInterpolant(),v=h,y=u-h;m.evaluate(s),_=Bn(m.resultBuffer,v,y)}l==="quaternion"&&new yn().fromArray(_).normalize().conjugate().toArray(_);const g=c.times.length;for(let m=0;m<g;++m){const v=m*f+d;if(l==="quaternion")yn.multiplyQuaternionsFlat(c.values,v,_,0,c.values,v);else{const y=f-d*2;for(let S=0;S<y;++S)c.values[v+S]-=_[S]}}}return r.blendMode=Hd,r}const zA={arraySlice:Bn,convertArray:Xs,isTypedArray:df,getKeyframeOrder:t0,sortedArray:xd,flattenJSON:ff,subclip:UA,makeClipAdditive:FA};class Da{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],s=t[n-1];e:{t:{let o;n:{i:if(!(e<i)){for(let a=n+2;;){if(i===void 0){if(e<s)break i;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===a)break;if(s=i,i=t[++n],e<i)break t}o=t.length;break n}if(!(e>=s)){const a=t[1];e<a&&(n=2,s=a);for(let l=n-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===l)break;if(i=s,s=t[--n-1],e>=s)break t}o=n,n=0;break n}break e}for(;n<o;){const a=n+o>>>1;e<t[a]?o=a:n=a+1}if(i=t[n],s=t[n-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,s,i)}return this.interpolate_(n,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=e*i;for(let o=0;o!==i;++o)t[o]=n[s+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class n0 extends Da{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ks,endingEnd:ks}}intervalChanged_(e,t,n){const i=this.parameterPositions;let s=e-2,o=e+1,a=i[s],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case Gs:s=e,a=2*t-n;break;case ia:s=i.length-2,a=t+i[s]-i[s+1];break;default:s=e,a=n}if(l===void 0)switch(this.getSettings_().endingEnd){case Gs:o=e,l=2*n-t;break;case ia:o=1,l=n+i[1]-i[0];break;default:o=e-1,l=t}const c=(n-t)*.5,h=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-n),this._offsetPrev=s*h,this._offsetNext=o*h}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,h=this._offsetPrev,u=this._offsetNext,d=this._weightPrev,f=this._weightNext,p=(n-t)/(i-t),_=p*p,g=_*p,m=-d*g+2*d*_-d*p,v=(1+d)*g+(-1.5-2*d)*_+(-.5+d)*p+1,y=(-1-f)*g+(1.5+f)*_+.5*p,S=f*g-f*_;for(let b=0;b!==a;++b)s[b]=m*o[h+b]+v*o[c+b]+y*o[l+b]+S*o[u+b];return s}}class pf extends Da{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,h=(n-t)/(i-t),u=1-h;for(let d=0;d!==a;++d)s[d]=o[c+d]*u+o[l+d]*h;return s}}class i0 extends Da{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class si{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Xs(t,this.TimeBufferType),this.values=Xs(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Xs(e.times,Array),values:Xs(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new i0(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new pf(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new n0(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case ta:t=this.InterpolantFactoryMethodDiscrete;break;case na:t=this.InterpolantFactoryMethodLinear;break;case hc:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ta;case this.InterpolantFactoryMethodLinear:return na;case this.InterpolantFactoryMethodSmooth:return hc}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let s=0,o=i-1;for(;s!==i&&n[s]<e;)++s;for(;o!==-1&&n[o]>t;)--o;if(++o,s!==0||o!==i){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=Bn(n,s,o),this.values=Bn(this.values,s*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,s=n.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const l=n[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(i!==void 0&&df(i))for(let a=0,l=i.length;a!==l;++a){const c=i[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=Bn(this.times),t=Bn(this.values),n=this.getValueSize(),i=this.getInterpolation()===hc,s=e.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const c=e[a],h=e[a+1];if(c!==h&&(a!==1||c!==e[0]))if(i)l=!0;else{const u=a*n,d=u-n,f=u+n;for(let p=0;p!==n;++p){const _=t[u+p];if(_!==t[d+p]||_!==t[f+p]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const u=a*n,d=o*n;for(let f=0;f!==n;++f)t[d+f]=t[u+f]}++o}}if(s>0){e[o]=e[s];for(let a=s*n,l=o*n,c=0;c!==n;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=Bn(e,0,o),this.values=Bn(t,0,o*n)):(this.times=e,this.values=t),this}clone(){const e=Bn(this.times,0),t=Bn(this.values,0),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}si.prototype.TimeBufferType=Float32Array;si.prototype.ValueBufferType=Float32Array;si.prototype.DefaultInterpolation=na;class ir extends si{}ir.prototype.ValueTypeName="bool";ir.prototype.ValueBufferType=Array;ir.prototype.DefaultInterpolation=ta;ir.prototype.InterpolantFactoryMethodLinear=void 0;ir.prototype.InterpolantFactoryMethodSmooth=void 0;class mf extends si{}mf.prototype.ValueTypeName="color";class ua extends si{}ua.prototype.ValueTypeName="number";class s0 extends Da{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(n-t)/(i-t);let c=e*a;for(let h=c+a;c!==h;c+=4)yn.slerpFlat(s,0,o,c-a,o,c,l);return s}}class _o extends si{InterpolantFactoryMethodLinear(e){return new s0(this.times,this.values,this.getValueSize(),e)}}_o.prototype.ValueTypeName="quaternion";_o.prototype.DefaultInterpolation=na;_o.prototype.InterpolantFactoryMethodSmooth=void 0;class sr extends si{}sr.prototype.ValueTypeName="string";sr.prototype.ValueBufferType=Array;sr.prototype.DefaultInterpolation=ta;sr.prototype.InterpolantFactoryMethodLinear=void 0;sr.prototype.InterpolantFactoryMethodSmooth=void 0;class da extends si{}da.prototype.ValueTypeName="vector";class fa{constructor(e,t=-1,n,i=Lc){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=In(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let o=0,a=n.length;o!==a;++o)t.push(BA(n[o]).scale(i));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=n.length;s!==o;++s)t.push(si.toJSON(n[s]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const s=t.length,o=[];for(let a=0;a<s;a++){let l=[],c=[];l.push((a+s-1)%s,a,(a+1)%s),c.push(0,1,0);const h=t0(l);l=xd(l,1,h),c=xd(c,1,h),!i&&l[0]===0&&(l.push(s),c.push(c[0])),o.push(new ua(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/n))}return new this(e,-1,o)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],h=c.name.match(s);if(h&&h.length>1){const u=h[1];let d=i[u];d||(i[u]=d=[]),d.push(c)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],t,n));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(u,d,f,p,_){if(f.length!==0){const g=[],m=[];ff(f,g,m,p),g.length!==0&&_.push(new u(d,g,m))}},i=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let u=0;u<c.length;u++){const d=c[u].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let _=0;_<d[p].morphTargets.length;_++)f[d[p].morphTargets[_]]=-1;for(const _ in f){const g=[],m=[];for(let v=0;v!==d[p].morphTargets.length;++v){const y=d[p];g.push(y.time),m.push(y.morphTarget===_?1:0)}i.push(new ua(".morphTargetInfluence["+_+"]",g,m))}l=f.length*o}else{const f=".bones["+t[u].name+"]";n(da,f+".position",d,"pos",i),n(_o,f+".quaternion",d,"rot",i),n(da,f+".scale",d,"scl",i)}}return i.length===0?null:new this(s,l,i,a)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const s=this.tracks[n];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function VA(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return ua;case"vector":case"vector2":case"vector3":case"vector4":return da;case"color":return mf;case"quaternion":return _o;case"bool":case"boolean":return ir;case"string":return sr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function BA(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=VA(r.type);if(r.times===void 0){const t=[],n=[];ff(r.keys,t,n,"value"),r.times=t,r.values=n}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const Js={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class gf{constructor(e,t,n){const i=this;let s=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(h){a++,s===!1&&i.onStart!==void 0&&i.onStart(h,o,a),s=!0},this.itemEnd=function(h){o++,i.onProgress!==void 0&&i.onProgress(h,o,a),o===a&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(h){i.onError!==void 0&&i.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,u){return c.push(h,u),this},this.removeHandler=function(h){const u=c.indexOf(h);return u!==-1&&c.splice(u,2),this},this.getHandler=function(h){for(let u=0,d=c.length;u<d;u+=2){const f=c[u],p=c[u+1];if(f.global&&(f.lastIndex=0),f.test(h))return p}return null}}}const r0=new gf;let On=class{constructor(e){this.manager=e!==void 0?e:r0,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,s){n.load(e,i,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}};const Ti={};class kA extends Error{constructor(e,t){super(e),this.response=t}}let zi=class extends On{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=Js.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(Ti[e]!==void 0){Ti[e].push({onLoad:t,onProgress:n,onError:i});return}Ti[e]=[],Ti[e].push({onLoad:t,onProgress:n,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const h=Ti[e],u=c.body.getReader(),d=c.headers.get("Content-Length")||c.headers.get("X-File-Size"),f=d?parseInt(d):0,p=f!==0;let _=0;const g=new ReadableStream({start(m){v();function v(){u.read().then(({done:y,value:S})=>{if(y)m.close();else{_+=S.byteLength;const b=new ProgressEvent("progress",{lengthComputable:p,loaded:_,total:f});for(let M=0,E=h.length;M<E;M++){const T=h[M];T.onProgress&&T.onProgress(b)}m.enqueue(S),v()}})}}});return new Response(g)}else throw new kA(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(h=>new DOMParser().parseFromString(h,a));case"json":return c.json();default:if(a===void 0)return c.text();{const u=/charset="?([^;"\s]*)"?/i.exec(a),d=u&&u[1]?u[1].toLowerCase():void 0,f=new TextDecoder(d);return c.arrayBuffer().then(p=>f.decode(p))}}}).then(c=>{Js.add(e,c);const h=Ti[e];delete Ti[e];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onLoad&&f.onLoad(c)}}).catch(c=>{const h=Ti[e];if(h===void 0)throw this.manager.itemError(e),c;delete Ti[e];for(let u=0,d=h.length;u<d;u++){const f=h[u];f.onError&&f.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}};class GA extends On{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new zi(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},n,i)}parse(e){const t=[];for(let n=0;n<e.length;n++){const i=fa.parse(e[n]);t.push(i)}return t}}class HA extends On{constructor(e){super(e)}load(e,t,n,i){const s=this,o=[],a=new sf,l=new zi(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(s.withCredentials);let c=0;function h(u){l.load(e[u],function(d){const f=s.parse(d,!0);o[u]={width:f.width,height:f.height,format:f.format,mipmaps:f.mipmaps},c+=1,c===6&&(f.mipmapCount===1&&(a.minFilter=It),a.image=o,a.format=f.format,a.needsUpdate=!0,t&&t(a))},n,i)}if(Array.isArray(e))for(let u=0,d=e.length;u<d;++u)h(u);else l.load(e,function(u){const d=s.parse(u,!0);if(d.isCubemap){const f=d.mipmaps.length/d.mipmapCount;for(let p=0;p<f;p++){o[p]={mipmaps:[]};for(let _=0;_<d.mipmapCount;_++)o[p].mipmaps.push(d.mipmaps[p*d.mipmapCount+_]),o[p].format=d.format,o[p].width=d.width,o[p].height=d.height}a.image=o}else a.image.width=d.width,a.image.height=d.height,a.mipmaps=d.mipmaps;d.mipmapCount===1&&(a.minFilter=It),a.format=d.format,a.needsUpdate=!0,t&&t(a)},n,i);return a}}class pa extends On{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Js.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a=oa("img");function l(){h(),Js.add(e,this),t&&t(this),s.manager.itemEnd(e)}function c(u){h(),i&&i(u),s.manager.itemError(e),s.manager.itemEnd(e)}function h(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class WA extends On{constructor(e){super(e)}load(e,t,n,i){const s=new ba;s.colorSpace=ot;const o=new pa(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(h){s.images[c]=h,a++,a===6&&(s.needsUpdate=!0,t&&t(s))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return s}}class XA extends On{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new eo,a=new zi(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(s.withCredentials),a.load(e,function(l){const c=s.parse(l);c&&(c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:en,o.wrapT=c.wrapT!==void 0?c.wrapT:en,o.magFilter=c.magFilter!==void 0?c.magFilter:It,o.minFilter=c.minFilter!==void 0?c.minFilter:It,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0?o.colorSpace=c.colorSpace:c.encoding!==void 0&&(o.encoding=c.encoding),c.flipY!==void 0&&(o.flipY=c.flipY),c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=ps),c.mipmapCount===1&&(o.minFilter=It),c.generateMipmaps!==void 0&&(o.generateMipmaps=c.generateMipmaps),o.needsUpdate=!0,t&&t(o,c))},n,i),o}}class jA extends On{constructor(e){super(e)}load(e,t,n,i){const s=new Lt,o=new pa(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,t!==void 0&&t(s)},n,i),s}}class vs extends mt{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new He(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}class o0 extends vs{constructor(e,t,n){super(e,n),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(mt.DEFAULT_UP),this.updateMatrix(),this.groundColor=new He(t)}copy(e,t){return super.copy(e,t),this.groundColor.copy(e.groundColor),this}}const nu=new rt,Pm=new F,Im=new F;class _f{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Te(512,512),this.map=null,this.mapPass=null,this.matrix=new rt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Uc,this._frameExtents=new Te(1,1),this._viewportCount=1,this._viewports=[new _t(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;Pm.setFromMatrixPosition(e.matrixWorld),t.position.copy(Pm),Im.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(Im),t.updateMatrixWorld(),nu.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(nu),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(nu)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class YA extends _f{constructor(){super(new Yt(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=ro*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(n!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=n,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class a0 extends vs{constructor(e,t,n=0,i=Math.PI/3,s=0,o=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(mt.DEFAULT_UP),this.updateMatrix(),this.target=new mt,this.distance=n,this.angle=i,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new YA}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const Lm=new rt,Po=new F,iu=new F;class qA extends _f{constructor(){super(new Yt(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Te(4,2),this._viewportCount=6,this._viewports=[new _t(2,1,1,1),new _t(0,1,1,1),new _t(3,1,1,1),new _t(1,1,1,1),new _t(3,0,1,1),new _t(1,0,1,1)],this._cubeDirections=[new F(1,0,0),new F(-1,0,0),new F(0,0,1),new F(0,0,-1),new F(0,1,0),new F(0,-1,0)],this._cubeUps=[new F(0,1,0),new F(0,1,0),new F(0,1,0),new F(0,1,0),new F(0,0,1),new F(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,s=e.distance||n.far;s!==n.far&&(n.far=s,n.updateProjectionMatrix()),Po.setFromMatrixPosition(e.matrixWorld),n.position.copy(Po),iu.copy(n.position),iu.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(iu),n.updateMatrixWorld(),i.makeTranslation(-Po.x,-Po.y,-Po.z),Lm.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Lm)}}class l0 extends vs{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new qA}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class $A extends _f{constructor(){super(new Fc(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class c0 extends vs{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(mt.DEFAULT_UP),this.updateMatrix(),this.target=new mt,this.shadow=new $A}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class h0 extends vs{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class u0 extends vs{constructor(e,t,n=10,i=10){super(e,t),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=n,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}class d0{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new F)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,i=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*i),t.addScaledVector(o[2],.488603*s),t.addScaledVector(o[3],.488603*n),t.addScaledVector(o[4],1.092548*(n*i)),t.addScaledVector(o[5],1.092548*(i*s)),t.addScaledVector(o[6],.315392*(3*s*s-1)),t.addScaledVector(o[7],1.092548*(n*s)),t.addScaledVector(o[8],.546274*(n*n-i*i)),t}getIrradianceAt(e,t){const n=e.x,i=e.y,s=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*i),t.addScaledVector(o[2],2*.511664*s),t.addScaledVector(o[3],2*.511664*n),t.addScaledVector(o[4],2*.429043*n*i),t.addScaledVector(o[5],2*.429043*i*s),t.addScaledVector(o[6],.743125*s*s-.247708),t.addScaledVector(o[7],2*.429043*n*s),t.addScaledVector(o[8],.429043*(n*n-i*i)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].fromArray(e,t+i*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let i=0;i<9;i++)n[i].toArray(e,t+i*3);return e}static getBasisAt(e,t){const n=e.x,i=e.y,s=e.z;t[0]=.282095,t[1]=.488603*i,t[2]=.488603*s,t[3]=.488603*n,t[4]=1.092548*n*i,t[5]=1.092548*i*s,t[6]=.315392*(3*s*s-1),t[7]=1.092548*n*s,t[8]=.546274*(n*n-i*i)}}class jc extends vs{constructor(e=new d0,t=1){super(void 0,t),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}class Yc extends On{constructor(e){super(e),this.textures={}}load(e,t,n,i){const s=this,o=new zi(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},n,i)}parse(e){const t=this.textures;function n(s){return t[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),t[s]}const i=Yc.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new He().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const o=e.uniforms[s];switch(i.uniforms[s]={},o.type){case"t":i.uniforms[s].value=n(o.value);break;case"c":i.uniforms[s].value=new He().setHex(o.value);break;case"v2":i.uniforms[s].value=new Te().fromArray(o.value);break;case"v3":i.uniforms[s].value=new F().fromArray(o.value);break;case"v4":i.uniforms[s].value=new _t().fromArray(o.value);break;case"m3":i.uniforms[s].value=new lt().fromArray(o.value);break;case"m4":i.uniforms[s].value=new rt().fromArray(o.value);break;default:i.uniforms[s].value=o.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)i.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),i.normalScale=new Te().fromArray(s)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=n(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=n(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Te().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=n(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=n(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=n(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=n(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=n(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=n(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const t={ShadowMaterial:j1,SpriteMaterial:ef,RawShaderMaterial:Y1,ShaderMaterial:gi,PointsMaterial:nf,MeshPhysicalMaterial:q1,MeshStandardMaterial:uf,MeshPhongMaterial:$1,MeshToonMaterial:Z1,MeshNormalMaterial:K1,MeshLambertMaterial:J1,MeshDepthMaterial:Jd,MeshDistanceMaterial:Qd,MeshBasicMaterial:ys,MeshMatcapMaterial:Q1,LineDashedMaterial:e0,LineBasicMaterial:un,Material:tn};return new t[e]}}class vd{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class f0 extends ht{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class p0 extends On{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new zi(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{t(s.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},n,i)}parse(e){const t={},n={};function i(f,p){if(t[p]!==void 0)return t[p];const g=f.interleavedBuffers[p],m=s(f,g.buffer),v=qr(g.type,m),y=new kc(v,g.stride);return y.uuid=g.uuid,t[p]=y,y}function s(f,p){if(n[p]!==void 0)return n[p];const g=f.arrayBuffers[p],m=new Uint32Array(g).buffer;return n[p]=m,m}const o=e.isInstancedBufferGeometry?new f0:new ht,a=e.data.index;if(a!==void 0){const f=qr(a.type,a.array);o.setIndex(new vt(f,1))}const l=e.data.attributes;for(const f in l){const p=l[f];let _;if(p.isInterleavedBufferAttribute){const g=i(e.data,p.data);_=new Zs(g,p.itemSize,p.offset,p.normalized)}else{const g=qr(p.type,p.array),m=p.isInstancedBufferAttribute?ao:vt;_=new m(g,p.itemSize,p.normalized)}p.name!==void 0&&(_.name=p.name),p.usage!==void 0&&_.setUsage(p.usage),p.updateRange!==void 0&&(_.updateRange.offset=p.updateRange.offset,_.updateRange.count=p.updateRange.count),o.setAttribute(f,_)}const c=e.data.morphAttributes;if(c)for(const f in c){const p=c[f],_=[];for(let g=0,m=p.length;g<m;g++){const v=p[g];let y;if(v.isInterleavedBufferAttribute){const S=i(e.data,v.data);y=new Zs(S,v.itemSize,v.offset,v.normalized)}else{const S=qr(v.type,v.array);y=new vt(S,v.itemSize,v.normalized)}v.name!==void 0&&(y.name=v.name),_.push(y)}o.morphAttributes[f]=_}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const u=e.data.groups||e.data.drawcalls||e.data.offsets;if(u!==void 0)for(let f=0,p=u.length;f!==p;++f){const _=u[f];o.addGroup(_.start,_.count,_.materialIndex)}const d=e.data.boundingSphere;if(d!==void 0){const f=new F;d.center!==void 0&&f.fromArray(d.center),o.boundingSphere=new ni(f,d.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class ZA extends On{constructor(e){super(e)}load(e,t,n,i){const s=this,o=this.path===""?vd.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new zi(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(u){i!==void 0&&i(u),console.error("THREE:ObjectLoader: Can't parse "+e+".",u.message);return}const h=c.metadata;if(h===void 0||h.type===void 0||h.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(c,t)},n,i)}async loadAsync(e,t){const n=this,i=this.path===""?vd.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const s=new zi(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const o=await s.loadAsync(e,t),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await n.parseAsync(a)}parse(e,t){const n=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),o=this.parseImages(e.images,function(){t!==void 0&&t(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,s,l,a,n),h=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,h),t!==void 0){let u=!1;for(const d in o)if(o[d].data instanceof HTMLImageElement){u=!0;break}u===!1&&t(c)}return c}async parseAsync(e){const t=this.parseAnimations(e.animations),n=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,n),s=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,s),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,i,a,o,t),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(e){const t={};if(e!==void 0)for(let n=0,i=e.length;n<i;n++){const s=new qs().fromJSON(e[n]);t[s.uuid]=s}return t}parseSkeletons(e,t){const n={},i={};if(t.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new Gc().fromJSON(e[s],i);n[a.uuid]=a}return n}parseGeometries(e,t){const n={};if(e!==void 0){const i=new p0;for(let s=0,o=e.length;s<o;s++){let a;const l=e[s];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(l);break;default:l.type in Rm?a=Rm[l.type].fromJSON(l,t):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),l.userData!==void 0&&(a.userData=l.userData),n[l.uuid]=a}}return n}parseMaterials(e,t){const n={},i={};if(e!==void 0){const s=new Yc;s.setTextures(t);for(let o=0,a=e.length;o<a;o++){const l=e[o];n[l.uuid]===void 0&&(n[l.uuid]=s.parse(l)),i[l.uuid]=n[l.uuid]}}return i}parseAnimations(e){const t={};if(e!==void 0)for(let n=0;n<e.length;n++){const i=e[n],s=fa.parse(i);t[s.uuid]=s}return t}parseImages(e,t){const n=this,i={};let s;function o(l){return n.manager.itemStart(l),s.load(l,function(){n.manager.itemEnd(l)},void 0,function(){n.manager.itemError(l),n.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,h=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:n.resourcePath+c;return o(h)}else return l.data?{data:qr(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new gf(t);s=new pa(l),s.setCrossOrigin(this.crossOrigin);for(let c=0,h=e.length;c<h;c++){const u=e[c],d=u.url;if(Array.isArray(d)){const f=[];for(let p=0,_=d.length;p<_;p++){const g=d[p],m=a(g);m!==null&&(m instanceof HTMLImageElement?f.push(m):f.push(new eo(m.data,m.width,m.height)))}i[u.uuid]=new Hs(f)}else{const f=a(u.url);i[u.uuid]=new Hs(f)}}}return i}async parseImagesAsync(e){const t=this,n={};let i;async function s(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:t.resourcePath+a;return await i.loadAsync(l)}else return o.data?{data:qr(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){i=new pa(this.manager),i.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],c=l.url;if(Array.isArray(c)){const h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u],p=await s(f);p!==null&&(p instanceof HTMLImageElement?h.push(p):h.push(new eo(p.data,p.width,p.height)))}n[l.uuid]=new Hs(h)}else{const h=await s(l.url);n[l.uuid]=new Hs(h)}}}return n}parseTextures(e,t){function n(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const i={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),t[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=t[a.image],c=l.data;let h;Array.isArray(c)?(h=new ba,c.length===6&&(h.needsUpdate=!0)):(c&&c.data?h=new eo:h=new Lt,c&&(h.needsUpdate=!0)),h.source=l,h.uuid=a.uuid,a.name!==void 0&&(h.name=a.name),a.mapping!==void 0&&(h.mapping=n(a.mapping,KA)),a.channel!==void 0&&(h.channel=a.channel),a.offset!==void 0&&h.offset.fromArray(a.offset),a.repeat!==void 0&&h.repeat.fromArray(a.repeat),a.center!==void 0&&h.center.fromArray(a.center),a.rotation!==void 0&&(h.rotation=a.rotation),a.wrap!==void 0&&(h.wrapS=n(a.wrap[0],Nm),h.wrapT=n(a.wrap[1],Nm)),a.format!==void 0&&(h.format=a.format),a.internalFormat!==void 0&&(h.internalFormat=a.internalFormat),a.type!==void 0&&(h.type=a.type),a.colorSpace!==void 0&&(h.colorSpace=a.colorSpace),a.encoding!==void 0&&(h.encoding=a.encoding),a.minFilter!==void 0&&(h.minFilter=n(a.minFilter,Om)),a.magFilter!==void 0&&(h.magFilter=n(a.magFilter,Om)),a.anisotropy!==void 0&&(h.anisotropy=a.anisotropy),a.flipY!==void 0&&(h.flipY=a.flipY),a.generateMipmaps!==void 0&&(h.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(h.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(h.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(h.compareFunction=a.compareFunction),a.userData!==void 0&&(h.userData=a.userData),i[a.uuid]=h}return i}parseObject(e,t,n,i,s){let o;function a(d){return t[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",d),t[d]}function l(d){if(d!==void 0){if(Array.isArray(d)){const f=[];for(let p=0,_=d.length;p<_;p++){const g=d[p];n[g]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",g),f.push(n[g])}return f}return n[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",d),n[d]}}function c(d){return i[d]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",d),i[d]}let h,u;switch(e.type){case"Scene":o=new C1,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new He(e.background):o.background=c(e.background)),e.environment!==void 0&&(o.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new Bc(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new Vc(e.fog.color,e.fog.density))),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity);break;case"PerspectiveCamera":o=new Yt(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new Fc(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new h0(e.color,e.intensity);break;case"DirectionalLight":o=new c0(e.color,e.intensity);break;case"PointLight":o=new l0(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new u0(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new a0(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new o0(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new jc().fromJSON(e);break;case"SkinnedMesh":h=a(e.geometry),u=l(e.material),o=new L1(h,u),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":h=a(e.geometry),u=l(e.material),o=new qt(h,u);break;case"InstancedMesh":h=a(e.geometry),u=l(e.material);const d=e.count,f=e.instanceMatrix,p=e.instanceColor;o=new N1(h,u,d),o.instanceMatrix=new ao(new Float32Array(f.array),16),p!==void 0&&(o.instanceColor=new ao(new Float32Array(p.array),p.itemSize));break;case"LOD":o=new I1;break;case"Line":o=new ms(a(e.geometry),l(e.material));break;case"LineLoop":o=new O1(a(e.geometry),l(e.material));break;case"LineSegments":o=new yi(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new D1(a(e.geometry),l(e.material));break;case"Sprite":o=new P1(l(e.material));break;case"Group":o=new Zr;break;case"Bone":o=new tf;break;default:o=new mt}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const d=e.children;for(let f=0;f<d.length;f++)o.add(this.parseObject(d[f],t,n,i,s))}if(e.animations!==void 0){const d=e.animations;for(let f=0;f<d.length;f++){const p=d[f];o.animations.push(s[p])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const d=e.levels;for(let f=0;f<d.length;f++){const p=d[f],_=o.getObjectByProperty("uuid",p.object);_!==void 0&&o.addLevel(_,p.distance,p.hysteresis)}}return o}bindSkeletons(e,t){Object.keys(t).length!==0&&e.traverse(function(n){if(n.isSkinnedMesh===!0&&n.skeleton!==void 0){const i=t[n.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",n.skeleton):n.bind(i,n.bindMatrix)}})}}const KA={UVMapping:Pc,CubeReflectionMapping:ds,CubeRefractionMapping:fs,EquirectangularReflectionMapping:Ko,EquirectangularRefractionMapping:Jo,CubeUVReflectionMapping:co},Nm={RepeatWrapping:Qo,ClampToEdgeWrapping:en,MirroredRepeatWrapping:ea},Om={NearestFilter:Pt,NearestMipmapNearestFilter:_c,NearestMipmapLinearFilter:Xo,LinearFilter:It,LinearMipmapNearestFilter:Ud,LinearMipmapLinearFilter:ps};class JA extends On{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=Js.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(o),s.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){Js.add(e,l),t&&t(l),s.manager.itemEnd(e)}).catch(function(l){i&&i(l),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}let Rl;class yf{static getContext(){return Rl===void 0&&(Rl=new(window.AudioContext||window.webkitAudioContext)),Rl}static setContext(e){Rl=e}}class QA extends On{constructor(e){super(e)}load(e,t,n,i){const s=this,o=new zi(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const c=l.slice(0);yf.getContext().decodeAudioData(c,function(u){t(u)},a)}catch(c){a(c)}},n,i);function a(l){i?i(l):console.error(l),s.manager.itemError(e)}}}class eE extends jc{constructor(e,t,n=1){super(void 0,n),this.isHemisphereLightProbe=!0;const i=new He().set(e),s=new He().set(t),o=new F(i.r,i.g,i.b),a=new F(s.r,s.g,s.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}class tE extends jc{constructor(e,t=1){super(void 0,t),this.isAmbientLightProbe=!0;const n=new He().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const Dm=new rt,Um=new rt,Rs=new rt;class nE{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Yt,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Yt,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep,Rs.copy(e.projectionMatrix);const i=t.eyeSep/2,s=i*t.near/t.focus,o=t.near*Math.tan(Ys*t.fov*.5)/t.zoom;let a,l;Um.elements[12]=-i,Dm.elements[12]=i,a=-o*t.aspect+s,l=o*t.aspect+s,Rs.elements[0]=2*t.near/(l-a),Rs.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(Rs),a=-o*t.aspect-s,l=o*t.aspect-s,Rs.elements[0]=2*t.near/(l-a),Rs.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(Rs)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Um),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Dm)}}class m0{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Fm(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=Fm();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function Fm(){return(typeof performance>"u"?Date:performance).now()}const Ps=new F,zm=new yn,iE=new F,Is=new F;class sE extends mt{constructor(){super(),this.type="AudioListener",this.context=yf.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new m0}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,n=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(Ps,zm,iE),Is.set(0,0,-1).applyQuaternion(zm),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(Ps.x,i),t.positionY.linearRampToValueAtTime(Ps.y,i),t.positionZ.linearRampToValueAtTime(Ps.z,i),t.forwardX.linearRampToValueAtTime(Is.x,i),t.forwardY.linearRampToValueAtTime(Is.y,i),t.forwardZ.linearRampToValueAtTime(Is.z,i),t.upX.linearRampToValueAtTime(n.x,i),t.upY.linearRampToValueAtTime(n.y,i),t.upZ.linearRampToValueAtTime(n.z,i)}else t.setPosition(Ps.x,Ps.y,Ps.z),t.setOrientation(Is.x,Is.y,Is.z,n.x,n.y,n.z)}}class g0 extends mt{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const Ls=new F,Vm=new yn,rE=new F,Ns=new F;class oE extends g0{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,t,n){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=t,this.panner.coneOuterGain=n,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(Ls,Vm,rE),Ns.set(0,0,1).applyQuaternion(Vm);const t=this.panner;if(t.positionX){const n=this.context.currentTime+this.listener.timeDelta;t.positionX.linearRampToValueAtTime(Ls.x,n),t.positionY.linearRampToValueAtTime(Ls.y,n),t.positionZ.linearRampToValueAtTime(Ls.z,n),t.orientationX.linearRampToValueAtTime(Ns.x,n),t.orientationY.linearRampToValueAtTime(Ns.y,n),t.orientationZ.linearRampToValueAtTime(Ns.z,n)}else t.setPosition(Ls.x,Ls.y,Ls.z),t.setOrientation(Ns.x,Ns.y,Ns.z)}}class aE{constructor(e,t=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=t,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const t=this.getFrequencyData();for(let n=0;n<t.length;n++)e+=t[n];return e/t.length}}class _0{constructor(e,t,n){this.binding=e,this.valueSize=n;let i,s,o;switch(t){case"quaternion":i=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,i=this.valueSize,s=e*i+i;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==i;++a)n[s+a]=n[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(n,s,0,a,i)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,i=e*t+t,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=t*this._origIndex;this._mixBufferRegion(n,i,l,1-s,t)}o>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(n[l]!==n[l+t]){a.setValue(n,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let s=n,o=i;s!==o;++s)t[s]=t[i+s%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,i,s){if(i>=.5)for(let o=0;o!==s;++o)e[t+o]=e[n+o]}_slerp(e,t,n,i){yn.slerpFlat(e,t,e,t,e,n,i)}_slerpAdditive(e,t,n,i,s){const o=this._workIndex*s;yn.multiplyQuaternionsFlat(e,o,e,t,e,n),yn.slerpFlat(e,t,e,t,e,o,i)}_lerp(e,t,n,i,s){const o=1-i;for(let a=0;a!==s;++a){const l=t+a;e[l]=e[l]*o+e[n+a]*i}}_lerpAdditive(e,t,n,i,s){for(let o=0;o!==s;++o){const a=t+o;e[a]=e[a]+e[n+o]*i}}}const xf="\\[\\]\\.:\\/",lE=new RegExp("["+xf+"]","g"),vf="[^"+xf+"]",cE="[^"+xf.replace("\\.","")+"]",hE=/((?:WC+[\/:])*)/.source.replace("WC",vf),uE=/(WCOD+)?/.source.replace("WCOD",cE),dE=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",vf),fE=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",vf),pE=new RegExp("^"+hE+uE+dE+fE+"$"),mE=["material","materials","bones","map"];class gE{constructor(e,t,n){const i=n||ft.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=n.length;i!==s;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class ft{constructor(e,t,n){this.path=t,this.parsedPath=n||ft.parseTrackName(t),this.node=ft.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new ft.Composite(e,t,n):new ft(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(lE,"")}static parseTrackName(e){const t=pE.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=n.nodeName.substring(i+1);mE.indexOf(s)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=s)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===t||a.uuid===t)return a;const l=n(a.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,s=n.length;i!==s;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let s=t.propertyIndex;if(e||(e=ft.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let h=0;h<e.length;h++)if(e[h].name===c){c=h;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[i];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ft.Composite=gE;ft.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ft.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ft.prototype.GetterByBindingType=[ft.prototype._getValue_direct,ft.prototype._getValue_array,ft.prototype._getValue_arrayElement,ft.prototype._getValue_toArray];ft.prototype.SetterByBindingTypeAndVersioning=[[ft.prototype._setValue_direct,ft.prototype._setValue_direct_setNeedsUpdate,ft.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_array,ft.prototype._setValue_array_setNeedsUpdate,ft.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_arrayElement,ft.prototype._setValue_arrayElement_setNeedsUpdate,ft.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ft.prototype._setValue_fromArray,ft.prototype._setValue_fromArray_setNeedsUpdate,ft.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class _E{constructor(){this.isAnimationObjectGroup=!0,this.uuid=In(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}add(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,s=this._bindings,o=s.length;let a,l=e.length,c=this.nCachedObjects_;for(let h=0,u=arguments.length;h!==u;++h){const d=arguments[h],f=d.uuid;let p=t[f];if(p===void 0){p=l++,t[f]=p,e.push(d);for(let _=0,g=o;_!==g;++_)s[_].push(new ft(d,n[_],i[_]))}else if(p<c){a=e[p];const _=--c,g=e[_];t[g.uuid]=p,e[p]=g,t[f]=_,e[_]=d;for(let m=0,v=o;m!==v;++m){const y=s[m],S=y[_];let b=y[p];y[p]=S,b===void 0&&(b=new ft(d,n[m],i[m])),y[_]=b}}else e[p]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let s=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,h=t[c];if(h!==void 0&&h>=s){const u=s++,d=e[u];t[d.uuid]=h,e[h]=d,t[c]=u,e[u]=l;for(let f=0,p=i;f!==p;++f){const _=n[f],g=_[u],m=_[h];_[h]=g,_[u]=m}}}this.nCachedObjects_=s}uncache(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let s=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],h=c.uuid,u=t[h];if(u!==void 0)if(delete t[h],u<s){const d=--s,f=e[d],p=--o,_=e[p];t[f.uuid]=u,e[u]=f,t[_.uuid]=d,e[d]=_,e.pop();for(let g=0,m=i;g!==m;++g){const v=n[g],y=v[d],S=v[p];v[u]=y,v[d]=S,v.pop()}}else{const d=--o,f=e[d];d>0&&(t[f.uuid]=u),e[u]=f,e.pop();for(let p=0,_=i;p!==_;++p){const g=n[p];g[u]=g[d],g.pop()}}}this.nCachedObjects_=s}subscribe_(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const s=this._bindings;if(i!==void 0)return s[i];const o=this._paths,a=this._parsedPaths,l=this._objects,c=l.length,h=this.nCachedObjects_,u=new Array(c);i=s.length,n[e]=i,o.push(e),a.push(t),s.push(u);for(let d=h,f=l.length;d!==f;++d){const p=l[d];u[d]=new ft(p,e,t)}return u}unsubscribe_(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,s=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],c=e[a];t[c]=n,o[n]=l,o.pop(),s[n]=s[a],s.pop(),i[n]=i[a],i.pop()}}}class y0{constructor(e,t,n=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=i;const s=t.tracks,o=s.length,a=new Array(o),l={endingStart:ks,endingEnd:ks};for(let c=0;c!==o;++c){const h=s[c].createInterpolant(null);a[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=K_,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const i=this._clip.duration,s=e._clip.duration,o=s/i,a=i/s;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const i=this._mixer,s=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+n,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*n;l<0||n===0?t=0:(this._startTime=null,t=n*l)}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case Hd:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulateAdditive(a);break;case Lc:default:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulate(i,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;if(n!==null){const i=n.evaluate(e)[0];t*=i,e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let i=this.time+e,s=this._loopCount;const o=n===J_;if(e===0)return s===-1?i:o&&(s&1)===1?t-i:i;if(n===Z_){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=t||i<0){const a=Math.floor(i/t);i-=t*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(s&1)===1)return t-i}return i}_setEndings(e,t,n){const i=this._interpolantSettings;n?(i.endingStart=Gs,i.endingEnd=Gs):(e?i.endingStart=this.zeroSlopeAtStart?Gs:ks:i.endingStart=ia,t?i.endingEnd=this.zeroSlopeAtEnd?Gs:ks:i.endingEnd=ia)}_scheduleFading(e,t,n){const i=this._mixer,s=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=t,a[1]=s+e,l[1]=n,this}}const yE=new Float32Array(1);class xE extends Gi{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,s=i.length,o=e._propertyBindings,a=e._interpolants,l=n.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let u=0;u!==s;++u){const d=i[u],f=d.name;let p=h[f];if(p!==void 0)++p.referenceCount,o[u]=p;else{if(p=o[u],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,f));continue}const _=t&&t._propertyBindings[u].binding.parsedPath;p=new _0(ft.create(n,f,_),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,f),o[u]=p}a[u].resultBuffer=p.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,s=this._actionsByClip[i];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const i=this._actions,s=this._actionsByClip;let o=s[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=i.length,i.push(e),o.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],l=a.knownActions,c=l[l.length-1],h=e._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),e._byClipCacheIndex=null;const u=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete u[d],l.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const s=t[n];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_addInactiveBinding(e,t,n){const i=this._bindingsByRootAndName,s=this._bindings;let o=i[t];o===void 0&&(o={},i[t]=o),o[n]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,s=n.path,o=this._bindingsByRootAndName,a=o[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete a[s],Object.keys(a).length===0&&delete o[i]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,s=t[i];e._cacheIndex=i,t[i]=e,s._cacheIndex=n,t[n]=s}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new pf(new Float32Array(2),new Float32Array(2),1,yE),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,s=t[i];e.__cacheIndex=i,t[i]=e,s.__cacheIndex=n,t[n]=s}clipAction(e,t,n){const i=t||this._root,s=i.uuid;let o=typeof e=="string"?fa.findByName(i,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(n===void 0&&(o!==null?n=o.blendMode:n=Lc),l!==void 0){const u=l.actionByRoot[s];if(u!==void 0&&u.blendMode===n)return u;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const h=new y0(this,o,t,n);return this._bindAction(h,c),this._addInactiveAction(h,a,s),h}existingAction(e,t){const n=t||this._root,i=n.uuid,s=typeof e=="string"?fa.findByName(n,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==n;++c)t[c]._update(i,e,s,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,s=i[n];if(s!==void 0){const o=s.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const h=c._cacheIndex,u=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=h,t[h]=u,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const o in n){const a=n[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,s=i[t];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}class Sf{constructor(e){this.value=e}clone(){return new Sf(this.value.clone===void 0?this.value:this.value.clone())}}let vE=0;class SE extends Gi{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:vE++}),this.name="",this.usage=sa,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const t=this.uniforms.indexOf(e);return t!==-1&&this.uniforms.splice(t,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const t=e.uniforms;this.uniforms.length=0;for(let n=0,i=t.length;n<i;n++)this.uniforms.push(t[n].clone());return this}clone(){return new this.constructor().copy(this)}}class bE extends kc{constructor(e,t,n=1){super(e,t),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}class wE{constructor(e,t,n,i,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,t){return this.type=e,this.elementSize=t,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}class ME{constructor(e,t,n=0,i=1/0){this.ray=new ho(e,t),this.near=n,this.far=i,this.camera=null,this.layers=new Oc,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}intersectObject(e,t=!0,n=[]){return Sd(e,this,n,t),n.sort(Bm),n}intersectObjects(e,t=!0,n=[]){for(let i=0,s=e.length;i<s;i++)Sd(e[i],this,n,t);return n.sort(Bm),n}}function Bm(r,e){return r.distance-e.distance}function Sd(r,e,t,n){if(r.layers.test(e.layers)&&r.raycast(e,t),n===!0){const i=r.children;for(let s=0,o=i.length;s<o;s++)Sd(i[s],e,t,!0)}}class AE{constructor(e=1,t=0,n=0){return this.radius=e,this.phi=t,this.theta=n,this}set(e,t,n){return this.radius=e,this.phi=t,this.theta=n,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+t*t+n*n),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,n),this.phi=Math.acos(Ct(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class EE{constructor(e=1,t=0,n=0){return this.radius=e,this.theta=t,this.y=n,this}set(e,t,n){return this.radius=e,this.theta=t,this.y=n,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,n){return this.radius=Math.sqrt(e*e+n*n),this.theta=Math.atan2(e,n),this.y=t,this}clone(){return new this.constructor().copy(this)}}const km=new Te;class TE{constructor(e=new Te(1/0,1/0),t=new Te(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=km.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,km).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Gm=new F,Pl=new F;class CE{constructor(e=new F,t=new F){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){Gm.subVectors(e,this.start),Pl.subVectors(this.end,this.start);const n=Pl.dot(Pl);let s=Pl.dot(Gm)/n;return t&&(s=Ct(s,0,1)),s}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const Hm=new F;class RE extends mt{constructor(e,t){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=t,this.type="SpotLightHelper";const n=new ht,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,h=a/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(h),Math.sin(h),1)}n.setAttribute("position",new je(i,3));const s=new un({fog:!1,toneMapped:!1});this.cone=new yi(n,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const e=this.light.distance?this.light.distance:1e3,t=e*Math.tan(this.light.angle);this.cone.scale.set(t,t,e),Hm.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(Hm),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Zi=new F,Il=new rt,su=new rt;class PE extends yi{constructor(e){const t=x0(e),n=new ht,i=[],s=[],o=new He(0,0,1),a=new He(0,1,0);for(let c=0;c<t.length;c++){const h=t[c];h.parent&&h.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}n.setAttribute("position",new je(i,3)),n.setAttribute("color",new je(s,3));const l=new un({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,i=n.getAttribute("position");su.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<t.length;s++){const a=t[s];a.parent&&a.parent.isBone&&(Il.multiplyMatrices(su,a.matrixWorld),Zi.setFromMatrixPosition(Il),i.setXYZ(o,Zi.x,Zi.y,Zi.z),Il.multiplyMatrices(su,a.parent.matrixWorld),Zi.setFromMatrixPosition(Il),i.setXYZ(o+1,Zi.x,Zi.y,Zi.z),o+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function x0(r){const e=[];r.isBone===!0&&e.push(r);for(let t=0;t<r.children.length;t++)e.push.apply(e,x0(r.children[t]));return e}class IE extends qt{constructor(e,t,n){const i=new go(t,4,2),s=new ys({wireframe:!0,fog:!1,toneMapped:!1});super(i,s),this.light=e,this.color=n,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const LE=new F,Wm=new He,Xm=new He;class NE extends mt{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="HemisphereLightHelper";const i=new mo(t);i.rotateY(Math.PI*.5),this.material=new ys({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),o=new Float32Array(s.count*3);i.setAttribute("color",new vt(o,3)),this.add(new qt(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const t=e.geometry.getAttribute("color");Wm.copy(this.light.color),Xm.copy(this.light.groundColor);for(let n=0,i=t.count;n<i;n++){const s=n<i/2?Wm:Xm;t.setXYZ(n,s.r,s.g,s.b)}t.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(LE.setFromMatrixPosition(this.light.matrixWorld).negate())}}class OE extends yi{constructor(e=10,t=10,n=4473924,i=8947848){n=new He(n),i=new He(i);const s=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,f=0,p=-a;d<=t;d++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const _=d===s?n:i;_.toArray(c,f),f+=3,_.toArray(c,f),f+=3,_.toArray(c,f),f+=3,_.toArray(c,f),f+=3}const h=new ht;h.setAttribute("position",new je(l,3)),h.setAttribute("color",new je(c,3));const u=new un({vertexColors:!0,toneMapped:!1});super(h,u),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class DE extends yi{constructor(e=10,t=16,n=8,i=64,s=4473924,o=8947848){s=new He(s),o=new He(o);const a=[],l=[];if(t>1)for(let u=0;u<t;u++){const d=u/t*(Math.PI*2),f=Math.sin(d)*e,p=Math.cos(d)*e;a.push(0,0,0),a.push(f,0,p);const _=u&1?s:o;l.push(_.r,_.g,_.b),l.push(_.r,_.g,_.b)}for(let u=0;u<n;u++){const d=u&1?s:o,f=e-e/n*u;for(let p=0;p<i;p++){let _=p/i*(Math.PI*2),g=Math.sin(_)*f,m=Math.cos(_)*f;a.push(g,0,m),l.push(d.r,d.g,d.b),_=(p+1)/i*(Math.PI*2),g=Math.sin(_)*f,m=Math.cos(_)*f,a.push(g,0,m),l.push(d.r,d.g,d.b)}}const c=new ht;c.setAttribute("position",new je(a,3)),c.setAttribute("color",new je(l,3));const h=new un({vertexColors:!0,toneMapped:!1});super(c,h),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const jm=new F,Ll=new F,Ym=new F;class UE extends mt{constructor(e,t,n){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=n,this.type="DirectionalLightHelper",t===void 0&&(t=1);let i=new ht;i.setAttribute("position",new je([-t,t,0,t,t,0,t,-t,0,-t,-t,0,-t,t,0],3));const s=new un({fog:!1,toneMapped:!1});this.lightPlane=new ms(i,s),this.add(this.lightPlane),i=new ht,i.setAttribute("position",new je([0,0,0,0,0,1],3)),this.targetLine=new ms(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),jm.setFromMatrixPosition(this.light.matrixWorld),Ll.setFromMatrixPosition(this.light.target.matrixWorld),Ym.subVectors(Ll,jm),this.lightPlane.lookAt(Ll),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Ll),this.targetLine.scale.z=Ym.length()}}const Nl=new F,Tt=new Dc;class FE extends yi{constructor(e){const t=new ht,n=new un({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(p,_){l(p),l(_)}function l(p){i.push(0,0,0),s.push(0,0,0),o[p]===void 0&&(o[p]=[]),o[p].push(i.length/3-1)}t.setAttribute("position",new je(i,3)),t.setAttribute("color",new je(s,3)),super(t,n),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const c=new He(16755200),h=new He(16711680),u=new He(43775),d=new He(16777215),f=new He(3355443);this.setColors(c,h,u,d,f)}setColors(e,t,n,i,s){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,t.r,t.g,t.b),a.setXYZ(25,t.r,t.g,t.b),a.setXYZ(26,t.r,t.g,t.b),a.setXYZ(27,t.r,t.g,t.b),a.setXYZ(28,t.r,t.g,t.b),a.setXYZ(29,t.r,t.g,t.b),a.setXYZ(30,t.r,t.g,t.b),a.setXYZ(31,t.r,t.g,t.b),a.setXYZ(32,n.r,n.g,n.b),a.setXYZ(33,n.r,n.g,n.b),a.setXYZ(34,n.r,n.g,n.b),a.setXYZ(35,n.r,n.g,n.b),a.setXYZ(36,n.r,n.g,n.b),a.setXYZ(37,n.r,n.g,n.b),a.setXYZ(38,i.r,i.g,i.b),a.setXYZ(39,i.r,i.g,i.b),a.setXYZ(40,s.r,s.g,s.b),a.setXYZ(41,s.r,s.g,s.b),a.setXYZ(42,s.r,s.g,s.b),a.setXYZ(43,s.r,s.g,s.b),a.setXYZ(44,s.r,s.g,s.b),a.setXYZ(45,s.r,s.g,s.b),a.setXYZ(46,s.r,s.g,s.b),a.setXYZ(47,s.r,s.g,s.b),a.setXYZ(48,s.r,s.g,s.b),a.setXYZ(49,s.r,s.g,s.b),a.needsUpdate=!0}update(){const e=this.geometry,t=this.pointMap,n=1,i=1;Tt.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),Rt("c",t,e,Tt,0,0,-1),Rt("t",t,e,Tt,0,0,1),Rt("n1",t,e,Tt,-n,-i,-1),Rt("n2",t,e,Tt,n,-i,-1),Rt("n3",t,e,Tt,-n,i,-1),Rt("n4",t,e,Tt,n,i,-1),Rt("f1",t,e,Tt,-n,-i,1),Rt("f2",t,e,Tt,n,-i,1),Rt("f3",t,e,Tt,-n,i,1),Rt("f4",t,e,Tt,n,i,1),Rt("u1",t,e,Tt,n*.7,i*1.1,-1),Rt("u2",t,e,Tt,-n*.7,i*1.1,-1),Rt("u3",t,e,Tt,0,i*2,-1),Rt("cf1",t,e,Tt,-n,0,1),Rt("cf2",t,e,Tt,n,0,1),Rt("cf3",t,e,Tt,0,-i,1),Rt("cf4",t,e,Tt,0,i,1),Rt("cn1",t,e,Tt,-n,0,-1),Rt("cn2",t,e,Tt,n,0,-1),Rt("cn3",t,e,Tt,0,-i,-1),Rt("cn4",t,e,Tt,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function Rt(r,e,t,n,i,s,o){Nl.set(i,s,o).unproject(n);const a=e[r];if(a!==void 0){const l=t.getAttribute("position");for(let c=0,h=a.length;c<h;c++)l.setXYZ(a[c],Nl.x,Nl.y,Nl.z)}}const Ol=new _i;class zE extends yi{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(24),s=new ht;s.setIndex(new vt(n,1)),s.setAttribute("position",new vt(i,3)),super(s,new un({color:t,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&Ol.setFromObject(this.object),Ol.isEmpty())return;const t=Ol.min,n=Ol.max,i=this.geometry.attributes.position,s=i.array;s[0]=n.x,s[1]=n.y,s[2]=n.z,s[3]=t.x,s[4]=n.y,s[5]=n.z,s[6]=t.x,s[7]=t.y,s[8]=n.z,s[9]=n.x,s[10]=t.y,s[11]=n.z,s[12]=n.x,s[13]=n.y,s[14]=t.z,s[15]=t.x,s[16]=n.y,s[17]=t.z,s[18]=t.x,s[19]=t.y,s[20]=t.z,s[21]=n.x,s[22]=t.y,s[23]=t.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,t){return super.copy(e,t),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class VE extends yi{constructor(e,t=16776960){const n=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new ht;s.setIndex(new vt(n,1)),s.setAttribute("position",new je(i,3)),super(s,new un({color:t,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const t=this.box;t.isEmpty()||(t.getCenter(this.position),t.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class BE extends ms{constructor(e,t=1,n=16776960){const i=n,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new ht;o.setAttribute("position",new je(s,3)),o.computeBoundingSphere(),super(o,new un({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=t;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new ht;l.setAttribute("position",new je(a,3)),l.computeBoundingSphere(),this.add(new qt(l,new ys({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const qm=new F;let Dl,ru;class kE extends mt{constructor(e=new F(0,0,1),t=new F(0,0,0),n=1,i=16776960,s=n*.2,o=s*.2){super(),this.type="ArrowHelper",Dl===void 0&&(Dl=new ht,Dl.setAttribute("position",new je([0,0,0,0,1,0],3)),ru=new nr(0,.5,1,5,1),ru.translate(0,-.5,0)),this.position.copy(t),this.line=new ms(Dl,new un({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new qt(ru,new ys({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(n,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{qm.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(qm,t)}}setLength(e,t=e*.2,n=t*.2){this.line.scale.set(1,Math.max(1e-4,e-t),1),this.line.updateMatrix(),this.cone.scale.set(n,t,n),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class GE extends yi{constructor(e=1){const t=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],n=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new ht;i.setAttribute("position",new je(t,3)),i.setAttribute("color",new je(n,3));const s=new un({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}setColors(e,t,n){const i=new He,s=this.geometry.attributes.color.array;return i.set(e),i.toArray(s,0),i.toArray(s,3),i.set(t),i.toArray(s,6),i.toArray(s,9),i.set(n),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class HE{constructor(){this.type="ShapePath",this.color=new He,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new aa,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,s,o){return this.currentPath.bezierCurveTo(e,t,n,i,s,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(m){const v=[];for(let y=0,S=m.length;y<S;y++){const b=m[y],M=new qs;M.curves=b.curves,v.push(M)}return v}function n(m,v){const y=v.length;let S=!1;for(let b=y-1,M=0;M<y;b=M++){let E=v[b],T=v[M],w=T.x-E.x,A=T.y-E.y;if(Math.abs(A)>Number.EPSILON){if(A<0&&(E=v[M],w=-w,T=v[b],A=-A),m.y<E.y||m.y>T.y)continue;if(m.y===E.y){if(m.x===E.x)return!0}else{const D=A*(m.x-E.x)-w*(m.y-E.y);if(D===0)return!0;if(D<0)continue;S=!S}}else{if(m.y!==E.y)continue;if(T.x<=m.x&&m.x<=E.x||E.x<=m.x&&m.x<=T.x)return!0}}return S}const i=pi.isClockWise,s=this.subPaths;if(s.length===0)return[];let o,a,l;const c=[];if(s.length===1)return a=s[0],l=new qs,l.curves=a.curves,c.push(l),c;let h=!i(s[0].getPoints());h=e?!h:h;const u=[],d=[];let f=[],p=0,_;d[p]=void 0,f[p]=[];for(let m=0,v=s.length;m<v;m++)a=s[m],_=a.getPoints(),o=i(_),o=e?!o:o,o?(!h&&d[p]&&p++,d[p]={s:new qs,p:_},d[p].s.curves=a.curves,h&&p++,f[p]=[]):f[p].push({h:a,p:_[0]});if(!d[0])return t(s);if(d.length>1){let m=!1,v=0;for(let y=0,S=d.length;y<S;y++)u[y]=[];for(let y=0,S=d.length;y<S;y++){const b=f[y];for(let M=0;M<b.length;M++){const E=b[M];let T=!0;for(let w=0;w<d.length;w++)n(E.p,d[w].p)&&(y!==w&&v++,T?(T=!1,u[w].push(E)):m=!0);T&&u[y].push(E)}}v>0&&m===!1&&(f=u)}let g;for(let m=0,v=d.length;m<v;m++){l=d[m].s,c.push(l),g=f[m];for(let y=0,S=g.length;y<S;y++)l.holes.push(g[y].h)}return c}}class WE extends xs{constructor(e,t,n,i,s,o){console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."),super(e,t,n,i,s,o)}}class XE extends wa{constructor(e,t,n,i){console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."),super(e,t,n,i)}}class jE extends Ma{constructor(e,t,n,i){console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."),super(e,t,n,i)}}class YE extends Aa{constructor(e,t,n,i,s,o,a){console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."),super(e,t,n,i,s,o,a)}}let qE=class extends nr{constructor(e,t,n,i,s,o,a,l){console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."),super(e,t,n,i,s,o,a,l)}};class $E extends Ea{constructor(e,t){console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."),super(e,t)}}class ZE extends Ta{constructor(e,t){console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."),super(e,t)}}class KE extends Ca{constructor(e,t){console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."),super(e,t)}}class JE extends po{constructor(e,t,n,i){console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."),super(e,t,n,i)}}class QE extends mo{constructor(e,t){console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."),super(e,t)}}class eT extends uo{constructor(e,t,n,i){console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."),super(e,t,n,i)}}class tT extends Hi{constructor(e,t,n,i){console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."),super(e,t,n,i)}}class nT extends Ra{constructor(e,t,n,i,s,o){console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."),super(e,t,n,i,s,o)}}class iT extends Pa{constructor(e,t){console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."),super(e,t)}}class sT extends go{constructor(e,t,n,i,s,o,a){console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."),super(e,t,n,i,s,o,a)}}class rT extends Ia{constructor(e,t){console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."),super(e,t)}}class oT extends La{constructor(e,t,n,i,s){console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."),super(e,t,n,i,s)}}class aT extends Na{constructor(e,t,n,i,s,o){console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."),super(e,t,n,i,s,o)}}class lT extends Oa{constructor(e,t,n,i,s){console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."),super(e,t,n,i,s)}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Rc}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Rc);const cT=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:V_,AddEquation:Vs,AddOperation:D_,AdditiveAnimationBlendMode:Hd,AdditiveBlending:zu,AlphaFormat:H_,AlwaysCompare:h1,AlwaysDepth:C_,AlwaysStencilFunc:n1,AmbientLight:h0,AmbientLightProbe:tE,AnimationAction:y0,AnimationClip:fa,AnimationLoader:GA,AnimationMixer:xE,AnimationObjectGroup:_E,AnimationUtils:zA,ArcCurve:U1,ArrayCamera:M1,ArrowHelper:kE,Audio:g0,AudioAnalyser:aE,AudioContext:yf,AudioListener:sE,AudioLoader:QA,AxesHelper:GE,BackSide:cn,BasicDepthPacking:Q_,BasicShadowMap:sx,Bone:tf,BooleanKeyframeTrack:ir,Box2:TE,Box3:_i,Box3Helper:VE,BoxBufferGeometry:WE,BoxGeometry:xs,BoxHelper:zE,BufferAttribute:vt,BufferGeometry:ht,BufferGeometryLoader:p0,ByteType:k_,Cache:Js,Camera:Dc,CameraHelper:FE,CanvasTexture:lA,CapsuleBufferGeometry:XE,CapsuleGeometry:wa,CatmullRomCurve3:F1,CineonToneMapping:z_,CircleBufferGeometry:jE,CircleGeometry:Ma,ClampToEdgeWrapping:en,Clock:m0,Color:He,ColorKeyframeTrack:mf,ColorManagement:Vn,CompressedArrayTexture:aA,CompressedTexture:sf,CompressedTextureLoader:HA,ConeBufferGeometry:YE,ConeGeometry:Aa,CubeCamera:g1,CubeReflectionMapping:ds,CubeRefractionMapping:fs,CubeTexture:ba,CubeTextureLoader:WA,CubeUVReflectionMapping:co,CubicBezierCurve:of,CubicBezierCurve3:z1,CubicInterpolant:n0,CullFaceBack:Fu,CullFaceFront:f_,CullFaceFrontBack:ix,CullFaceNone:d_,Curve:ii,CurvePath:B1,CustomBlending:m_,CustomToneMapping:B_,CylinderBufferGeometry:qE,CylinderGeometry:nr,Cylindrical:EE,Data3DTexture:qd,DataArrayTexture:Nc,DataTexture:eo,DataTextureLoader:XA,DataUtils:_v,DecrementStencilOp:gx,DecrementWrapStencilOp:yx,DefaultLoadingManager:r0,DepthFormat:ls,DepthStencilFormat:$s,DepthTexture:A1,DirectionalLight:c0,DirectionalLightHelper:UE,DiscreteInterpolant:i0,DisplayP3ColorSpace:Xd,DodecahedronBufferGeometry:$E,DodecahedronGeometry:Ea,DoubleSide:hi,DstAlphaFactor:b_,DstColorFactor:M_,DynamicCopyUsage:Nx,DynamicDrawUsage:Tx,DynamicReadUsage:Px,EdgesGeometry:k1,EllipseCurve:Hc,EqualCompare:r1,EqualDepth:P_,EqualStencilFunc:bx,EquirectangularReflectionMapping:Ko,EquirectangularRefractionMapping:Jo,Euler:Sa,EventDispatcher:Gi,ExtrudeBufferGeometry:ZE,ExtrudeGeometry:Ta,FileLoader:zi,Float16BufferAttribute:wv,Float32BufferAttribute:je,Float64BufferAttribute:Mv,FloatType:ui,Fog:Bc,FogExp2:Vc,FramebufferTexture:oA,FrontSide:Fi,Frustum:Uc,GLBufferAttribute:wE,GLSL1:Dx,GLSL3:dd,GreaterCompare:a1,GreaterDepth:L_,GreaterEqualCompare:c1,GreaterEqualDepth:I_,GreaterEqualStencilFunc:Ex,GreaterStencilFunc:Mx,GridHelper:OE,Group:Zr,HalfFloatType:so,HemisphereLight:o0,HemisphereLightHelper:NE,HemisphereLightProbe:eE,IcosahedronBufferGeometry:KE,IcosahedronGeometry:Ca,ImageBitmapLoader:JA,ImageLoader:pa,ImageUtils:Yd,IncrementStencilOp:mx,IncrementWrapStencilOp:_x,InstancedBufferAttribute:ao,InstancedBufferGeometry:f0,InstancedInterleavedBuffer:bE,InstancedMesh:N1,Int16BufferAttribute:Sv,Int32BufferAttribute:bv,Int8BufferAttribute:yv,IntType:Fd,InterleavedBuffer:kc,InterleavedBufferAttribute:Zs,Interpolant:Da,InterpolateDiscrete:ta,InterpolateLinear:na,InterpolateSmooth:hc,InvertStencilOp:xx,KeepStencilOp:uc,KeyframeTrack:si,LOD:I1,LatheBufferGeometry:JE,LatheGeometry:po,Layers:Oc,LessCompare:s1,LessDepth:R_,LessEqualCompare:o1,LessEqualDepth:gc,LessEqualStencilFunc:wx,LessStencilFunc:Sx,Light:vs,LightProbe:jc,Line:ms,Line3:CE,LineBasicMaterial:un,LineCurve:Wc,LineCurve3:V1,LineDashedMaterial:e0,LineLoop:O1,LineSegments:yi,LinearEncoding:Wd,LinearFilter:It,LinearInterpolant:pf,LinearMipMapLinearFilter:cx,LinearMipMapNearestFilter:lx,LinearMipmapLinearFilter:ps,LinearMipmapNearestFilter:Ud,LinearSRGBColorSpace:Jn,LinearToneMapping:U_,Loader:On,LoaderUtils:vd,LoadingManager:gf,LoopOnce:Z_,LoopPingPong:J_,LoopRepeat:K_,LuminanceAlphaFormat:X_,LuminanceFormat:W_,MOUSE:tx,Material:tn,MaterialLoader:Yc,MathUtils:$x,Matrix3:lt,Matrix4:rt,MaxEquation:Gu,Mesh:qt,MeshBasicMaterial:ys,MeshDepthMaterial:Jd,MeshDistanceMaterial:Qd,MeshLambertMaterial:J1,MeshMatcapMaterial:Q1,MeshNormalMaterial:K1,MeshPhongMaterial:$1,MeshPhysicalMaterial:q1,MeshStandardMaterial:uf,MeshToonMaterial:Z1,MinEquation:ku,MirroredRepeatWrapping:ea,MixOperation:O_,MultiplyBlending:Bu,MultiplyOperation:va,NearestFilter:Pt,NearestMipMapLinearFilter:ax,NearestMipMapNearestFilter:ox,NearestMipmapLinearFilter:Xo,NearestMipmapNearestFilter:_c,NeverCompare:i1,NeverDepth:T_,NeverStencilFunc:vx,NoBlending:Di,NoColorSpace:hs,NoToneMapping:fi,NormalAnimationBlendMode:Lc,NormalBlending:js,NotEqualCompare:l1,NotEqualDepth:N_,NotEqualStencilFunc:Ax,NumberKeyframeTrack:ua,Object3D:mt,ObjectLoader:ZA,ObjectSpaceNormalMap:t1,OctahedronBufferGeometry:QE,OctahedronGeometry:mo,OneFactor:x_,OneMinusDstAlphaFactor:w_,OneMinusDstColorFactor:A_,OneMinusSrcAlphaFactor:Dd,OneMinusSrcColorFactor:S_,OrthographicCamera:Fc,PCFShadowMap:Nd,PCFSoftShadowMap:p_,PMREMGenerator:pd,Path:aa,PerspectiveCamera:Yt,Plane:ss,PlaneBufferGeometry:eT,PlaneGeometry:uo,PlaneHelper:BE,PointLight:l0,PointLightHelper:IE,Points:D1,PointsMaterial:nf,PolarGridHelper:DE,PolyhedronBufferGeometry:tT,PolyhedronGeometry:Hi,PositionalAudio:oE,PropertyBinding:ft,PropertyMixer:_0,QuadraticBezierCurve:af,QuadraticBezierCurve3:lf,Quaternion:yn,QuaternionKeyframeTrack:_o,QuaternionLinearInterpolant:s0,RED_GREEN_RGTC2_Format:hd,RED_RGTC1_Format:$_,REVISION:Rc,RGBADepthPacking:e1,RGBAFormat:Rn,RGBAIntegerFormat:Gd,RGBA_ASTC_10x10_Format:od,RGBA_ASTC_10x5_Format:id,RGBA_ASTC_10x6_Format:sd,RGBA_ASTC_10x8_Format:rd,RGBA_ASTC_12x10_Format:ad,RGBA_ASTC_12x12_Format:ld,RGBA_ASTC_4x4_Format:$u,RGBA_ASTC_5x4_Format:Zu,RGBA_ASTC_5x5_Format:Ku,RGBA_ASTC_6x5_Format:Ju,RGBA_ASTC_6x6_Format:Qu,RGBA_ASTC_8x5_Format:ed,RGBA_ASTC_8x6_Format:td,RGBA_ASTC_8x8_Format:nd,RGBA_BPTC_Format:cc,RGBA_ETC2_EAC_Format:qu,RGBA_PVRTC_2BPPV1_Format:ju,RGBA_PVRTC_4BPPV1_Format:Xu,RGBA_S3TC_DXT1_Format:oc,RGBA_S3TC_DXT3_Format:ac,RGBA_S3TC_DXT5_Format:lc,RGB_ETC1_Format:q_,RGB_ETC2_Format:Yu,RGB_PVRTC_2BPPV1_Format:Wu,RGB_PVRTC_4BPPV1_Format:Hu,RGB_S3TC_DXT1_Format:rc,RGFormat:Y_,RGIntegerFormat:kd,RawShaderMaterial:Y1,Ray:ho,Raycaster:ME,RectAreaLight:u0,RedFormat:j_,RedIntegerFormat:Bd,ReinhardToneMapping:F_,RepeatWrapping:Qo,ReplaceStencilOp:px,ReverseSubtractEquation:__,RingBufferGeometry:nT,RingGeometry:Ra,SIGNED_RED_GREEN_RGTC2_Format:ud,SIGNED_RED_RGTC1_Format:cd,SRGBColorSpace:ot,Scene:C1,ShaderChunk:at,ShaderLib:Kn,ShaderMaterial:gi,ShadowMaterial:j1,Shape:qs,ShapeBufferGeometry:iT,ShapeGeometry:Pa,ShapePath:HE,ShapeUtils:pi,ShortType:G_,Skeleton:Gc,SkeletonHelper:PE,SkinnedMesh:L1,Source:Hs,Sphere:ni,SphereBufferGeometry:sT,SphereGeometry:go,Spherical:AE,SphericalHarmonics3:d0,SplineCurve:cf,SpotLight:a0,SpotLightHelper:RE,Sprite:P1,SpriteMaterial:ef,SrcAlphaFactor:Od,SrcAlphaSaturateFactor:E_,SrcColorFactor:v_,StaticCopyUsage:Lx,StaticDrawUsage:sa,StaticReadUsage:Rx,StereoCamera:nE,StreamCopyUsage:Ox,StreamDrawUsage:Cx,StreamReadUsage:Ix,StringKeyframeTrack:sr,SubtractEquation:g_,SubtractiveBlending:Vu,TOUCH:nx,TangentSpaceNormalMap:_s,TetrahedronBufferGeometry:rT,TetrahedronGeometry:Ia,Texture:Lt,TextureLoader:jA,TorusBufferGeometry:oT,TorusGeometry:La,TorusKnotBufferGeometry:aT,TorusKnotGeometry:Na,Triangle:Ws,TriangleFanDrawMode:dx,TriangleStripDrawMode:ux,TrianglesDrawMode:hx,TubeBufferGeometry:lT,TubeGeometry:Oa,TwoPassDoubleSide:rx,UVMapping:Pc,Uint16BufferAttribute:$d,Uint32BufferAttribute:Zd,Uint8BufferAttribute:xv,Uint8ClampedBufferAttribute:vv,Uniform:Sf,UniformsGroup:SE,UniformsLib:ze,UniformsUtils:m1,UnsignedByteType:Ui,UnsignedInt248Type:as,UnsignedIntType:Oi,UnsignedShort4444Type:zd,UnsignedShort5551Type:Vd,UnsignedShortType:Ic,VSMShadowMap:li,Vector2:Te,Vector3:F,Vector4:_t,VectorKeyframeTrack:da,VideoTexture:rA,WebGL1Renderer:T1,WebGL3DRenderTarget:ov,WebGLArrayRenderTarget:rv,WebGLCoordinateSystem:di,WebGLCubeRenderTarget:_1,WebGLMultipleRenderTargets:av,WebGLRenderTarget:Qn,WebGLRenderer:E1,WebGLUtils:w1,WebGPUCoordinateSystem:ra,WireframeGeometry:X1,WrapAroundEnding:ia,ZeroCurvatureEnding:ks,ZeroFactor:y_,ZeroSlopeEnding:Gs,ZeroStencilOp:fx,_SRGBAFormat:yc,sRGBEncoding:cs},Symbol.toStringTag,{value:"Module"}));var hT={89:(r=>{var e=(function(){var t=function(se,ae,ge,Fe){for(ge=ge||{},Fe=se.length;Fe--;ge[se[Fe]]=ae);return ge},n=[1,60],i=[1,62],s=[1,63],o=[1,65],a=[1,66],l=[1,67],c=[1,68],h=[1,69],u=[1,80],d=[1,72],f=[1,73],p=[1,74],_=[1,75],g=[1,99],m=[1,76],v=[1,100],y=[1,79],S=[1,51],b=[1,81],M=[1,82],E=[1,84],T=[1,83],w=[1,85],A=[1,96],D=[1,97],k=[1,98],G=[1,86],P=[1,87],N=[1,64],B=[1,70],H=[1,71],W=[1,77],$=[1,78],oe=[1,53],Se=[1,54],K=[1,55],ce=[1,61],Z=[1,88],_e=[1,89],xe=[1,90],Ee=[1,91],Ne=[1,92],Oe=[1,93],Ve=[1,94],De=[1,95],z=[1,101],ye=[1,102],X=[1,103],ie=[1,104],ne=[1,105],Ae=[1,56],Pe=[1,57],Ie=[1,58],Ge=[1,59],Ye=[1,115],et=[1,111],U=[1,114],I=[1,112],fe=[1,113],Ce=[1,118],Re=[1,117],Ue=[1,134],ke=[1,149],C=[1,150],R=[1,157],O=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],j=[5,6,7,9,13,14,15,17,18,19,20,23,25,26,27,30,33,34,35,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,71,72,74,77,78,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,101],q=[5,6,7,9,13,15,17,18,19,20,23,25,26,27,30,33,34,37,38,41,43,45,46,49,52,54,55,56,58,59,62,64,65,66,70,72,82,83,84,85,86,87,88,89,90,91,92,93,94,95],he=[5,70,72],ee=[5,74],we=[71,101],Le={trace:function(){},yy:{},symbols_:{error:2,Program:3,Command:4,EOF:5,RESET:6,BUILD:7,ALL:8,HELP:9,Path:10,MOTM:11,OneArgCommand:12,GET:13,STRING:14,SET:15,Value:16,SET_SAVE:17,SET_RESTORE:18,SET_RESET:19,PRESET:20,AddRepresentation:21,EditRepresentation:22,REMOVE:23,RepresentationReference:24,HIDE:25,SHOW:26,LIST:27,EXPAND_KEY:28,SELECTOR_KEY:29,SELECT:30,AS:31,WordAll:32,SELECTOR:33,WITHIN:34,NUMBER:35,OF:36,MATERIAL:37,IDENTIFIER:38,ModeCMD:39,ColorCMD:40,VIEW:41,BASE_64:42,UNIT:43,DSSP:44,SCALE:45,ROTATE:46,AxesList:47,TRANSLATE:48,CENTER:49,GetURLBranch:50,Screenshot:51,LINE:52,ArgList:53,LISTOBJ:54,REMOVEOBJ:55,URL:56,VIEW_KEY:57,SCREENSHOT:58,LOAD:59,Url:60,FILE_KEY:61,ADD:62,Description:63,REP:64,MODE:65,COLOR:66,Descriptor:67,RepresentationOwnProperty:68,RepresentationOwnPropertyOpts:69,DESC_KEY:70,"=":71,DESC_KEY_OPTS:72,AxesArg:73,DESC_KEY_AXES:74,Arg:75,PathWoDescKey:76,HEX:77,BOOL:78,Word:79,CommandSetWoDESC_KEY:80,DescKeys:81,CLEAR:82,FILE_LIST:83,FILE_REGISTER:84,FILE_DELETE:85,PRESET_ADD:86,PRESET_DELETE:87,PRESET_UPDATE:88,PRESET_RENAME:89,PRESET_OPEN:90,CREATE_SCENARIO:91,RESET_SCENARIO:92,DELETE_SCENARIO:93,ADD_SCENARIO_ITEM:94,LIST_SCENARIO:95,PDB_KEY:96,DELAY_KEY:97,PRST_KEY:98,DESCRIPTION_KEY:99,CommandSet:100,".":101,PresetPath:102,"/":103,HexOrNumber:104,$accept:0,$end:1},terminals_:{2:"error",5:"EOF",6:"RESET",7:"BUILD",8:"ALL",9:"HELP",11:"MOTM",13:"GET",14:"STRING",15:"SET",17:"SET_SAVE",18:"SET_RESTORE",19:"SET_RESET",20:"PRESET",23:"REMOVE",25:"HIDE",26:"SHOW",27:"LIST",28:"EXPAND_KEY",29:"SELECTOR_KEY",30:"SELECT",31:"AS",33:"SELECTOR",34:"WITHIN",35:"NUMBER",36:"OF",37:"MATERIAL",38:"IDENTIFIER",41:"VIEW",42:"BASE_64",43:"UNIT",44:"DSSP",45:"SCALE",46:"ROTATE",48:"TRANSLATE",49:"CENTER",52:"LINE",54:"LISTOBJ",55:"REMOVEOBJ",56:"URL",57:"VIEW_KEY",58:"SCREENSHOT",59:"LOAD",61:"FILE_KEY",62:"ADD",64:"REP",65:"MODE",66:"COLOR",70:"DESC_KEY",71:"=",72:"DESC_KEY_OPTS",74:"DESC_KEY_AXES",77:"HEX",78:"BOOL",82:"CLEAR",83:"FILE_LIST",84:"FILE_REGISTER",85:"FILE_DELETE",86:"PRESET_ADD",87:"PRESET_DELETE",88:"PRESET_UPDATE",89:"PRESET_RENAME",90:"PRESET_OPEN",91:"CREATE_SCENARIO",92:"RESET_SCENARIO",93:"DELETE_SCENARIO",94:"ADD_SCENARIO_ITEM",95:"LIST_SCENARIO",96:"PDB_KEY",97:"DELAY_KEY",98:"PRST_KEY",99:"DESCRIPTION_KEY",101:".",103:"/"},productions_:[0,[3,2],[3,1],[4,1],[4,1],[4,2],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,3],[4,3],[4,1],[4,1],[4,1],[4,1],[4,2],[4,1],[4,1],[4,2],[4,2],[4,2],[4,2],[4,1],[4,2],[4,2],[4,2],[4,4],[4,2],[4,6],[4,2],[4,1],[4,1],[4,1],[4,2],[4,2],[4,1],[4,2],[4,1],[4,2],[4,2],[4,2],[4,1],[4,2],[4,1],[4,1],[4,3],[4,3],[4,4],[4,4],[4,1],[4,2],[50,1],[50,2],[50,2],[50,3],[50,3],[51,1],[51,2],[51,3],[12,2],[12,2],[12,2],[21,1],[21,2],[21,2],[21,3],[22,2],[22,3],[39,2],[39,3],[40,2],[40,3],[24,1],[24,1],[63,1],[63,2],[63,3],[63,4],[67,1],[67,1],[67,2],[68,3],[69,3],[47,1],[47,2],[73,2],[53,1],[53,2],[75,3],[16,1],[16,1],[16,1],[16,1],[16,1],[79,1],[79,1],[32,1],[32,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[80,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[81,1],[100,1],[100,1],[76,1],[76,3],[76,3],[10,1],[10,1],[10,3],[10,3],[10,3],[60,1],[102,1],[102,3],[104,1],[104,1]],performAction:function(ae,ge,Fe,Y,We,J,Qe){var ue=J.length-1;switch(We){case 1:return J[ue-1];case 3:this.$=Y.miew.reset(!1),Y.ClearContext(),Y.miew.resetReps("empty");break;case 4:this.$=Y.miew.rebuild();break;case 5:this.$=Y.miew.rebuildAll(),Y.miew.rebuild();break;case 6:this.$=Y.echo(Y.utils.help().toString());break;case 7:this.$=Y.echo(Y.utils.help(J[ue]).toString());break;case 8:this.$=Y.miew.motm();break;case 10:case 11:this.$=Y.utils.propagateProp(J[ue]),Y.echo(Y.miew.get(J[ue]).toString());break;case 12:case 13:this.$=Y.miew.set(J[ue-1],Y.utils.propagateProp(J[ue-1],J[ue]));break;case 14:this.$=Y.miew.saveSettings();break;case 15:this.$=Y.miew.restoreSettings();break;case 16:this.$=Y.miew.resetSettings();break;case 17:this.$=Y.miew.resetReps();break;case 18:this.$=Y.miew.applyPreset(J[ue]);break;case 21:this.$=Y.miew.repRemove(J[ue]),Y.representations.remove(J[ue]);break;case 22:this.$=Y.miew.repHide(J[ue]);break;case 23:this.$=Y.miew.repHide(J[ue],!1);break;case 24:this.$=Y.echo(Y.utils.listRep(Y.miew,Y.representations,J[ue],"-e"));break;case 25:this.$=Y.echo(Y.utils.list(Y.miew,Y.representations));break;case 26:this.$=Y.echo(Y.utils.list(Y.miew,Y.representations,J[ue]));break;case 27:this.$=Y.echo(Y.utils.listSelector(Y.miew,Y.Context));break;case 28:this.$=Y.miew.select(Y.utils.checkArg(J[ue-1].toLowerCase(),J[ue],!0));break;case 29:this.$=Y.Context[J[ue].toLowerCase()]=Y.utils.checkArg(J[ue-3].toLowerCase(),J[ue-2],!0),Y.miew.select(Y.Context[J[ue].toLowerCase()]);break;case 30:this.$=Y.miew.rep(Y.miew.repCurrent(),{selector:Y.utils.checkArg(J[ue-1].toLowerCase(),J[ue])});break;case 31:this.$=Y.Context[J[ue].toLowerCase()]=Y.miew.within(Y.utils.checkArg("select",J[ue-2],!0),Number(J[ue-4]));break;case 32:this.$=Y.miew.rep(Y.miew.repCurrent(),{material:Y.utils.checkArg(J[ue-1].toLowerCase(),J[ue].toUpperCase())});break;case 35:this.$=Y.echo(Y.miew.view());break;case 36:case 37:this.$=Y.miew.view(J[ue]);break;case 38:this.$=Y.echo(Y.miew.changeUnit());break;case 39:this.$=Y.echo(Y.miew.changeUnit(J[ue]));break;case 40:this.$=Y.miew.dssp();break;case 41:this.$=Y.miew.scale(J[ue]);break;case 42:for(var it=0,Xt=J[ue].length;it<Xt;it++)Y.miew.rotate(J[ue][it].x*Math.PI/180,J[ue][it].y*Math.PI/180,J[ue][it].z*Math.PI/180);break;case 43:for(var it=0,Xt=J[ue].length;it<Xt;it++)Y.miew.translate(J[ue][it].x||0,J[ue][it].y||0,J[ue][it].z||0);break;case 44:this.$=Y.miew.center();break;case 45:this.$=Y.miew.center(J[ue]);break;case 48:case 49:this.$=Y.miew.addObject({type:"line",params:[J[ue-1],J[ue]]},!0);break;case 50:case 51:this.$=Y.miew.addObject({type:"line",params:[J[ue-2],J[ue-1]],opts:J[ue].toJSO(Y.utils,"objects","line")},!0);break;case 52:this.$=Y.echo(Y.utils.listObjs(Y.miew));break;case 53:this.$=Y.miew.removeObject(J[ue]);break;case 54:this.$=Y.echo(Y.miew.getURL({view:!1,settings:!1}));break;case 55:this.$=Y.echo(Y.miew.getURL({view:!1,settings:!0}));break;case 56:this.$=Y.echo(Y.miew.getURL({view:!0,settings:!1}));break;case 57:case 58:this.$=Y.echo(Y.miew.getURL({view:!0,settings:!0}));break;case 59:this.$=Y.miew.screenshotSave();break;case 60:this.$=Y.miew.screenshotSave("",Number(J[ue]));break;case 61:this.$=Y.miew.screenshotSave("",Number(J[ue-1]),Number(J[ue]));break;case 62:case 63:case 64:this.$=Y.utils.load(Y.miew,J[ue]),Y.representations.clear();break;case 65:this.$=Y.echo(Y.representations.add(Y.miew.repAdd()));break;case 66:this.$=Y.echo(Y.representations.add(J[ue],Y.miew.repAdd()));break;case 67:this.$=Y.echo(Y.representations.add(Y.miew.repAdd(J[ue])));break;case 68:this.$=Y.echo(Y.representations.add(J[ue-1],Y.miew.repAdd(J[ue])));break;case 69:this.$=Y.miew.rep(J[ue]),Y.miew.repCurrent(J[ue]);break;case 70:this.$=Y.miew.rep(J[ue-1],J[ue]),Y.miew.repCurrent(J[ue-1]);break;case 71:this.$=Y.miew.rep(Y.miew.repCurrent(),{mode:Y.utils.checkArg(J[ue-1].toLowerCase(),J[ue].toUpperCase())});break;case 72:this.$=Y.miew.rep(Y.miew.repCurrent(),{mode:new Array(Y.utils.checkArg(J[ue-2].toLowerCase(),J[ue-1].toUpperCase()),J[ue].toJSO(Y.utils,J[ue-2],J[ue-1].toUpperCase()))});break;case 73:this.$=Y.miew.rep(Y.miew.repCurrent(),{colorer:Y.utils.checkArg(J[ue-1].toLowerCase(),J[ue].toUpperCase())});break;case 74:this.$=Y.miew.rep(Y.miew.repCurrent(),{colorer:new Array(Y.utils.checkArg(J[ue-2].toLowerCase(),J[ue-1].toUpperCase()),J[ue].toJSO(Y.utils,J[ue-2],J[ue-1].toUpperCase()))});break;case 75:this.$=Number(Y.representations.get(J[ue]));break;case 76:case 92:this.$=Number(J[ue]);break;case 77:this.$=J[ue];break;case 78:this.$=Y._.assign(J[ue-1],J[ue]);break;case 79:this.$=Y._.assign(J[ue-2],J[ue-1],J[ue]);break;case 80:this.$=Y._.assign(J[ue-3],J[ue-2],J[ue-1],J[ue]);break;case 81:case 82:this.$=Y.CreateObjectPair(J[ue].key,J[ue].val);break;case 83:this.$=Y.CreateObjectPair(J[ue-1].key,new Array(J[ue-1].val,J[ue].toJSO(Y.utils,J[ue-1].key,J[ue-1].val)));break;case 84:case 85:this.$=Object.create({key:Y.keyRemap(J[ue-2]),val:Y.utils.checkArg(J[ue-2],J[ue])});break;case 86:this.$=[J[ue]];break;case 87:this.$=J[ue-1].concat(J[ue]);break;case 88:this.$=Y.CreateObjectPair(J[ue-1].toLowerCase(),Number(J[ue]));break;case 89:this.$=new Y.ArgList(J[ue]);break;case 90:this.$=J[ue-1].append(J[ue]);break;case 91:this.$=new Y.Arg(J[ue-2],J[ue]);break;case 93:this.$=parseInt(J[ue]);break;case 94:this.$=JSON.parse(J[ue]);break;case 95:case 96:this.$=String(J[ue]);break;case 157:case 158:case 161:case 162:case 163:this.$=J[ue-2]+J[ue-1]+J[ue];break;case 166:this.$=J[ue-2]=J[ue-2]+J[ue-1]+J[ue];break}},table:[{3:1,4:2,5:[1,3],6:[1,4],7:[1,5],9:[1,6],11:[1,7],12:8,13:[1,9],15:[1,10],17:[1,11],18:[1,12],19:[1,13],20:[1,14],21:15,22:16,23:[1,17],25:[1,18],26:[1,19],27:[1,20],30:[1,21],33:[1,22],34:[1,23],37:[1,24],39:25,40:26,41:[1,27],43:[1,28],44:[1,29],45:[1,30],46:[1,31],48:[1,32],49:[1,33],50:34,51:35,52:[1,36],54:[1,37],55:[1,38],56:[1,44],58:[1,45],59:[1,39],62:[1,40],64:[1,41],65:[1,42],66:[1,43]},{1:[3]},{5:[1,46]},{1:[2,2]},{5:[2,3]},{5:[2,4],8:[1,47]},{5:[2,6],6:n,7:i,9:s,10:48,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:49,80:52,81:50,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{5:[2,8]},{5:[2,9]},{6:n,7:i,9:s,10:106,13:o,14:[1,107],15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:49,80:52,81:50,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{6:n,7:i,9:s,10:108,13:o,14:[1,109],15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:49,80:52,81:50,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{5:[2,14]},{5:[2,15]},{5:[2,16]},{5:[2,17],14:Ye,16:110,35:et,38:U,77:I,78:fe},{5:[2,19]},{5:[2,20]},{24:116,35:Ce,38:Re},{24:119,35:Ce,38:Re},{24:120,35:Ce,38:Re},{5:[2,25],24:121,28:[1,122],29:[1,123],35:Ce,38:Re},{14:[1,124]},{14:[1,125]},{35:[1,126]},{38:[1,127]},{5:[2,33]},{5:[2,34]},{5:[2,35],14:[1,128],42:[1,129]},{5:[2,38],35:[1,130]},{5:[2,40]},{35:[1,131]},{47:132,73:133,74:Ue},{47:135,73:133,74:Ue},{5:[2,44],14:[1,136]},{5:[2,46]},{5:[2,47]},{6:n,7:i,9:s,10:138,13:o,14:[1,137],15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:49,80:52,81:50,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{5:[2,52]},{35:[1,139]},{14:[1,143],38:[1,141],60:140,61:[1,142]},{5:[2,65],38:[1,144],63:145,67:146,68:147,69:148,70:ke,72:C},{24:151,35:Ce,38:Re},{38:[1,152]},{38:[1,153]},{5:[2,54],29:[1,154],57:[1,155]},{5:[2,59],35:[1,156]},{1:[2,1]},{5:[2,5]},{5:[2,7],101:R},t(O,[2,159]),t(O,[2,160]),t(j,[2,97]),t(j,[2,98]),t(O,[2,147]),t(O,[2,148]),t(O,[2,149]),t(O,[2,150]),t(O,[2,151]),t(O,[2,152]),t(O,[2,153]),t(j,[2,101]),t(j,[2,102]),t(j,[2,103]),t(j,[2,104]),t(j,[2,105]),t(j,[2,106]),t(j,[2,107]),t(j,[2,108]),t(j,[2,109]),t(j,[2,110]),t(j,[2,111]),t(j,[2,112]),t(j,[2,113]),t(j,[2,114]),t(j,[2,115]),t(j,[2,116]),t(j,[2,117]),t(j,[2,118]),t(j,[2,119]),t(j,[2,120]),t(j,[2,121]),t(j,[2,122]),t(j,[2,123]),t(j,[2,124]),t(j,[2,125]),t(j,[2,126]),t(j,[2,127]),t(j,[2,128]),t(j,[2,129]),t(j,[2,130]),t(j,[2,131]),t(j,[2,132]),t(j,[2,133]),t(j,[2,134]),t(j,[2,135]),t(j,[2,136]),t(j,[2,137]),t(j,[2,138]),t(j,[2,139]),t(j,[2,140]),t(j,[2,141]),t(j,[2,142]),t(j,[2,143]),t(j,[2,144]),t(j,[2,145]),t(j,[2,146]),{5:[2,10],101:R},{5:[2,11]},{14:Ye,16:158,35:et,38:U,77:I,78:fe,101:R},{14:Ye,16:159,35:et,38:U,77:I,78:fe},{5:[2,18]},t(q,[2,92]),t(q,[2,93]),t(q,[2,94]),t(q,[2,95]),t(q,[2,96]),{5:[2,21]},t(he,[2,75]),t(he,[2,76]),{5:[2,22]},{5:[2,23]},{5:[2,24]},{5:[2,26]},{5:[2,27]},{5:[2,28],31:[1,160]},{5:[2,30]},{36:[1,161]},{5:[2,32]},{5:[2,36]},{5:[2,37]},{5:[2,39]},{5:[2,41]},{5:[2,42],73:162,74:Ue},t(ee,[2,86]),{35:[1,163]},{5:[2,43],73:162,74:Ue},{5:[2,45]},{14:[1,164]},{6:n,7:i,9:s,10:165,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:49,80:52,81:50,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge,101:R},{5:[2,53]},{5:[2,62]},{5:[2,63]},{5:[2,64]},{5:[2,164]},{5:[2,66],63:166,67:146,68:147,69:148,70:ke,72:C},{5:[2,67]},{5:[2,77],67:167,68:147,69:148,70:ke,72:C},t(he,[2,81]),t(he,[2,82],{80:52,53:168,75:169,76:170,79:171,6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne}),{71:[1,172]},{71:[1,173]},{5:[2,69],63:174,67:146,68:147,69:148,70:ke,72:C},{5:[2,71],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,53:175,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:169,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,73],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,53:176,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:169,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,55],57:[1,177]},{5:[2,56],29:[1,178]},{5:[2,60],35:[1,179]},{6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,35:[1,181],37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:180,80:52,81:182,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{5:[2,12]},{5:[2,13]},{6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,32:183,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:184,80:52,81:185,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{14:[1,186]},t(ee,[2,87]),t(ee,[2,88]),{5:[2,48],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,53:187,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:169,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,49],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,53:188,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:169,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,101:R},{5:[2,68]},{5:[2,78],67:189,68:147,69:148,70:ke,72:C},t(he,[2,83],{80:52,76:170,79:171,75:190,6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne}),t(q,[2,89]),{71:[1,191],101:[1,192]},t(we,[2,156]),{14:Ye,16:193,35:et,38:U,77:I,78:fe},{14:Ye,16:194,35:et,38:U,77:I,78:fe},{5:[2,70]},{5:[2,72],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:190,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,74],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:190,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,57]},{5:[2,58]},{5:[2,61]},t(O,[2,161]),t(O,[2,162]),t(O,[2,163]),{5:[2,29]},{5:[2,99]},{5:[2,100]},{31:[1,195]},{5:[2,50],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:190,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,51],6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,75:190,76:170,79:171,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},{5:[2,79],67:196,68:147,69:148,70:ke,72:C},t(q,[2,90]),{14:Ye,16:197,35:et,38:U,77:I,78:fe},{6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,33:m,34:v,35:[1,199],37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,79:198,80:52,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne},t(he,[2,84]),t(q,[2,85]),{6:n,7:i,9:s,13:o,15:a,17:l,18:c,19:h,20:u,23:d,25:f,26:p,27:_,30:g,32:200,33:m,34:v,37:y,38:S,41:b,43:M,45:E,46:T,49:w,52:A,54:D,55:k,56:G,58:P,59:N,62:B,64:H,65:W,66:$,70:oe,72:Se,74:K,79:184,80:52,81:185,82:ce,83:Z,84:_e,85:xe,86:Ee,87:Ne,88:Oe,89:Ve,90:De,91:z,92:ye,93:X,94:ie,95:ne,96:Ae,97:Pe,98:Ie,99:Ge},{5:[2,80]},t(q,[2,91]),t(we,[2,157]),t(we,[2,158]),{5:[2,31]}],defaultActions:{3:[2,2],4:[2,3],7:[2,8],8:[2,9],11:[2,14],12:[2,15],13:[2,16],15:[2,19],16:[2,20],25:[2,33],26:[2,34],29:[2,40],34:[2,46],35:[2,47],37:[2,52],46:[2,1],47:[2,5],107:[2,11],110:[2,18],116:[2,21],119:[2,22],120:[2,23],121:[2,24],122:[2,26],123:[2,27],125:[2,30],127:[2,32],128:[2,36],129:[2,37],130:[2,39],131:[2,41],136:[2,45],139:[2,53],140:[2,62],141:[2,63],142:[2,64],143:[2,164],145:[2,67],158:[2,12],159:[2,13],166:[2,68],174:[2,70],177:[2,57],178:[2,58],179:[2,61],183:[2,29],184:[2,99],185:[2,100],196:[2,80],200:[2,31]},parseError:function(ae,ge){if(ge.recoverable)this.trace(ae);else{var Fe=new Error(ae);throw Fe.hash=ge,Fe}},parse:function(ae){var ge=this,Fe=[0],Y=[],We=[null],J=[],Qe=this.table,ue="",it=0,Xt=0,$t=2,Fn=1,Zt=J.slice.call(arguments,1),xt=Object.create(this.lexer),kt={yy:{}};for(var vi in this.yy)Object.prototype.hasOwnProperty.call(this.yy,vi)&&(kt.yy[vi]=this.yy[vi]);xt.setInput(ae,kt.yy),kt.yy.lexer=xt,kt.yy.parser=this,typeof xt.yylloc>"u"&&(xt.yylloc={});var Wi=xt.yylloc;J.push(Wi);var Xi=xt.options&&xt.options.ranges;typeof kt.yy.parseError=="function"?this.parseError=kt.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;function ur(){var qe;return qe=Y.pop()||xt.lex()||Fn,typeof qe!="number"&&(qe instanceof Array&&(Y=qe,qe=Y.pop()),qe=ge.symbols_[qe]||qe),qe}for(var L,re,me,Q,pe={},Be,Xe,Ze,$e;;){if(re=Fe[Fe.length-1],this.defaultActions[re]?me=this.defaultActions[re]:((L===null||typeof L>"u")&&(L=ur()),me=Qe[re]&&Qe[re][L]),typeof me>"u"||!me.length||!me[0]){var tt="";$e=[];for(Be in Qe[re])this.terminals_[Be]&&Be>$t&&$e.push("'"+this.terminals_[Be]+"'");xt.showPosition?tt="Parse error on line "+(it+1)+`:
`+xt.showPosition()+`
Expecting `+$e.join(", ")+", got '"+(this.terminals_[L]||L)+"'":tt="Parse error on line "+(it+1)+": Unexpected "+(L==Fn?"end of input":"'"+(this.terminals_[L]||L)+"'"),this.parseError(tt,{text:xt.match,token:this.terminals_[L]||L,line:xt.yylineno,loc:Wi,expected:$e})}if(me[0]instanceof Array&&me.length>1)throw new Error("Parse Error: multiple actions possible at state: "+re+", token: "+L);switch(me[0]){case 1:Fe.push(L),We.push(xt.yytext),J.push(xt.yylloc),Fe.push(me[1]),L=null,Xt=xt.yyleng,ue=xt.yytext,it=xt.yylineno,Wi=xt.yylloc;break;case 2:if(Xe=this.productions_[me[1]][1],pe.$=We[We.length-Xe],pe._$={first_line:J[J.length-(Xe||1)].first_line,last_line:J[J.length-1].last_line,first_column:J[J.length-(Xe||1)].first_column,last_column:J[J.length-1].last_column},Xi&&(pe._$.range=[J[J.length-(Xe||1)].range[0],J[J.length-1].range[1]]),Q=this.performAction.apply(pe,[ue,Xt,it,kt.yy,me[1],We,J].concat(Zt)),typeof Q<"u")return Q;Xe&&(Fe=Fe.slice(0,-1*Xe*2),We=We.slice(0,-1*Xe),J=J.slice(0,-1*Xe)),Fe.push(this.productions_[me[1]][0]),We.push(pe.$),J.push(pe._$),Ze=Qe[Fe[Fe.length-2]][Fe[Fe.length-1]],Fe.push(Ze);break;case 3:return!0}}return!0}},V=(function(){var se={EOF:1,parseError:function(ge,Fe){if(this.yy.parser)this.yy.parser.parseError(ge,Fe);else throw new Error(ge)},setInput:function(ae,ge){return this.yy=ge||this.yy||{},this._input=ae,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var ae=this._input[0];this.yytext+=ae,this.yyleng++,this.offset++,this.match+=ae,this.matched+=ae;var ge=ae.match(/(?:\r\n?|\n).*/g);return ge?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),ae},unput:function(ae){var ge=ae.length,Fe=ae.split(/(?:\r\n?|\n)/g);this._input=ae+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-ge),this.offset-=ge;var Y=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),Fe.length-1&&(this.yylineno-=Fe.length-1);var We=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:Fe?(Fe.length===Y.length?this.yylloc.first_column:0)+Y[Y.length-Fe.length].length-Fe[0].length:this.yylloc.first_column-ge},this.options.ranges&&(this.yylloc.range=[We[0],We[0]+this.yyleng-ge]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){if(this.options.backtrack_lexer)this._backtrack=!0;else return this.parseError("Lexical error on line "+(this.yylineno+1)+`. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
`+this.showPosition(),{text:"",token:null,line:this.yylineno});return this},less:function(ae){this.unput(this.match.slice(ae))},pastInput:function(){var ae=this.matched.substr(0,this.matched.length-this.match.length);return(ae.length>20?"...":"")+ae.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var ae=this.match;return ae.length<20&&(ae+=this._input.substr(0,20-ae.length)),(ae.substr(0,20)+(ae.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var ae=this.pastInput(),ge=new Array(ae.length+1).join("-");return ae+this.upcomingInput()+`
`+ge+"^"},test_match:function(ae,ge){var Fe,Y,We;if(this.options.backtrack_lexer&&(We={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(We.yylloc.range=this.yylloc.range.slice(0))),Y=ae[0].match(/(?:\r\n?|\n).*/g),Y&&(this.yylineno+=Y.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:Y?Y[Y.length-1].length-Y[Y.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+ae[0].length},this.yytext+=ae[0],this.match+=ae[0],this.matches=ae,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(ae[0].length),this.matched+=ae[0],Fe=this.performAction.call(this,this.yy,this,ge,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),Fe)return Fe;if(this._backtrack){for(var J in We)this[J]=We[J];return!1}return!1},next:function(){if(this.done)return this.EOF;this._input||(this.done=!0);var ae,ge,Fe,Y;this._more||(this.yytext="",this.match="");for(var We=this._currentRules(),J=0;J<We.length;J++)if(Fe=this._input.match(this.rules[We[J]]),Fe&&(!ge||Fe[0].length>ge[0].length)){if(ge=Fe,Y=J,this.options.backtrack_lexer){if(ae=this.test_match(Fe,We[J]),ae!==!1)return ae;if(this._backtrack){ge=!1;continue}else return!1}else if(!this.options.flex)break}return ge?(ae=this.test_match(ge,We[Y]),ae!==!1?ae:!1):this._input===""?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+`. Unrecognized text.
`+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var ge=this.next();return ge||this.lex()},begin:function(ge){this.conditionStack.push(ge)},popState:function(){var ge=this.conditionStack.length-1;return ge>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(ge){return ge=this.conditionStack.length-1-Math.abs(ge||0),ge>=0?this.conditionStack[ge]:"INITIAL"},pushState:function(ge){this.begin(ge)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(ge,Fe,Y,We){switch(Y){case 0:break;case 1:return"";case 2:return"";case 3:return 42;case 4:return 35;case 5:return 77;case 6:return 78;case 7:return 78;case 8:return 8;case 9:return 6;case 10:return 82;case 11:return 7;case 12:return 9;case 13:return 59;case 14:return 13;case 15:return 15;case 16:return 17;case 17:return 18;case 18:return 19;case 19:return 20;case 20:return 11;case 21:return 62;case 22:return 64;case 23:return 23;case 24:return 25;case 25:return 26;case 26:return 27;case 27:return 30;case 28:return 34;case 29:return 33;case 30:return 65;case 31:return 66;case 32:return 37;case 33:return 41;case 34:return 43;case 35:return 52;case 36:return 54;case 37:return 55;case 38:return 46;case 39:return 48;case 40:return 45;case 41:return 49;case 42:return 56;case 43:return 58;case 44:return 44;case 45:return 83;case 46:return 84;case 47:return 85;case 48:return 86;case 49:return 87;case 50:return 88;case 51:return 89;case 52:return 90;case 53:return 91;case 54:return 92;case 55:return 93;case 56:return 94;case 57:return 95;case 58:return 70;case 59:return 70;case 60:return 72;case 61:return 72;case 62:return 74;case 63:return 74;case 64:return 74;case 65:return 31;case 66:return 36;case 67:return 96;case 68:return 97;case 69:return 98;case 70:return 99;case 71:return Fe.yytext=ge.utils.unquoteString(Fe.yytext),14;case 72:return 38;case 73:return 5;case 74:return 101;case 75:return 103;case 76:return"\\";case 77:return 28;case 78:return 61;case 79:return 29;case 80:return 57;case 81:return 71}},rules:[/^(?:\s+)/i,/^(?:[#].*)/i,/^(?:\/\/.*)/i,/^(?:([_A-Z0-9\/\+]+==))/i,/^(?:-?[0-9]+(\.[0-9]+)?\b)/i,/^(?:0[xX][0-9A-F]+\b)/i,/^(?:false\b)/i,/^(?:true\b)/i,/^(?:all\b)/i,/^(?:reset\b)/i,/^(?:clear\b)/i,/^(?:build\b)/i,/^(?:help\b)/i,/^(?:load\b)/i,/^(?:get\b)/i,/^(?:set\b)/i,/^(?:set_save\b)/i,/^(?:set_restore\b)/i,/^(?:set_reset\b)/i,/^(?:preset\b)/i,/^(?:motm\b)/i,/^(?:add\b)/i,/^(?:rep\b)/i,/^(?:remove\b)/i,/^(?:hide\b)/i,/^(?:show\b)/i,/^(?:list\b)/i,/^(?:select\b)/i,/^(?:within\b)/i,/^(?:selector\b)/i,/^(?:mode\b)/i,/^(?:color\b)/i,/^(?:material\b)/i,/^(?:view\b)/i,/^(?:unit\b)/i,/^(?:line\b)/i,/^(?:listobj\b)/i,/^(?:removeobj\b)/i,/^(?:rotate\b)/i,/^(?:translate\b)/i,/^(?:scale\b)/i,/^(?:center\b)/i,/^(?:url\b)/i,/^(?:screenshot\b)/i,/^(?:dssp\b)/i,/^(?:file_list\b)/i,/^(?:file_register\b)/i,/^(?:file_delete\b)/i,/^(?:preset_add\b)/i,/^(?:preset_delete\b)/i,/^(?:preset_update\b)/i,/^(?:preset_rename\b)/i,/^(?:preset_open\b)/i,/^(?:create_scenario\b)/i,/^(?:reset_scenario\b)/i,/^(?:delete_scenario\b)/i,/^(?:add_scenario_item\b)/i,/^(?:list_scenario\b)/i,/^(?:s\b)/i,/^(?:mt\b)/i,/^(?:m\b)/i,/^(?:c\b)/i,/^(?:x\b)/i,/^(?:y\b)/i,/^(?:z\b)/i,/^(?:as\b)/i,/^(?:of\b)/i,/^(?:pdb\b)/i,/^(?:delay\b)/i,/^(?:prst\b)/i,/^(?:desc\b)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:\.)/i,/^(?:\/)/i,/^(?:\\)/i,/^(?:-e\b)/i,/^(?:-f\b)/i,/^(?:-s\b)/i,/^(?:-v\b)/i,/^(?:=)/i],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81],inclusive:!0}}};return se})();Le.lexer=V;function Me(){this.yy={}}return Me.prototype=Le,Le.Parser=Me,new Me})();r.exports={parser:e}}),99:(r=>{var e=(function(){var t=function(S,b,M,E){for(M=M||{},E=S.length;E--;M[S[E]]=b);return M},n=[1,4],i=[1,5],s=[1,6],o=[1,7],a=[1,8],l=[1,9],c=[1,11],h=[1,12],u=[5,7,8,11],d=[1,17],f=[1,22],p=[1,20],_=[1,21],g=[5,7,8,11,19],m={trace:function(){},yy:{},symbols_:{error:2,Program:3,Expression:4,EOF:5,Selector:6,OR:7,AND:8,NOT:9,"(":10,")":11,SELECTOR:12,NAMED_SELECTOR:13,SELECTOR_RANGED:14,RangeList:15,SELECTOR_NAMED:16,NameList:17,Range:18,",":19,NUMBER:20,":":21,Name:22,IDENTIFIER:23,STRING:24,$accept:0,$end:1},terminals_:{2:"error",5:"EOF",7:"OR",8:"AND",9:"NOT",10:"(",11:")",12:"SELECTOR",13:"NAMED_SELECTOR",14:"SELECTOR_RANGED",16:"SELECTOR_NAMED",19:",",20:"NUMBER",21:":",23:"IDENTIFIER",24:"STRING"},productions_:[0,[3,2],[4,1],[4,3],[4,3],[4,2],[4,3],[6,1],[6,1],[6,2],[6,2],[15,1],[15,3],[18,1],[18,3],[17,1],[17,3],[22,1],[22,1],[22,1]],performAction:function(b,M,E,T,w,A,D){var k=A.length-1;switch(w){case 1:return A[k-1];case 3:this.$=T.keyword("or")(A[k-2],A[k]);break;case 4:this.$=T.keyword("and")(A[k-2],A[k]);break;case 5:this.$=T.keyword("not")(A[k]);break;case 6:this.$=A[k-1];break;case 7:this.$=T.keyword(A[k])();break;case 8:this.$=T.GetSelector(A[k].toLowerCase().slice(1,A[k].length));break;case 9:case 10:this.$=T.keyword(A[k-1])(A[k]);break;case 11:this.$=new T.RangeList(A[k]);break;case 12:case 16:this.$=A[k-2].append(A[k]);break;case 13:this.$=new T.Range(Number(A[k]));break;case 14:this.$=new T.Range(Number(A[k-2]),Number(A[k]));break;case 15:this.$=new T.ValueList(A[k]);break}},table:[{3:1,4:2,6:3,9:n,10:i,12:s,13:o,14:a,16:l},{1:[3]},{5:[1,10],7:c,8:h},t(u,[2,2]),{4:13,6:3,9:n,10:i,12:s,13:o,14:a,16:l},{4:14,6:3,9:n,10:i,12:s,13:o,14:a,16:l},t(u,[2,7]),t(u,[2,8]),{15:15,18:16,20:d},{17:18,20:f,22:19,23:p,24:_},{1:[2,1]},{4:23,6:3,9:n,10:i,12:s,13:o,14:a,16:l},{4:24,6:3,9:n,10:i,12:s,13:o,14:a,16:l},t(u,[2,5]),{7:c,8:h,11:[1,25]},t(u,[2,9],{19:[1,26]}),t(g,[2,11]),t(g,[2,13],{21:[1,27]}),t(u,[2,10],{19:[1,28]}),t(g,[2,15]),t(g,[2,17]),t(g,[2,18]),t(g,[2,19]),t([5,7,11],[2,3],{8:h}),t(u,[2,4]),t(u,[2,6]),{18:29,20:d},{20:[1,30]},{20:f,22:31,23:p,24:_},t(g,[2,12]),t(g,[2,14]),t(g,[2,16])],defaultActions:{10:[2,1]},parseError:function(b,M){if(M.recoverable)this.trace(b);else{var E=new Error(b);throw E.hash=M,E}},parse:function(b){var M=this,E=[0],T=[],w=[null],A=[],D=this.table,k="",G=0,P=0,N=2,B=1,H=A.slice.call(arguments,1),W=Object.create(this.lexer),$={yy:{}};for(var oe in this.yy)Object.prototype.hasOwnProperty.call(this.yy,oe)&&($.yy[oe]=this.yy[oe]);W.setInput(b,$.yy),$.yy.lexer=W,$.yy.parser=this,typeof W.yylloc>"u"&&(W.yylloc={});var Se=W.yylloc;A.push(Se);var K=W.options&&W.options.ranges;typeof $.yy.parseError=="function"?this.parseError=$.yy.parseError:this.parseError=Object.getPrototypeOf(this).parseError;function ce(){var X;return X=T.pop()||W.lex()||B,typeof X!="number"&&(X instanceof Array&&(T=X,X=T.pop()),X=M.symbols_[X]||X),X}for(var Z,_e,xe,Ee,Ne={},Oe,Ve,De,z;;){if(_e=E[E.length-1],this.defaultActions[_e]?xe=this.defaultActions[_e]:((Z===null||typeof Z>"u")&&(Z=ce()),xe=D[_e]&&D[_e][Z]),typeof xe>"u"||!xe.length||!xe[0]){var ye="";z=[];for(Oe in D[_e])this.terminals_[Oe]&&Oe>N&&z.push("'"+this.terminals_[Oe]+"'");W.showPosition?ye="Parse error on line "+(G+1)+`:
`+W.showPosition()+`
Expecting `+z.join(", ")+", got '"+(this.terminals_[Z]||Z)+"'":ye="Parse error on line "+(G+1)+": Unexpected "+(Z==B?"end of input":"'"+(this.terminals_[Z]||Z)+"'"),this.parseError(ye,{text:W.match,token:this.terminals_[Z]||Z,line:W.yylineno,loc:Se,expected:z})}if(xe[0]instanceof Array&&xe.length>1)throw new Error("Parse Error: multiple actions possible at state: "+_e+", token: "+Z);switch(xe[0]){case 1:E.push(Z),w.push(W.yytext),A.push(W.yylloc),E.push(xe[1]),Z=null,P=W.yyleng,k=W.yytext,G=W.yylineno,Se=W.yylloc;break;case 2:if(Ve=this.productions_[xe[1]][1],Ne.$=w[w.length-Ve],Ne._$={first_line:A[A.length-(Ve||1)].first_line,last_line:A[A.length-1].last_line,first_column:A[A.length-(Ve||1)].first_column,last_column:A[A.length-1].last_column},K&&(Ne._$.range=[A[A.length-(Ve||1)].range[0],A[A.length-1].range[1]]),Ee=this.performAction.apply(Ne,[k,P,G,$.yy,xe[1],w,A].concat(H)),typeof Ee<"u")return Ee;Ve&&(E=E.slice(0,-1*Ve*2),w=w.slice(0,-1*Ve),A=A.slice(0,-1*Ve)),E.push(this.productions_[xe[1]][0]),w.push(Ne.$),A.push(Ne._$),De=D[E[E.length-2]][E[E.length-1]],E.push(De);break;case 3:return!0}}return!0}},v=(function(){var S={EOF:1,parseError:function(M,E){if(this.yy.parser)this.yy.parser.parseError(M,E);else throw new Error(M)},setInput:function(b,M){return this.yy=M||this.yy||{},this._input=b,this._more=this._backtrack=this.done=!1,this.yylineno=this.yyleng=0,this.yytext=this.matched=this.match="",this.conditionStack=["INITIAL"],this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0},this.options.ranges&&(this.yylloc.range=[0,0]),this.offset=0,this},input:function(){var b=this._input[0];this.yytext+=b,this.yyleng++,this.offset++,this.match+=b,this.matched+=b;var M=b.match(/(?:\r\n?|\n).*/g);return M?(this.yylineno++,this.yylloc.last_line++):this.yylloc.last_column++,this.options.ranges&&this.yylloc.range[1]++,this._input=this._input.slice(1),b},unput:function(b){var M=b.length,E=b.split(/(?:\r\n?|\n)/g);this._input=b+this._input,this.yytext=this.yytext.substr(0,this.yytext.length-M),this.offset-=M;var T=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1),this.matched=this.matched.substr(0,this.matched.length-1),E.length-1&&(this.yylineno-=E.length-1);var w=this.yylloc.range;return this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:E?(E.length===T.length?this.yylloc.first_column:0)+T[T.length-E.length].length-E[0].length:this.yylloc.first_column-M},this.options.ranges&&(this.yylloc.range=[w[0],w[0]+this.yyleng-M]),this.yyleng=this.yytext.length,this},more:function(){return this._more=!0,this},reject:function(){if(this.options.backtrack_lexer)this._backtrack=!0;else return this.parseError("Lexical error on line "+(this.yylineno+1)+`. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
`+this.showPosition(),{text:"",token:null,line:this.yylineno});return this},less:function(b){this.unput(this.match.slice(b))},pastInput:function(){var b=this.matched.substr(0,this.matched.length-this.match.length);return(b.length>20?"...":"")+b.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var b=this.match;return b.length<20&&(b+=this._input.substr(0,20-b.length)),(b.substr(0,20)+(b.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var b=this.pastInput(),M=new Array(b.length+1).join("-");return b+this.upcomingInput()+`
`+M+"^"},test_match:function(b,M){var E,T,w;if(this.options.backtrack_lexer&&(w={yylineno:this.yylineno,yylloc:{first_line:this.yylloc.first_line,last_line:this.last_line,first_column:this.yylloc.first_column,last_column:this.yylloc.last_column},yytext:this.yytext,match:this.match,matches:this.matches,matched:this.matched,yyleng:this.yyleng,offset:this.offset,_more:this._more,_input:this._input,yy:this.yy,conditionStack:this.conditionStack.slice(0),done:this.done},this.options.ranges&&(w.yylloc.range=this.yylloc.range.slice(0))),T=b[0].match(/(?:\r\n?|\n).*/g),T&&(this.yylineno+=T.length),this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:T?T[T.length-1].length-T[T.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+b[0].length},this.yytext+=b[0],this.match+=b[0],this.matches=b,this.yyleng=this.yytext.length,this.options.ranges&&(this.yylloc.range=[this.offset,this.offset+=this.yyleng]),this._more=!1,this._backtrack=!1,this._input=this._input.slice(b[0].length),this.matched+=b[0],E=this.performAction.call(this,this.yy,this,M,this.conditionStack[this.conditionStack.length-1]),this.done&&this._input&&(this.done=!1),E)return E;if(this._backtrack){for(var A in w)this[A]=w[A];return!1}return!1},next:function(){if(this.done)return this.EOF;this._input||(this.done=!0);var b,M,E,T;this._more||(this.yytext="",this.match="");for(var w=this._currentRules(),A=0;A<w.length;A++)if(E=this._input.match(this.rules[w[A]]),E&&(!M||E[0].length>M[0].length)){if(M=E,T=A,this.options.backtrack_lexer){if(b=this.test_match(E,w[A]),b!==!1)return b;if(this._backtrack){M=!1;continue}else return!1}else if(!this.options.flex)break}return M?(b=this.test_match(M,w[T]),b!==!1?b:!1):this._input===""?this.EOF:this.parseError("Lexical error on line "+(this.yylineno+1)+`. Unrecognized text.
`+this.showPosition(),{text:"",token:null,line:this.yylineno})},lex:function(){var M=this.next();return M||this.lex()},begin:function(M){this.conditionStack.push(M)},popState:function(){var M=this.conditionStack.length-1;return M>0?this.conditionStack.pop():this.conditionStack[0]},_currentRules:function(){return this.conditionStack.length&&this.conditionStack[this.conditionStack.length-1]?this.conditions[this.conditionStack[this.conditionStack.length-1]].rules:this.conditions.INITIAL.rules},topState:function(M){return M=this.conditionStack.length-1-Math.abs(M||0),M>=0?this.conditionStack[M]:"INITIAL"},pushState:function(M){this.begin(M)},stateStackSize:function(){return this.conditionStack.length},options:{"case-insensitive":!0},performAction:function(M,E,T,w){switch(T){case 0:break;case 1:return 20;case 2:return 7;case 3:return 8;case 4:return 9;case 5:return 12;case 6:return 16;case 7:return 14;case 8:return 10;case 9:return 11;case 10:return 19;case 11:return 21;case 12:return"<=";case 13:return">=";case 14:return"<";case 15:return">";case 16:return E.yytext=E.yytext.substr(1,E.yyleng-2),24;case 17:return 13;case 18:return 23;case 19:return 5;case 20:return"INVALID"}},rules:[/^(?:\s+)/i,/^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i,/^(?:OR\b)/i,/^(?:AND\b)/i,/^(?:NOT\b)/i,/^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i,/^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i,/^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i,/^(?:\()/i,/^(?:\))/i,/^(?:,)/i,/^(?::)/i,/^(?:<=)/i,/^(?:>=)/i,/^(?:<)/i,/^(?:>)/i,/^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i,/^(?:(@[_A-Z0-9]+))/i,/^(?:([_A-Z0-9]+))/i,/^(?:$)/i,/^(?:.)/i],conditions:{INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],inclusive:!0}}};return S})();m.lexer=v;function y(){this.yy={}}return y.prototype=m,m.Parser=y,new y})();r.exports={parser:e}}),690:(function(r,e){(function(){var t,n,i,s,o,a,l,c,h,u,d,f,p,_,g,m,v,y,S,b,M,E,T,w,A,D,k=Object.prototype.hasOwnProperty,G=function(P,N){for(var B in N)k.call(N,B)&&(P[B]=N[B]);function H(){this.constructor=P}return H.prototype=N.prototype,P.prototype=new H,P.__super__=N.prototype,P};i={METHOD_NEAREST:"nearest",METHOD_LINEAR:"linear",METHOD_CUBIC:"cubic",METHOD_LANCZOS:"lanczos",METHOD_SINC:"sinc",CLIP_CLAMP:"clamp",CLIP_ZERO:"zero",CLIP_PERIODIC:"periodic",CLIP_MIRROR:"mirror",CUBIC_TENSION_DEFAULT:0,CUBIC_TENSION_CATMULL_ROM:0},f={method:i.METHOD_CUBIC,cubicTension:i.CUBIC_TENSION_DEFAULT,clip:i.CLIP_CLAMP,scaleTo:0,sincFilterSize:2,sincWindow:void 0},h=function(P,N){return Math.max(0,Math.min(P,N-1))},d=function(P,N){return P=P%N,P<0&&(P+=N),P},u=function(P,N){var B;return B=2*(N-1),P=d(P,B),P>N-1&&(P=B-P),P},t=(function(){function P(N,B){if(this.array=N.slice(0),this.length=this.array.length,!(this.clipHelper={clamp:this.clipHelperClamp,zero:this.clipHelperZero,periodic:this.clipHelperPeriodic,mirror:this.clipHelperMirror}[B.clip]))throw"Invalid clip: "+B.clip}return P.prototype.getClippedInput=function(N){return 0<=N&&N<this.length?this.array[N]:this.clipHelper(N)},P.prototype.clipHelperClamp=function(N){return this.array[h(N,this.length)]},P.prototype.clipHelperZero=function(N){return 0},P.prototype.clipHelperPeriodic=function(N){return this.array[d(N,this.length)]},P.prototype.clipHelperMirror=function(N){return this.array[u(N,this.length)]},P.prototype.interpolate=function(N){throw"Subclasses of AbstractInterpolator must override the interpolate() method."},P})(),o=(function(P){G(N,P);function N(){N.__super__.constructor.apply(this,arguments)}return N.prototype.interpolate=function(B){return this.getClippedInput(Math.round(B))},N})(t),s=(function(P){G(N,P);function N(){N.__super__.constructor.apply(this,arguments)}return N.prototype.interpolate=function(B){var H;return H=Math.floor(B),B-=H,(1-B)*this.getClippedInput(H)+B*this.getClippedInput(H+1)},N})(t),n=(function(P){G(N,P);function N(B,H){this.tangentFactor=1-Math.max(-1,Math.min(1,H.cubicTension)),N.__super__.constructor.apply(this,arguments)}return N.prototype.getTangent=function(B){return this.tangentFactor*(this.getClippedInput(B+1)-this.getClippedInput(B-1))/2},N.prototype.interpolate=function(B){var H,W,$,oe,Se;return H=Math.floor(B),W=[this.getTangent(H),this.getTangent(H+1)],$=[this.getClippedInput(H),this.getClippedInput(H+1)],B-=H,oe=B*B,Se=B*oe,(2*Se-3*oe+1)*$[0]+(Se-2*oe+B)*W[0]+(-2*Se+3*oe)*$[1]+(Se-oe)*W[1]},N})(t),E=Math.sin,a=Math.PI,T=function(P){return P===0?1:E(a*P)/(a*P)},v=function(P){return function(N){return T(N/P)}},S=function(P){return function(N){return T(N)*P(N)}},l=(function(P){G(N,P);function N(B,H){if(N.__super__.constructor.apply(this,arguments),this.a=H.sincFilterSize,!H.sincWindow)throw"No sincWindow provided";this.kernel=S(H.sincWindow)}return N.prototype.interpolate=function(B){var H,W,$,oe,Se;for(H=Math.floor(B),$=0,W=oe=H-this.a+1,Se=H+this.a;oe<=Se?W<=Se:W>=Se;oe<=Se?W++:W--)$+=this.kernel(B-W)*this.getClippedInput(W);return $},N})(t),p=function(P,N){var B,H,W,$;for($=[],H=0,W=P.length;H<W;H++)B=P[H],$.push(B[N]);return $},y=function(P,N,B){var H,W;return B.join==="0,1"?P:(H=N/(B[1]-B[0]),W=B[0],function($){return P(H*($-W))})},_=function(P){return Object.prototype.toString.call(P).slice(8,-1)},A=function(P){if(isNaN(P))throw"NaN in Smooth() input";if(_(P)!=="Number")throw"Non-number in Smooth() input";if(!isFinite(P))throw"Infinity in Smooth() input"},D=function(P,N){var B,H,W;if(_(P)!=="Array")throw"Non-vector in Smooth() input";if(P.length!==N)throw"Inconsistent dimension in Smooth() input";for(H=0,W=P.length;H<W;H++)B=P[H],A(B)},g=function(P){return _(P)==="Number"&&isFinite(P)&&!isNaN(P)},b=function(P){var N;switch(N="scaleTo param must be number or array of two numbers",_(P)){case"Number":if(!g(P))throw N;P=[0,P];break;case"Array":if(P.length!==2||!(g(P[0])&&g(P[1])))throw N;break;default:throw N}return P},M=function(P){var N,B,H;N={};for(B in P)k.call(P,B)&&(H=P[B],N[B]=H);return N},c=function(P,N){var B,H,W,$,oe,Se,K,ce,Z,_e,xe;N==null&&(N={}),Z={},N=M(N),Z.config=M(N),N.scaleTo==null&&(N.scaleTo=N.period),N.sincFilterSize==null&&(N.sincFilterSize=N.lanczosFilterSize);for(K in f)k.call(f,K)&&(xe=f[K],N[K]==null&&(N[K]=xe));if(!(oe={nearest:o,linear:s,cubic:n,lanczos:l,sinc:l}[N.method]))throw"Invalid method: "+N.method;if(N.method==="lanczos"&&(N.sincWindow=v(N.sincFilterSize)),P.length<2)throw"Array must have at least two elements";Z.count=P.length,_e=(function(){var Ee,Ne,Oe,Ve;switch(_(P[0])){case"Number":if(Z.dimension="scalar",c.deepValidation)for(Ee=0,Oe=P.length;Ee<Oe;Ee++)ce=P[Ee],A(ce);return $=new oe(P,N),function(De){return $.interpolate(De)};case"Array":if(Z.dimension=H=P[0].length,!H)throw"Vectors must be non-empty";if(c.deepValidation)for(Ne=0,Ve=P.length;Ne<Ve;Ne++)xe=P[Ne],D(xe,H);return Se=(function(){var De;for(De=[],W=0;0<=H?W<H:W>H;0<=H?W++:W--)De.push(new oe(p(P,W),N));return De})(),function(De){var z,ye,X,ie;for(ie=[],ye=0,X=Se.length;ye<X;ye++)z=Se[ye],ie.push(z.interpolate(De));return ie};default:throw"Invalid element type: "+_(P[0])}})(),N.clip==="periodic"?B=P.length:B=P.length-1,N.scaleTo||(N.scaleTo=B),Z.domain=b(N.scaleTo),_e=y(_e,B,Z.domain),Z.domain.sort();for(K in Z)k.call(Z,K)&&(xe=Z[K],_e[K]=xe);return _e};for(m in i)k.call(i,m)&&(w=i[m],c[m]=w);c.deepValidation=!0,(e!==null?e:window).Smooth=c}).call(this)}),660:(function(r,e){var t,n,i;(function(s,o){n=[e],t=o,i=typeof t=="function"?t.apply(e,n):t,i!==void 0&&(r.exports=i)})(this,function(s){function o(C,R,O){for(var j=(C.byteLength,0),q=O.length;q>j;j++){var he=O.charCodeAt(j);if(128>he)C.setUint8(R++,he>>>0&127|0);else if(2048>he)C.setUint8(R++,he>>>6&31|192),C.setUint8(R++,he>>>0&63|128);else if(65536>he)C.setUint8(R++,he>>>12&15|224),C.setUint8(R++,he>>>6&63|128),C.setUint8(R++,he>>>0&63|128);else{if(!(1114112>he))throw new Error("bad codepoint "+he);C.setUint8(R++,he>>>18&7|240),C.setUint8(R++,he>>>12&63|128),C.setUint8(R++,he>>>6&63|128),C.setUint8(R++,he>>>0&63|128)}}}function a(C){for(var R=0,O=0,j=C.length;j>O;O++){var q=C.charCodeAt(O);if(128>q)R+=1;else if(2048>q)R+=2;else if(65536>q)R+=3;else{if(!(1114112>q))throw new Error("bad codepoint "+q);R+=4}}return R}function l(C,R,O){var j=typeof C;if(j==="string"){var q=a(C);if(32>q)return R.setUint8(O,160|q),o(R,O+1,C),1+q;if(256>q)return R.setUint8(O,217),R.setUint8(O+1,q),o(R,O+2,C),2+q;if(65536>q)return R.setUint8(O,218),R.setUint16(O+1,q),o(R,O+3,C),3+q;if(4294967296>q)return R.setUint8(O,219),R.setUint32(O+1,q),o(R,O+5,C),5+q}if(C instanceof Uint8Array){var q=C.byteLength,he=new Uint8Array(R.buffer);if(256>q)return R.setUint8(O,196),R.setUint8(O+1,q),he.set(C,O+2),2+q;if(65536>q)return R.setUint8(O,197),R.setUint16(O+1,q),he.set(C,O+3),3+q;if(4294967296>q)return R.setUint8(O,198),R.setUint32(O+1,q),he.set(C,O+5),5+q}if(j==="number"){if(!isFinite(C))throw new Error("Number not finite: "+C);if(Math.floor(C)!==C)return R.setUint8(O,203),R.setFloat64(O+1,C),9;if(C>=0){if(128>C)return R.setUint8(O,C),1;if(256>C)return R.setUint8(O,204),R.setUint8(O+1,C),2;if(65536>C)return R.setUint8(O,205),R.setUint16(O+1,C),3;if(4294967296>C)return R.setUint8(O,206),R.setUint32(O+1,C),5;throw new Error("Number too big 0x"+C.toString(16))}if(C>=-32)return R.setInt8(O,C),1;if(C>=-128)return R.setUint8(O,208),R.setInt8(O+1,C),2;if(C>=-32768)return R.setUint8(O,209),R.setInt16(O+1,C),3;if(C>=-2147483648)return R.setUint8(O,210),R.setInt32(O+1,C),5;throw new Error("Number too small -0x"+(-C).toString(16).substr(1))}if(C===null)return R.setUint8(O,192),1;if(j==="boolean")return R.setUint8(O,C?195:194),1;if(j==="object"){var q,Le=0,ee=Array.isArray(C);if(ee)q=C.length;else{var we=Object.keys(C);q=we.length}var Le;if(16>q?(R.setUint8(O,q|(ee?144:128)),Le=1):65536>q?(R.setUint8(O,ee?220:222),R.setUint16(O+1,q),Le=3):4294967296>q&&(R.setUint8(O,ee?221:223),R.setUint32(O+1,q),Le=5),ee)for(var V=0;q>V;V++)Le+=l(C[V],R,O+Le);else for(var V=0;q>V;V++){var Me=we[V];Le+=l(Me,R,O+Le),Le+=l(C[Me],R,O+Le)}return Le}throw new Error("Unknown type "+j)}function c(C){var R=typeof C;if(R==="string"){var O=a(C);if(32>O)return 1+O;if(256>O)return 2+O;if(65536>O)return 3+O;if(4294967296>O)return 5+O}if(C instanceof Uint8Array){var O=C.byteLength;if(256>O)return 2+O;if(65536>O)return 3+O;if(4294967296>O)return 5+O}if(R==="number"){if(Math.floor(C)!==C)return 9;if(C>=0){if(128>C)return 1;if(256>C)return 2;if(65536>C)return 3;if(4294967296>C)return 5;throw new Error("Number too big 0x"+C.toString(16))}if(C>=-32)return 1;if(C>=-128)return 2;if(C>=-32768)return 3;if(C>=-2147483648)return 5;throw new Error("Number too small -0x"+C.toString(16).substr(1))}if(R==="boolean"||C===null)return 1;if(R==="object"){var O,j=0;if(Array.isArray(C)){O=C.length;for(var q=0;O>q;q++)j+=c(C[q])}else{var he=Object.keys(C);O=he.length;for(var q=0;O>q;q++){var ee=he[q];j+=c(ee)+c(C[ee])}}if(16>O)return 1+j;if(65536>O)return 3+j;if(4294967296>O)return 5+j;throw new Error("Array or object too long 0x"+O.toString(16))}throw new Error("Unknown type "+R)}function h(C){var R=new ArrayBuffer(c(C)),O=new DataView(R);return l(C,O,0),new Uint8Array(R)}function u(C,R,O){return R?new C(R.buffer,R.byteOffset,R.byteLength/(O||1)):void 0}function d(C){return u(DataView,C)}function f(C){return u(Uint8Array,C)}function p(C){return u(Int8Array,C)}function _(C){return u(Int32Array,C,4)}function g(C){return u(Float32Array,C,4)}function m(C,R){var O=C.length/2;R||(R=new Int16Array(O));for(var j=0,q=0;O>j;++j,q+=2)R[j]=C[q]<<8^C[q+1]<<0;return R}function v(C,R){var O=C.length;R||(R=new Uint8Array(2*O));for(var j=d(R),q=0;O>q;++q)j.setInt16(2*q,C[q]);return f(R)}function y(C,R){var O=C.length/4;R||(R=new Int32Array(O));for(var j=0,q=0;O>j;++j,q+=4)R[j]=C[q]<<24^C[q+1]<<16^C[q+2]<<8^C[q+3]<<0;return R}function S(C,R){var O=C.length;R||(R=new Uint8Array(4*O));for(var j=d(R),q=0;O>q;++q)j.setInt32(4*q,C[q]);return f(R)}function b(C,R){var O=C.length;R||(R=new Float32Array(O/4));for(var j=d(R),q=d(C),he=0,ee=0,we=O/4;we>he;++he,ee+=4)j.setFloat32(ee,q.getFloat32(ee),!0);return R}function M(C,R,O){var j=C.length,q=1/R;O||(O=new Float32Array(j));for(var he=0;j>he;++he)O[he]=C[he]*q;return O}function E(C,R,O){var j=C.length;O||(O=new Int32Array(j));for(var q=0;j>q;++q)O[q]=Math.round(C[q]*R);return O}function T(C,R){var O,j;if(!R){var q=0;for(O=0,j=C.length;j>O;O+=2)q+=C[O+1];R=new C.constructor(q)}var he=0;for(O=0,j=C.length;j>O;O+=2)for(var ee=C[O],we=C[O+1],Le=0;we>Le;++Le)R[he]=ee,++he;return R}function w(C){if(C.length===0)return new Int32Array;var R,O,j=2;for(R=1,O=C.length;O>R;++R)C[R-1]!==C[R]&&(j+=2);var q=new Int32Array(j),he=0,ee=1;for(R=1,O=C.length;O>R;++R)C[R-1]!==C[R]?(q[he]=C[R-1],q[he+1]=ee,ee=1,he+=2):++ee;return q[he]=C[C.length-1],q[he+1]=ee,q}function A(C,R){var O=C.length;R||(R=new C.constructor(O)),O&&(R[0]=C[0]);for(var j=1;O>j;++j)R[j]=C[j]+R[j-1];return R}function D(C,R){var O=C.length;R||(R=new C.constructor(O)),R[0]=C[0];for(var j=1;O>j;++j)R[j]=C[j]-C[j-1];return R}function k(C,R){var O,j,q=C instanceof Int8Array?127:32767,he=-q-1,ee=C.length;if(!R){var we=0;for(O=0;ee>O;++O)C[O]<q&&C[O]>he&&++we;R=new Int32Array(we)}for(O=0,j=0;ee>O;){for(var Le=0;C[O]===q||C[O]===he;)Le+=C[O],++O;Le+=C[O],++O,R[j]=Le,++j}return R}function G(C,R){var O,j=32767,q=-j-1,he=C.length,ee=0;for(O=0;he>O;++O){var we=C[O];we===0?++ee:ee+=we===j||we===q?2:we>0?Math.ceil(we/j):Math.ceil(we/q)}var Le=new Int16Array(ee),V=0;for(O=0;he>O;++O){var we=C[O];if(we>=0)for(;we>=j;)Le[V]=j,++V,we-=j;else for(;q>=we;)Le[V]=q,++V,we-=q;Le[V]=we,++V}return Le}function P(C,R){return A(T(C),R)}function N(C){return w(D(C))}function B(C,R,O){return M(T(C,_(O)),R,O)}function H(C,R){return w(E(C,R))}function W(C,R,O){return M(A(C,_(O)),R,O)}function $(C,R,O){return D(E(C,R),O)}function oe(C,R,O){return M(k(C,_(O)),R,O)}function Se(C,R,O){var j=k(C,_(O));return W(j,R,g(j))}function K(C,R,O){return G($(C,R))}function ce(he){var R=d(he),O=R.getInt32(0),j=R.getInt32(4),q=he.subarray(8,12),he=he.subarray(12);return[O,he,j,q]}function Z(C,R,O,j){var q=new ArrayBuffer(12+j.byteLength),he=new Uint8Array(q),ee=new DataView(q);return ee.setInt32(0,C),ee.setInt32(4,R),O&&he.set(O,8),he.set(j,12),he}function _e(C){var R=C.length,O=f(C);return Z(2,R,void 0,O)}function xe(C){var R=C.length,O=S(C);return Z(4,R,void 0,O)}function Ee(C,R){var O=C.length/R,j=S([R]),q=f(C);return Z(5,O,j,q)}function Ne(C){var R=C.length,O=S(w(C));return Z(6,R,void 0,O)}function Oe(C){var R=C.length,O=S(N(C));return Z(8,R,void 0,O)}function Ve(C,R){var O=C.length,j=S([R]),q=S(H(C,R));return Z(9,O,j,q)}function De(C,R){var O=C.length,j=S([R]),q=v(K(C,R));return Z(10,O,j,q)}function z(C){var R={};return U.forEach(function(O){C[O]!==void 0&&(R[O]=C[O])}),C.bondAtomList&&(R.bondAtomList=xe(C.bondAtomList)),C.bondOrderList&&(R.bondOrderList=_e(C.bondOrderList)),R.xCoordList=De(C.xCoordList,1e3),R.yCoordList=De(C.yCoordList,1e3),R.zCoordList=De(C.zCoordList,1e3),C.bFactorList&&(R.bFactorList=De(C.bFactorList,100)),C.atomIdList&&(R.atomIdList=Oe(C.atomIdList)),C.altLocList&&(R.altLocList=Ne(C.altLocList)),C.occupancyList&&(R.occupancyList=Ve(C.occupancyList,100)),R.groupIdList=Oe(C.groupIdList),R.groupTypeList=xe(C.groupTypeList),C.secStructList&&(R.secStructList=_e(C.secStructList)),C.insCodeList&&(R.insCodeList=Ne(C.insCodeList)),C.sequenceIndexList&&(R.sequenceIndexList=Oe(C.sequenceIndexList)),R.chainIdList=Ee(C.chainIdList,4),C.chainNameList&&(R.chainNameList=Ee(C.chainNameList,4)),R}function ye(C){function R(Le){for(var V={},Me=0;Le>Me;Me++){var se=he();V[se]=he()}return V}function O(Le){var V=C.subarray(ee,ee+Le);return ee+=Le,V}function j(Le){var V=C.subarray(ee,ee+Le);ee+=Le;var Me=65535;if(Le>Me){for(var se=[],ae=0;ae<V.length;ae+=Me)se.push(String.fromCharCode.apply(null,V.subarray(ae,ae+Me)));return se.join("")}return String.fromCharCode.apply(null,V)}function q(Le){for(var V=new Array(Le),Me=0;Le>Me;Me++)V[Me]=he();return V}function he(){var Le,V,Me=C[ee];if((128&Me)===0)return ee++,Me;if((240&Me)===128)return V=15&Me,ee++,R(V);if((240&Me)===144)return V=15&Me,ee++,q(V);if((224&Me)===160)return V=31&Me,ee++,j(V);if((224&Me)===224)return Le=we.getInt8(ee),ee++,Le;switch(Me){case 192:return ee++,null;case 194:return ee++,!1;case 195:return ee++,!0;case 196:return V=we.getUint8(ee+1),ee+=2,O(V);case 197:return V=we.getUint16(ee+1),ee+=3,O(V);case 198:return V=we.getUint32(ee+1),ee+=5,O(V);case 202:return Le=we.getFloat32(ee+1),ee+=5,Le;case 203:return Le=we.getFloat64(ee+1),ee+=9,Le;case 204:return Le=C[ee+1],ee+=2,Le;case 205:return Le=we.getUint16(ee+1),ee+=3,Le;case 206:return Le=we.getUint32(ee+1),ee+=5,Le;case 208:return Le=we.getInt8(ee+1),ee+=2,Le;case 209:return Le=we.getInt16(ee+1),ee+=3,Le;case 210:return Le=we.getInt32(ee+1),ee+=5,Le;case 217:return V=we.getUint8(ee+1),ee+=2,j(V);case 218:return V=we.getUint16(ee+1),ee+=3,j(V);case 219:return V=we.getUint32(ee+1),ee+=5,j(V);case 220:return V=we.getUint16(ee+1),ee+=3,q(V);case 221:return V=we.getUint32(ee+1),ee+=5,q(V);case 222:return V=we.getUint16(ee+1),ee+=3,R(V);case 223:return V=we.getUint32(ee+1),ee+=5,R(V)}throw new Error("Unknown type 0x"+Me.toString(16))}var ee=0,we=new DataView(C.buffer);return he()}function X(C,R,O,j){switch(C){case 1:return b(R);case 2:return p(R);case 3:return m(R);case 4:return y(R);case 5:return f(R);case 6:return T(y(R),new Uint8Array(O));case 7:return T(y(R));case 8:return P(y(R));case 9:return B(y(R),y(j)[0]);case 10:return Se(m(R),y(j)[0]);case 11:return M(m(R),y(j)[0]);case 12:return oe(m(R),y(j)[0]);case 13:return oe(p(R),y(j)[0]);case 14:return k(m(R));case 15:return k(p(R))}}function ie(C,R){R=R||{};var O=R.ignoreFields,j={};return fe.forEach(function(q){var he=O?O.indexOf(q)!==-1:!1,ee=C[q];he||ee===void 0||(ee instanceof Uint8Array?j[q]=X.apply(null,ce(ee)):j[q]=ee)}),j}function ne(C){return String.fromCharCode.apply(null,C).replace(/\0/g,"")}function Ae(C,R,O){O=O||{};var j,q,he,ee,we,Le,V=O.firstModelOnly,Me=R.onModel,se=R.onChain,ae=R.onGroup,ge=R.onAtom,Fe=R.onBond,Y=0,We=0,J=0,Qe=0,ue=0,it=-1,Xt=C.chainNameList,$t=C.secStructList,Fn=C.insCodeList,Zt=C.sequenceIndexList,xt=C.atomIdList,kt=C.bFactorList,vi=C.altLocList,Wi=C.occupancyList,Xi=C.bondAtomList,ur=C.bondOrderList;for(j=0,q=C.chainsPerModel.length;q>j&&!(V&&Y>0);++j){var L=C.chainsPerModel[Y];for(Me&&Me({chainCount:L,modelIndex:Y}),he=0;L>he;++he){var re=C.groupsPerChain[We];if(se){var me=ne(C.chainIdList.subarray(4*We,4*We+4)),Q=null;Xt&&(Q=ne(Xt.subarray(4*We,4*We+4))),se({groupCount:re,chainIndex:We,modelIndex:Y,chainId:me,chainName:Q})}for(ee=0;re>ee;++ee){var pe=C.groupList[C.groupTypeList[J]],Be=pe.atomNameList.length;if(ae){var Xe=null;$t&&(Xe=$t[J]);var Ze=null;C.insCodeList&&(Ze=String.fromCharCode(Fn[J]));var $e=null;Zt&&($e=Zt[J]),ae({atomCount:Be,groupIndex:J,chainIndex:We,modelIndex:Y,groupId:C.groupIdList[J],groupType:C.groupTypeList[J],groupName:pe.groupName,singleLetterCode:pe.singleLetterCode,chemCompType:pe.chemCompType,secStruct:Xe,insCode:Ze,sequenceIndex:$e})}for(we=0;Be>we;++we){if(ge){var tt=null;xt&&(tt=xt[Qe]);var qe=null;kt&&(qe=kt[Qe]);var st=null;vi&&(st=String.fromCharCode(vi[Qe]));var yt=null;Wi&&(yt=Wi[Qe]),ge({atomIndex:Qe,groupIndex:J,chainIndex:We,modelIndex:Y,atomId:tt,element:pe.elementList[we],atomName:pe.atomNameList[we],formalCharge:pe.formalChargeList[we],xCoord:C.xCoordList[Qe],yCoord:C.yCoordList[Qe],zCoord:C.zCoordList[Qe],bFactor:qe,altLoc:st,occupancy:yt})}Qe+=1}if(Fe){var wt=pe.bondAtomList;for(we=0,Le=pe.bondOrderList.length;Le>we;++we)Fe({atomIndex1:Qe-Be+wt[2*we],atomIndex2:Qe-Be+wt[2*we+1],bondOrder:pe.bondOrderList[we]})}J+=1}We+=1}if(ue=it+1,it=Qe-1,Fe&&Xi)for(we=0,Le=Xi.length;Le>we;we+=2){var sn=Xi[we],bn=Xi[we+1];(sn>=ue&&it>=sn||bn>=ue&&it>=bn)&&Fe({atomIndex1:sn,atomIndex2:bn,bondOrder:ur?ur[we/2]:null})}Y+=1}}function Pe(C){return h(z(C))}function Ie(C,R){C instanceof ArrayBuffer&&(C=new Uint8Array(C));var O;return O=C instanceof Uint8Array?ye(C):C,ie(O,R)}function Ge(C,R,O,j){function q(){try{var ee=Ie(he.response);O(ee)}catch(we){j(we)}}var he=new XMLHttpRequest;he.addEventListener("load",q,!0),he.addEventListener("error",j,!0),he.responseType="arraybuffer",he.open("GET",R+C.toUpperCase()),he.send()}function Ye(C,R,O){Ge(C,Ue,R,O)}function et(C,R,O){Ge(C,ke,R,O)}var U=["mmtfVersion","mmtfProducer","unitCell","spaceGroup","structureId","title","depositionDate","releaseDate","experimentalMethods","resolution","rFree","rWork","bioAssemblyList","ncsOperatorList","entityList","groupList","numBonds","numAtoms","numGroups","numChains","numModels","groupsPerChain","chainsPerModel"],I=["xCoordList","yCoordList","zCoordList","groupIdList","groupTypeList","chainIdList","bFactorList","atomIdList","altLocList","occupancyList","secStructList","insCodeList","sequenceIndexList","chainNameList","bondAtomList","bondOrderList"],fe=U.concat(I),Ce="v1.1.0dev",Re="//mmtf.rcsb.org/v1.0/",Ue=Re+"full/",ke=Re+"reduced/";s.encode=Pe,s.decode=Ie,s.traverse=Ae,s.fetch=Ye,s.fetchReduced=et,s.version=Ce,s.fetchUrl=Ue,s.fetchReducedUrl=ke,s.encodeMsgpack=h,s.encodeMmtf=z,s.decodeMsgpack=ye,s.decodeMmtf=ie})})},$m={};function xn(r){var e=$m[r];if(e!==void 0)return e.exports;var t=$m[r]={exports:{}};return hT[r].call(t.exports,t,t.exports,xn),t.exports}xn.n=r=>{var e=r&&r.__esModule?(()=>r.default):(()=>r);return xn.d(e,{a:e}),e};xn.d=(r,e)=>{for(var t in e)xn.o(e,t)&&!xn.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:e[t]})};xn.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e);var v0={};xn.d(v0,{A:()=>yO});var uT=r=>{var e={};return xn.d(e,r),e};const de=uT({default:()=>Qy}),x=cT;var vc=function(){return vc=Object.assign||function(r){for(var e,t=1,n=arguments.length;t<n;t++){e=arguments[t];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(r[i]=e[i])}return r},vc.apply(this,arguments)},dT={lines:12,length:7,width:5,radius:10,scale:1,corners:1,color:"#000",fadeColor:"transparent",animation:"spinner-line-fade-default",rotate:0,direction:1,speed:1,zIndex:2e9,className:"spinner",top:"50%",left:"50%",shadow:"0 0 1px transparent",position:"absolute"},fT=(function(){function r(e){e===void 0&&(e={}),this.opts=vc(vc({},dT),e)}return r.prototype.spin=function(e){return this.stop(),this.el=document.createElement("div"),this.el.className=this.opts.className,this.el.setAttribute("role","progressbar"),this.el.style.position=this.opts.position,this.el.style.width="0",this.el.style.zIndex=this.opts.zIndex.toString(),this.el.style.left=this.opts.left,this.el.style.top=this.opts.top,this.el.style.transform="scale(".concat(this.opts.scale,")"),e&&e.insertBefore(this.el,e.firstChild||null),pT(this.el,this.opts),this},r.prototype.stop=function(){return this.el&&(this.el.parentNode&&this.el.parentNode.removeChild(this.el),this.el=void 0),this},r})();function Zm(r,e){return typeof r=="string"?r:r[e%r.length]}function pT(r,e){var t=Math.round(e.corners*e.width*500)/1e3+"px",n="none";e.shadow===!0?n="0 2px 4px #000":typeof e.shadow=="string"&&(n=e.shadow);for(var i=mT(n),s=0;s<e.lines;s++){var o=~~(360/e.lines*s+e.rotate),a=document.createElement("div");a.style.position="absolute",a.style.top="".concat(-e.width/2,"px"),a.style.width=e.length+e.width+"px",a.style.height=e.width+"px",a.style.background=Zm(e.fadeColor,s),a.style.borderRadius=t,a.style.transformOrigin="left",a.style.transform="rotate(".concat(o,"deg) translateX(").concat(e.radius,"px)");var l=s*e.direction/e.lines/e.speed;l-=1/e.speed;var c=document.createElement("div");c.style.width="100%",c.style.height="100%",c.style.background=Zm(e.color,s),c.style.borderRadius=t,c.style.boxShadow=gT(i,o),c.style.animation="".concat(1/e.speed,"s linear ").concat(l,"s infinite ").concat(e.animation),a.appendChild(c),r.appendChild(a)}}function mT(r){for(var e=/^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/,t=[],n=0,i=r.split(",");n<i.length;n++){var s=i[n],o=s.match(e);if(o!==null){var a=+o[2],l=+o[5],c=o[4],h=o[7];a===0&&!c&&(c=h),l===0&&!h&&(h=c),c===h&&t.push({prefix:o[1]||"",x:a,y:l,xUnits:c,yUnits:h,end:o[8]})}}return t}function gT(r,e){for(var t=[],n=0,i=r;n<i.length;n++){var s=i[n],o=_T(s.x,s.y,e);t.push(s.prefix+o[0]+s.xUnits+" "+o[1]+s.yUnits+s.end)}return t.join(", ")}function _T(r,e,t){var n=t*Math.PI/180,i=Math.sin(n),s=Math.cos(n);return[Math.round((r*s+e*i)*1e3)/1e3,Math.round((-r*i+e*s)*1e3)/1e3]}class Qs{constructor(){this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=Qs.now(),this.oldTime=this.startTime,this.running=!0}stop(){this.getElapsedTime(),this.running=!1}getElapsedTime(){return this.update(),this.elapsedTime}update(){let e=0;if(this.running){const t=Qs.now();e=.001*(t-this.oldTime),this.oldTime=t,this.elapsedTime+=e}return e}}Qs.now=(function(){const r=typeof window<"u"&&window.performance;return r&&r.now?r.now.bind(r):Date.now})();const{now:Km}=Qs;function Jm(r,e,t){const n=document.createElement(r);return n.id=e,n.style.cssText=t,n}class yT{constructor(){this.domElement=Jm("div","stats","padding:8px"),this._text=Jm("p","fps","margin:0;color:silver;font-size:large"),this.domElement.appendChild(this._text),this._startTime=Km(),this._prevTime=this._startTime,this._deltas=new Array(20),this._index=0,this._total=0,this._count=0}end(){const e=Km(),t=e-this._startTime;return this._count<this._deltas.length?this._count++:this._total-=this._deltas[this._index],this._total+=t,this._deltas[this._index]=t,this._index=(this._index+1)%this._deltas.length,this.ms=this._total/this._count,this.fps=1e3/this.ms,e>this._prevTime+1e3&&(this._text.textContent=this.fps.toPrecision(2),this._prevTime=e),e}update(){this._startTime=this.end()}show(e){e===void 0&&(e=!0),this.domElement.style.display=e?"block":"none"}}const xT=yT;function ou(r,e){return!r||r===e}function qc(){this._handlers={}}qc.prototype.addEventListener=function(r,e,t){let n=this._handlers[r];n||(this._handlers[r]=[],n=this._handlers[r]);const i=[e,t];function s(o){return o[0]===i[0]&&o[1]===i[1]}de.default.find(n,s)===void 0&&n.push(i)};qc.prototype.removeEventListener=function(r,e,t){const n=this;de.default.forEach(n._handlers,(i,s)=>{de.default.remove(i,o=>ou(r,s)&&ou(e,o[0])&&ou(t,o[1]||n))}),this._handlers=de.default.omitBy(n._handlers,i=>i.length===0)};qc.prototype.dispatchEvent=function(r){const e=this;de.default.forEach(this._handlers[r.type],t=>{const n=t[1]||e;t[0].apply(n,[r])})};const Dn=qc,ei={debug:0,info:1,report:2,warn:3,error:4};function hn(){Dn.call(this),this.console=!1,this._priority=ei.warn}hn.prototype=Object.create(Dn.prototype);hn.prototype.constructor=hn;hn.prototype.instantiate=function(){return new hn};function S0(r){if(!de.default.isNumber(r))throw new Error("Wrong log level specified!");return r}Object.defineProperty(hn.prototype,"level",{get(){return de.default.findKey(ei,r=>r===this._priority)},set(r){this._priority=S0(ei[r])}});hn.prototype.levels=function(){return Object.keys(ei)};hn.prototype.message=function(r,e){const t=S0(ei[r]);this._message(t,e)};hn.prototype.debug=function(r){this._message(ei.debug,r)};hn.prototype.info=function(r){this._message(ei.info,r)};hn.prototype.report=function(r){this._message(ei.report,r)};hn.prototype.warn=function(r){this._message(ei.warn,r)};hn.prototype.error=function(r){this._message(ei.error,r)};hn.prototype._message=function(r,e){if(r<this._priority)return;const t=de.default.findKey(ei,n=>n===r);if(e=String(e),this.console){const n=`miew:${t}: ${e}`;t==="error"?console.error(n):t==="warn"?console.warn(n):console.log(n)}this.dispatchEvent({type:"message",level:t,message:e})};const Ut=new hn,bd={DEFAULT:0,SAFARI:1};function vT(r,e){const t=n=>String.fromCharCode(parseInt(n.substr(1),16));return encodeURIComponent(r).replace(e,t).replace(/%20/g,"+")}function wd(r){return decodeURIComponent(r.replace(/\+/g," "))}function b0(r){r=r||window.location.search;const e=r.substring(r.indexOf("?")+1),t=/([^&=]+)=?([^&]*)/g,n=[];let i;for(;(i=t.exec(e))!==null;)n.push([wd(i[1]),wd(i[2])]);return n}function ST(r){const e={},t=b0(r);for(let n=0;n<t.length;++n){const[i,s]=t[n];e[i]=s}return e}function bT(r){if(typeof URL<"u")try{return typeof window<"u"?new URL(r,window.location).href:new URL(r).href}catch{}if(typeof document<"u"){const e=document.createElement("a");return e.href=r,e.href}return r}function wT(r){const e=[];for(let n=0,i=r.length;n<i;++n)e[e.length]=r[n].charCodeAt(0).toString(16);const t=e.join("|");return new RegExp(`%(?:${t})`,"gi")}function MT(r,e,t){const n=document.createElement(r);let i,s;if(e){const o=Object.keys(e);for(i=0,s=o.length;i<s;++i){const a=o[i];n.setAttribute(a,e[a])}}if(t)for(t instanceof Array||(t=[t]),i=0,s=t.length;i<s;++i){const o=t[i];typeof o=="string"?n.appendChild(document.createTextNode(o)):o instanceof HTMLElement&&n.appendChild(o)}return n}function AT(r,e,t,n){return r.prototype=de.default.assign(Object.create(e.prototype),{constructor:r},t),n&&de.default.assign(r,n),r}function Md(r,e){let t=r,n,i;if(r instanceof Array)for(t=new Array(r.length),n=0,i=r.length;n<i;++n)t[n]=Md(r[n]);else if(r instanceof Object){t=Object.create(r);const s=Object.keys(r);for(n=0,i=s.length;n<i;++n){const o=s[n],a=r[o],l=Md(a);l!==a&&(t[o]=l)}e&&Object.keys(t).length>0&&(t=Object.create(t))}return t}function ET(r){return`#${`0000000${r.toString(16)}`.substr(-6)}`}function bf(r){let e=!1;this.enable=function(s){e=s};let t=0;const n=Object.keys(r);function i(s,o){return function(){const a=bf.spaces.substr(0,t*2);e&&Ut.debug(`${a+o} {`),t++;for(var l=arguments.length,c=new Array(l),h=0;h<l;h++)c[h]=arguments[h];const u=s.apply(this,c);return t--,e&&Ut.debug(`${a}} // ${o}`),u}}for(let s=0,o=n.length;s<o;++s){const a=n[s],l=r[a];l instanceof Function&&a!=="constructor"&&(r[a]=i(l,a))}}bf.spaces="                                                                                          ";class w0 extends Error{constructor(e){super(),this.name="OutOfMemoryError",this.message=e}}function TT(r,e){let t=null;try{t=new r(e)}catch(n){throw n instanceof RangeError?new w0(n.message):n}return t}function M0(r){const e=new Uint8Array(r);let t="";for(let n=0;n<e.byteLength;n++)t+=String.fromCharCode(e[n]);return window.btoa(t)}function wf(r){const e=window.atob(r),t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)t[n]=e[n].charCodeAt(0);return t.buffer}function CT(r,e){return M0(new e(r).buffer)}function RT(r,e){return Array.prototype.slice.call(new e(wf(r)))}function PT(r,e){const t=[];if(e&&r){const n=Object.keys(r);for(let i=0;i<n.length;++i){const s=n[i],o=r[s];!(o instanceof Object)&&typeof e[s]<"u"&&e[s]!==o&&t.push(`${s}:${o}`)}if(t.length>0)return`!${t.join()}`}return""}function Ad(r){if(de.default.isPlainObject(r))return!0;const e=r&&Object.getPrototypeOf(r);return!!e&&!e.hasOwnProperty("constructor")&&Ad(e)}function A0(r,e){const t={};return de.default.forIn(r,(n,i)=>{const s=e[i];if(Ad(n)&&Ad(s)){const o=A0(n,s);de.default.isEmpty(o)||(t[i]=o)}else de.default.isEqual(n,s)||(t[i]=n)}),t}function IT(r,e){function t(n,i){de.default.forIn(n,(s,o)=>{const a=i+(i.length>0?".":"");s instanceof Object?t(s,a+o):s!==void 0&&e(s,a+o)})}t(r,"")}function LT(r){return de.default.isString(r)?`"${r.replace(/"/g,'\\"')}"`:r}function NT(r){if(!de.default.isString(r))return r;if(r[0]==='"'&&r[r.length-1]==='"')return r=r.slice(1,r.length-1),r.replace(/\\"/g,'"');if(r[0]==="'"&&r[r.length-1]==="'")return r=r.slice(1,r.length-1),r.replace(/\\'/g,"'");throw new SyntaxError("Incorrect string format, can't unqute it")}function E0(r){return r.slice(Math.max(0,r.lastIndexOf("."))||1/0)}function OT(r){const e=E0(r);return[r.slice(0,r.length-e.length),e]}function Qm(r){const e=r.split(/[:;,]/),t=e.length;return t>=3&&e[t-2]==="base64"?new Blob([wf(e[t-1])]):null}function DT(){return navigator.vendor&&navigator.vendor.indexOf("Apple")>-1&&navigator.userAgent&&navigator.userAgent.indexOf("CriOS")===-1&&navigator.userAgent.indexOf("FxiOS")===-1?bd.SAFARI:bd.DEFAULT}function UT(r){typeof window<"u"&&window.open().document.write(`<body style="margin:0"><img src="${r}" /></body>`)}function FT(r,e){if(!(!r||r.substr(0,5)!=="data:")){if(e||(e=["screenshot-",+new Date,".png"].join("")),typeof window<"u"&&window.navigator&&window.navigator.msSaveBlob)window.navigator.msSaveBlob(Qm(r),e);else if(typeof document<"u"){const t=document.createElement("a");t.download=e,t.innerHTML="download",t.href=window.URL.createObjectURL(Qm(r)),document.body.appendChild(t),t.click(),document.body.removeChild(t)}}}function zT(r,e,t){const n=new Blob([r]);if(e||(e=["data",+new Date].join("")),t?e+=`.${t}`:e+=n.type||".bin",typeof window<"u"&&window.navigator&&window.navigator.msSaveBlob)window.navigator.msSaveBlob(n,e);else if(typeof document<"u"){const i=document.createElement("a");i.download=e,i.innerHTML="download",i.href=window.URL.createObjectURL(n),document.body.appendChild(i),i.click(),document.body.removeChild(i)}}function VT(r,e,t,n){for(let i=0,s=t.length;i<s;++i)for(let o=0;o<n;++o)e[i*n+o]=r[t[i]*n+o]}function BT(r){const e=r.cloneNode(!0);return e.worldPos=r.worldPos,e}const kT=/^[a-zA-Z0-9_]*$/,eg=['"',"",'"'];function GT(r){return kT.test(r)?r:(eg[1]=r,eg.join(""))}function HT(r,e){const t=new r.constructor(r.length+e.length);return t.set(r),t.set(e,r.length),t}function WT(r){if(r.length<=0)return null;const e=r.reduce((n,i)=>n+i.length,0),t=new r[0].constructor(e);for(let n=0,i=0;n<r.length;n++){const s=r[n].length;t.set(r[n],i),i+=s}return t}const be={browserType:bd,encodeQueryComponent:vT,decodeQueryComponent:wd,getUrlParameters:b0,getUrlParametersAsDict:ST,resolveURL:bT,generateRegExp:wT,createElement:MT,deriveClass:AT,deriveDeep:Md,hexColor:ET,DebugTracer:bf,OutOfMemoryError:w0,allocateTyped:TT,bytesFromBase64:wf,bytesToBase64:M0,arrayFromBase64:RT,arrayToBase64:CT,compareOptionsWithDefaults:PT,objectsDiff:A0,forInRecursive:IT,enquoteString:LT,unquoteString:NT,getBrowser:DT,shotOpen:UT,shotDownload:FT,copySubArrays:VT,shallowCloneNode:BT,correctSelectorIdentifier:GT,getFileExtension:E0,splitFileName:OT,download:zT,concatTypedArraysUnsafe:HT,mergeTypedArraysUnsafe:WT};class XT extends Dn{constructor(){super(),this._shouldCancel=!1}cancel(){this._shouldCancel=!0,this.dispatchEvent({type:"cancel"})}shouldCancel(){return this._shouldCancel}notify(e){this.dispatchEvent({type:"notification",slaveEvent:e})}}const tg=0,Io={modes:{BS:{atom:.23,bond:.15,space:.5,multibond:!0,aromrad:.1,showarom:!0,polyComplexity:{poor:3,low:4,medium:6,high:12,ultra:32}},VW:{polyComplexity:{poor:4,low:6,medium:8,high:16,ultra:32}},LN:{multibond:!0,showarom:!0,offsarom:.2,chunkarom:10,atom:.23,lineWidth:2},LC:{bond:.2,space:0,multibond:!0,aromrad:.1,showarom:!0,polyComplexity:{poor:3,low:4,medium:6,high:12,ultra:32}},SA:{zClip:!1,probeRadius:1.5,subset:"",wireframe:!1,polyComplexity:{poor:6,low:8,medium:16,high:30,ultra:60}},SE:{zClip:!1,probeRadius:1.5,subset:"",wireframe:!1,polyComplexity:{poor:6,low:8,medium:16,high:30,ultra:60}},QS:{isoValue:.5,gaussLim:{poor:1.5,low:2,medium:2.5,high:3,ultra:4},scale:1,wireframe:!1,gridSpacing:{poor:2,low:1.5,medium:1,high:.5,ultra:.25},subset:"",zClip:!1},CS:{probeRadius:1.4,isoValue:1.5,wireframe:!1,probePositions:30,polyComplexity:{poor:.5,low:1,medium:1.5,high:1.75,ultra:2},subset:"",zClip:!1},TR:{radius:.3,polyComplexity:{poor:12,low:16,medium:32,high:64,ultra:64}},TU:{radius:.3,heightSegmentsRatio:1.5,tension:-.7,polyComplexity:{poor:4,low:6,medium:10,high:18,ultra:34}},CA:{radius:.3,depth:.25,ss:{helix:{width:1,arrow:2},strand:{width:1,arrow:2}},heightSegmentsRatio:1.5,tension:-.7,polyComplexity:{poor:4,low:6,medium:10,high:18,ultra:34}},TX:{template:"{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}",horizontalAlign:"center",verticalAlign:"middle",dx:0,dy:0,dz:1,fg:"none",bg:"0x202020",showBg:!0},VD:{kSigma:1,kSigmaMed:2,kSigmaMax:4,frame:!0,isoMode:!1,polyComplexity:{poor:2,low:3,medium:4,high:8,ultra:10}}},colorers:{EL:{carbon:-1},UN:{color:16777215},CO:{subset:"charged",color:16711680,baseColor:16777215},CB:{color:9474192,factor:.6},SQ:{gradient:"rainbow"},TM:{gradient:"temp",min:5,max:40},OC:{gradient:"reds"},HY:{gradient:"blue-red"},MO:{gradient:"rainbow"}},antialias:!0,camFov:45,camNear:.5,camFar:100,camDistance:2.5,radiusToFit:1,fogNearFactor:.5,fogFarFactor:1,fogAlpha:1,fogColor:0,fogColorEnable:!1,palette:"JM",resolution:"medium",autoResolution:!1,autoPreset:!0,preset:"default",presets:{default:[{mode:"BS",colorer:"EL",selector:"all",material:"SF"}],empty:[],wire:[{mode:"LN",colorer:"EL",selector:"all",material:"SF"}],small:[{mode:"BS",colorer:"EL",selector:"all",material:"SF"}],macro:[{mode:"CA",colorer:"SS",selector:"not hetatm",material:"SF"},{mode:"BS",colorer:"EL",selector:"hetatm and not water",material:"SF"}]},objects:{line:{color:4294967295,dashSize:.3,gapSize:.05}},bg:{color:2105376,transparent:!1},draft:{clipPlane:!1,clipPlaneFactor:.5,clipPlaneSpeed:3e-5},plugins:{},axes:!0,fog:!0,fps:!0,zSprites:!0,isoSurfaceFakeOpacity:!0,suspendRender:!0,nowater:!1,autobuild:!0,fxaa:!0,outline:{on:!1,color:0,threshold:.1,thickness:1},ao:!1,shadow:{on:!1,type:"random",radius:1},autoRotation:0,maxfps:30,fbxprec:4,autoRotationAxisFixed:!0,zooming:!0,picking:!0,pick:"atom",editing:!1,aromatic:!1,singleUnit:!0,stereo:"NONE",interpolateViews:!0,transparency:"prepass",translationSpeed:2,debug:{example:3.5,text:"hello!",good:!0,ssaoKernelRadius:.7,ssaoFactor:.7,stereoBarrel:.25},use:{multiFile:!1}};function T0(){Dn.call(this),this.old=null,this.now={},this._changed={},this.reset()}be.deriveClass(T0,Dn,{defaults:Io,set(r,e){if(de.default.isString(r))de.default.get(this.now,r)!==e&&(de.default.set(this.now,r,e),this._notifyChange(r,e));else{const t=be.objectsDiff(r,this.now);de.default.isEmpty(t)||(de.default.merge(this.now,t),this._notifyChanges(t))}},get(r,e){return de.default.get(this.now,r,e)},reset(){const r=be.objectsDiff(Io,this.now);this.now=de.default.cloneDeep(Io),this.old=null,this._notifyChanges(r),this._changed={}},checkpoint(){this.old=de.default.cloneDeep(this.now),this._changed={}},_notifyChange(r,e){this._changed[r]=!0,this.dispatchEvent({type:`change:${r}`,value:e})},_notifyChanges(r){be.forInRecursive(r,(e,t)=>{this._notifyChange(t,e)})},changed(){if(!this.old)return[];const{old:r,now:e}=this;return de.default.filter(Object.keys(this._changed),n=>de.default.get(r,n)!==de.default.get(e,n))},applyDiffs(r){if(r.hasOwnProperty("VERSION")&&r.VERSION!==tg)throw new Error("Settings version does not match!");delete r.VERSION,this.reset(),this.set(r)},getDiffs(r){const e=be.objectsDiff(this.now,Io);return r&&(e.VERSION=tg),e},setPluginOpts(r,e){Io.plugins[r]=de.default.cloneDeep(e),this.now.plugins[r]=de.default.cloneDeep(e)}});const te=new T0;let jt=0;function C0(r){return!(!r||r==="0"||de.default.isString(r)&&r.toLowerCase()==="false")}const Mf={string:String,number:Number,boolean:C0},jT="=",Af="!",R0=":",P0=",",I0="$;@/?";function YT(){return be.generateRegExp(I0+":,")}function qT(){return be.generateRegExp(I0+" ")}const $T=YT();function ng(r){return be.encodeQueryComponent(r,$T)}const ZT=qT();function ig(r){return be.encodeQueryComponent(r,ZT)}function fc(r){let{reps:e}=r;if(!e){const{presets:t}=te.now;let n=r.preset||te.now.preset;e=t[n],e||(Ut.warn(`Unknown preset "${n}"`),[n]=Object.keys(t),e=t[n]),r.preset=n,r.reps=be.deriveDeep(e,!0)}}function Ul(r,e,t){fc(r);const n=r.reps[jt];n.hasOwnProperty(e)&&(jt=r.reps.length,r.reps[jt]=be.deriveDeep(n,!0)),t!==void 0&&(r.reps[jt][e]=t)}function KT(r,e,t){r._objects===void 0&&(r._objects=[]);const[n,i]=t,s={type:n,params:e};i!==void 0&&(s.opts=i),r._objects[r._objects.length]=s}function JT(r,e){const t=r.indexOf(",");return t>=0?(e.push(r.substr(t+1).split(",")),r.substr(0,t)):r}function Fl(r,e,t){if(r){const n=r.indexOf(Af),i=JT(r.substr(0,n>=0?n:void 0),t);if(n>=0){const s=r.substr(n+1).split(P0);if(r=i,e){const o=e[r],a=be.deriveDeep(o,!0);s.forEach(l=>{const c=l.split(R0,2),h=decodeURIComponent(c[0]),u=decodeURIComponent(c[1]),d=Mf[typeof de.default.get(o,h)];d?de.default.set(a,h,d(u)):Ut.warn(`Unknown argument "${h}" for option "${r}"`)}),Object.keys(a).length>0&&(r=[r,a])}}else r=i}return r}const sg={l:"load",load:String,t:"type",type:String,v:"view",view:String,u:"unit",unit:Number,menu:C0,o:"object",object(r,e){const t=[];let n=Fl(r,te.defaults.objects,t);Array.isArray(n)||(n=[n]),KT(e,t[0],n)},p:"preset",preset(r,e){e.preset=r,e.reps=null,fc(e)},r:"rep",rep(r,e){fc(e),jt=Number(r),jt=jt<=e.reps.length?jt<0?0:jt:e.reps.length,jt===e.reps.length&&(e.reps[jt]=jt>0?be.deriveDeep(e.reps[jt-1],!0):be.deriveDeep(te.defaults.presets.default[0],!0))},s:"select",select(r,e){Ul(e,"selector",r)},m:"mode",mode(r,e){Ul(e,"mode",Fl(r,te.defaults.modes))},c:"color",color(r,e){Ul(e,"colorer",Fl(r,te.defaults.colorers))},mt:"material",material(r,e){Ul(e,"material",Fl(r,te.defaults.materials))},dup(r,e){fc(e);const{reps:t}=e,n=t[jt];jt=t.length,t[jt]=be.deriveDeep(n,!0)},ar:"autoResolution"};function L0(r){jt=0;const e={};for(let t=0,n=r.length;t<n;++t){const i=r[t];let s=i[0];const o=i[1];let a=sg[s];for(;de.default.isString(a);)s=a,a=sg[s];if(a){if(de.default.isFunction(a)){const l=a(o,e);l!==void 0&&(e[s]=l)}}else{const l=Mf[typeof de.default.get(te.defaults,s)];l?de.default.set(e,`settings.${s}`,l(o)):Ut.warn(`Unknown option "${s}"`)}}return e}function QT(r){return L0(be.getUrlParameters(`?${r||""}`))}function e2(r){return L0(be.getUrlParameters(r))}function N0(r){const e=[];let t=0;return be.forInRecursive(r,(n,i)=>{e[t++]=ig(i)+R0+ig(n)}),e.join(P0)}function au(r){return de.default.isArray(r)?r.length<2?r[0]:`${r[0]}${Af}${N0(r[1])}`:r}function t2(r){if(!r||!r.type)return;let e=r.type;return de.default.isArray(r.params)&&r.params.length>0&&(e+=`,${r.params.join(",")}`),r.opts&&(e+=Af+N0(r.opts)),e}function n2(r){const e=[];let t=0;function n(a,l){l!=null&&(e[t++]=ng(a)+jT+ng(l))}function i(a){if(a)for(let l=0,c=a.length;l<c;++l)de.default.isEmpty(a[l])||(n("r",l),n("s",a[l].selector),n("m",au(a[l].mode)),n("c",au(a[l].colorer)),n("mt",au(a[l].material)))}function s(a){if(a)for(let l=0,c=a.length;l<c;++l)n("o",t2(a[l]))}n("l",r.load),n("u",r.unit),n("p",r.preset),i(r.reps),s(r._objects),n("v",r.view),be.forInRecursive(r.settings,(a,l)=>{l!=="preset"&&n(l,a)});let o="";if(typeof window<"u"){const{location:a}=window;o=`${a.protocol}//${a.host}${a.pathname}`}return e.length>0&&(o+=`?${e.join("&")}`),o}function O0(r){const e=[];let t=0;return be.forInRecursive(r,(n,i)=>{e[t++]=`${i}=${be.enquoteString(n)}`}),e.join(" ")}function lu(r){return de.default.isArray(r)?r.length<2?r[0]:`${r[0]} ${O0(r[1])}`:r}function i2(r){if(!r||!r.type)return;let e=r.type;return de.default.isArray(r.params)&&r.params.length>0&&(e+=` ${r.params.map(be.enquoteString).join(" ")}`),r.opts&&(e+=` ${O0(r.opts)}`),e}function s2(r,e){const t=[];let n=0;function i(s,o){o!=null&&(t[n++]=s+o)}return de.default.isEmpty(r)?null:(i("",e),i("s=",be.enquoteString(r.selector)),i("m=",lu(r.mode)),i("c=",lu(r.colorer)),i("mt=",lu(r.material)),t.join(" "))}function r2(r){const e=[];let t=0;function n(o,a,l){if(a!=null){const c=typeof a=="string"&&l?'"':"";e[t++]=`${o} ${c}${a}${c}`.trim()}}function i(o){if(o)for(let a=0,l=o.length;a<l;++a)n("rep",s2(o[a],a))}function s(o){if(o)for(let a=0,l=o.length;a<l;++a)n("",i2(o[a]))}return n("set","autobuild false"),n("load",r.load,!0),n("unit",r.unit),n("preset",r.preset),i(r.reps),s(r._objects),be.forInRecursive(r.settings,(o,a)=>{a!=="preset"&&n(`set ${a}`,o,!0)}),n("view",r.view),n("set","autobuild true"),e.join(`
`)}const Ef={fromURL:e2,fromAttr:QT,adapters:Mf,toURL:n2,toScript:r2};class Sc{constructor(e,t,n,i,s,o,a,l,c,h,u){this.index=-1,this.residue=e,this.name=t,this.element=n,this.position=i,this.role=s,this.mask=1,this.het=o,this.serial=a,this.location=(l||" ").charCodeAt(0),this.occupancy=c||1,this.temperature=h,this.charge=u,this.hydrogenCount=-1,this.radicalCount=0,this.valence=-1,this.bonds=[],this.flags=0,n.name==="H"?this.flags|=Sc.Flags.HYDROGEN:n.name==="C"&&(this.flags|=Sc.Flags.CARBON)}isHet(){return this.het}isHydrogen(){return this.element.number===1}getVisualName(){const{name:e}=this;return e.length>0?e:this.element.name.trim()}forEachBond(e){const{bonds:t}=this;for(let n=0,i=t.length;n<i;++n)e(t[n])}getFullName(){let e="";return this.residue!==null&&(this.residue._chain!==null&&(e+=`${this.residue._chain.getName()}.`),e+=`${this.residue._sequence}.`),e+=this.name,e}static Flags={CARBON:1,HYDROGEN:8,NONPOLARH:4104}}const mi=Sc;class ve{constructor(e,t,n,i,s,o,a){this.number=e,this.name=t,this.fullName=n,this.weight=i,this.radius=s,this.radiusBonding=o,this.hydrogenValency=a}static Constants={U1:1,Lead:2,U2:3,Wing:4,U18:18};static Role={N:ve.Constants.U1,CA:ve.Constants.Lead,C:ve.Constants.U2,O:ve.Constants.Wing,SG:ve.Constants.U18};static ByAtomicNumber=[null,new ve(1,"H","Hydrogen",1.008,1.2,.23,[1]),new ve(2,"HE","Helium",4.003,1.4,.93,[0]),new ve(3,"LI","Lithium",6.941,1.82,.68,[1]),new ve(4,"BE","Beryllium",9.012,1.7,.35,[2]),new ve(5,"B","Boron",10.81,2.08,.83,[3]),new ve(6,"C","Carbon",12.011,1.95,.68,[4]),new ve(7,"N","Nitrogen",14.007,1.85,.68,[3,5]),new ve(8,"O","Oxygen",15.999,1.7,.68,[2,4]),new ve(9,"F","Fluorine",18.998,1.73,.64,[1]),new ve(10,"NE","Neon",20.18,1.54,1.12,[0]),new ve(11,"NA","Sodium",22.99,2.27,.97,[1]),new ve(12,"MG","Magnesium",24.305,1.73,1.1,[2]),new ve(13,"AL","Aluminum",26.981,2.05,1.35,[3]),new ve(14,"SI","Silicon",28.086,2.1,1.2,[4]),new ve(15,"P","Phosphorus",30.974,2.08,.75,[3,5]),new ve(16,"S","Sulfur",32.07,2,1.02,[2,4,6]),new ve(17,"CL","Chlorine",35.453,1.97,.99,[1,3,5,7]),new ve(18,"AR","Argon",39.948,1.88,1.57,[0]),new ve(19,"K","Potassium",39.1,2.75,1.33,[1]),new ve(20,"CA","Calcium",40.08,1.973,.99,[2]),new ve(21,"SC","Scandium",44.956,1.7,1.44,[0]),new ve(22,"TI","Titanium",47.88,1.7,1.47,[0]),new ve(23,"V","Vanadium",50.941,1.7,1.33,[0]),new ve(24,"CR","Chromium",52,1.7,1.35,[0]),new ve(25,"MN","Manganese",54.938,1.7,1.35,[0]),new ve(26,"FE","Iron",55.847,1.7,1.34,[0]),new ve(27,"CO","Cobalt",58.93,1.7,1.33,[0]),new ve(28,"NI","Nickel",58.69,1.63,1.5,[0]),new ve(29,"CU","Copper",63.55,1.4,1.52,[0]),new ve(30,"ZN","Zinc",65.39,1.39,1.45,[0]),new ve(31,"GA","Gallium",69.72,1.87,1.22,[3]),new ve(32,"GE","Germanium",72.61,1.7,1.17,[4]),new ve(33,"AS","Arsenic",74.92,1.85,1.21,[3,5]),new ve(34,"SE","Selenium",78.96,1.9,1.22,[2,4,6]),new ve(35,"BR","Bromine",79.9,2.1,1.21,[1,3,5,7]),new ve(36,"KR","Krypton",83.8,2.02,1.91,[0]),new ve(37,"RB","Rubidium",85.47,1.7,1.47,[1]),new ve(38,"SR","Strontium",87.62,1.7,1.12,[2]),new ve(39,"Y","Yttrium",88.91,1.7,1.78,[0]),new ve(40,"ZR","Zirconium",91.22,1.7,1.56,[0]),new ve(41,"NB","Niobium",92.91,1.7,1.48,[0]),new ve(42,"MO","Molybdenum",95.94,1.7,1.47,[0]),new ve(43,"TC","Technetium",98.91,1.7,1.35,[0]),new ve(44,"RU","Ruthenium",101.07,1.7,1.4,[0]),new ve(45,"RH","Rhodium",102.91,1.7,1.45,[0]),new ve(46,"PD","Palladium",106.42,1.63,1.5,[0]),new ve(47,"AG","Silver",107.87,1.72,1.59,[0]),new ve(48,"CD","Cadmium",112.41,1.58,1.69,[0]),new ve(49,"IN","Indium",114.82,1.93,1.63,[3]),new ve(50,"SN","Tin",118.71,2.17,1.46,[2,4]),new ve(51,"SB","Antimony",121.75,2.2,1.46,[3,5]),new ve(52,"TE","Tellurium",127.6,2.06,1.47,[2,4,6]),new ve(53,"I","Iodine",126.91,2.15,1.4,[1,3,5,7]),new ve(54,"XE","Xenon",131.29,2.16,1.98,[0]),new ve(55,"CS","Cesium",132.91,1.7,1.67,[1]),new ve(56,"BA","Barium",137.33,1.7,1.34,[2]),new ve(57,"LA","Lanthanum",138.91,1.7,1.87,[0]),new ve(58,"CE","Cerium",140.12,1.7,1.83,[0]),new ve(59,"PR","Praseodymium",140.91,1.7,1.82,[0]),new ve(60,"ND","Neodymium",144.24,1.7,1.81,[0]),new ve(61,"PM","Promethium",144.9,1.7,1.8,[0]),new ve(62,"SM","Samarium",150.36,1.7,1.8,[0]),new ve(63,"EU","Europium",151.96,1.7,1.99,[0]),new ve(64,"GD","Gadolinium",157.25,1.7,1.79,[0]),new ve(65,"TB","Terbium",158.93,1.7,1.76,[0]),new ve(66,"DY","Dysprosium",162.5,1.7,1.75,[0]),new ve(67,"HO","Holmium",164.93,1.7,1.74,[0]),new ve(68,"ER","Erbium",167.26,1.7,1.73,[0]),new ve(69,"TM","Thulium",168.93,1.7,1.72,[0]),new ve(70,"YB","Ytterbium",173.04,1.7,1.94,[0]),new ve(71,"LU","Lutetium",174.97,1.7,1.72,[0]),new ve(72,"HF","Hafnium",178.49,1.7,1.57,[0]),new ve(73,"TA","Tantalum",180.95,1.7,1.43,[0]),new ve(74,"W","Tungsten",183.85,1.7,1.37,[0]),new ve(75,"RE","Rhenium",186.21,1.7,1.35,[0]),new ve(76,"OS","Osmium",190.2,1.7,1.37,[0]),new ve(77,"IR","Iridium",192.22,1.7,1.32,[0]),new ve(78,"PT","Platinum",195.08,1.72,1.5,[0]),new ve(79,"AU","Gold",196.97,1.66,1.5,[0]),new ve(80,"HG","Mercury",200.59,1.55,1.7,[0]),new ve(81,"TL","Thallium",204.38,1.96,1.55,[1,3]),new ve(82,"PB","Lead",207.2,2.02,1.54,[2,4]),new ve(83,"BI","Bismuth",208.98,1.7,1.54,[3,5]),new ve(84,"PO","Polonium",210,1.7,1.68,[2,4,6]),new ve(85,"AT","Astatine",210,1.7,1.7,[1,3,5,7]),new ve(86,"RN","Radon",222,1.7,2.4,[0]),new ve(87,"FR","Francium",223,1.7,2,[1]),new ve(88,"RA","Radium",226.03,1.7,1.9,[2]),new ve(89,"AC","Actinium",227.03,1.7,1.88,[0]),new ve(90,"TH","Thorium",232.04,1.7,1.79,[0]),new ve(91,"PA","Protactinium",231.04,1.7,1.61,[0]),new ve(92,"U","Uranium",238.03,1.86,1.58,[0]),new ve(93,"NP","Neptunium",237.05,1.7,1.55,[0]),new ve(94,"PU","Plutonium",239.1,1.7,1.53,[0]),new ve(95,"AM","Americium",243.1,1.7,1.51,[0]),new ve(96,"CM","Curium",247.1,1.7,1.5,[0]),new ve(97,"BK","Berkelium",247.1,1.7,1.5,[0]),new ve(98,"CF","Californium",252.1,1.7,1.5,[0]),new ve(99,"ES","Einsteinium",252.1,1.7,1.5,[0]),new ve(100,"FM","Fermium",257.1,1.7,1.5,[0]),new ve(101,"MD","Mendelevium",256.1,1.7,1.5,[0]),new ve(102,"NO","Nobelium",259.1,1.7,1.5,[0]),new ve(103,"LR","Lawrencium",260.1,1.7,1.5,[0]),new ve(104,"RF","Rutherfordium",261,1.7,1.6,[0]),new ve(105,"DB","Dubnium",262,1.7,1.6,[0]),new ve(106,"SG","Seaborgium",263,1.7,1.6,[0]),new ve(107,"BH","Bohrium",262,1.7,1.6,[0]),new ve(108,"HS","Hassium",265,1.7,1.6,[0]),new ve(109,"MT","Meitnerium",268,1.7,1.6,[0])];static ByName={D:new ve(1,"D","Deuterium",2.014,1.2,.23,[1]),T:new ve(1,"T","Tritium",3.016,1.2,.23,[1])}}(function(){const r=ve.ByAtomicNumber,e=ve.ByName;for(let t=0,n=r.length;t<n;++t){const i=r[t];i&&(e[i.name]=i)}})();ve.getByName=function(r){let e=ve.ByName[r];return e||(e=ve.ByName[r]=new ve(0,r,"Unknown",0,1,.01,[0])),e};const ma=ve,D0={UNKNOWN:0,COVALENT:1,AROMATIC:2};function o2(r){return r.position}class U0{constructor(e,t,n,i,s){if(this._left=e,this._right=t,this._fixed=s,this._index=-1,e>t)throw new Error("In a bond atom indices must be in increasing order");this._order=n,this._type=i}getLeft(){return this._left}getRight(){return this._right}getOrder(){return this._order}calcLength(){return this._left.position.distanceTo(this._right.position)}_forEachNeighbour(e,t){const{bonds:n}=e;for(let i=0,s=n.length;i<s;++i)t(n[i]._left!==e?n[i]._left:n[i]._right)}forEachLevelOne(e){const t=this._left,n=this._right;this._forEachNeighbour(t,i=>{i!==n&&e(i)}),this._forEachNeighbour(n,i=>{i!==t&&e(i)})}forEachLevelTwo(e){const t=this._left,n=this._right,i=this;i._forEachNeighbour(t,s=>{s!==n&&i._forEachNeighbour(s,o=>{o!==t&&e(o)})}),i._forEachNeighbour(n,s=>{s!==t&&i._forEachNeighbour(s,o=>{o!==n&&e(o)})})}_fixDir(e,t,n){let i=0,s=0;const o=e.clone();function a(h){o.copy(n(h)),o.sub(e),t.dot(o)>0?++i:++s}function l(h){h.element.name==="C"&&a(h)}const c=[[this.forEachLevelOne,l],[this.forEachLevelOne,a],[this.forEachLevelTwo,l],[this.forEachLevelTwo,a]];for(let h=0;h<c.length;++h){if(c[h][0].call(this,c[h][1]),s>i)return t.multiplyScalar(-1);if(s<i)return t}return t}calcNormalDir(e){const t=this._left,n=this._right;let i=t,s=n;e=e===void 0?o2:e,t.bonds.length>n.bonds.length&&(i=n,s=t);let o=i,a=0;const{bonds:l}=s;for(let d=0,f=l.length;d<f;++d){let p=l[d]._left;l[d]._left===s&&(p=l[d]._right),p.bonds.length>a&&p!==i&&(o=p,a=p.bonds.length)}const c=e(s),h=e(i).clone().sub(c),u=e(o).clone().sub(c);return u.crossVectors(h,u),u.lengthSq()<1e-4&&u.set(0,1,0),h.normalize(),u.normalize(),h.crossVectors(u,h),h.lengthSq()<1e-4&&h.set(0,1,0),h.normalize(),this._fixDir(c,h,e)}static BondType=D0}U0.prototype.BondType=D0;const Ua=U0,a2=["C3'","C3*","P","H5T","H3T"],rg=["OP1","O1P"],og=["OP2","O2P"],l2=["C3'","C3*","C1","C1'","C1*","P"],zl=[{types:["A","DA","G","DG"],atoms:["N1"]},{types:["C","DC"],atoms:["N3"]},{types:["T","DT","U","DU"],atoms:["O4"]}];class c2{constructor(e,t,n,i){this._chain=e,this._component=null,this._type=t,this._sequence=n,this._icode=i,this._mask=1,this._index=-1,this._atoms=[],this._secondary=null,this._firstAtom=null,this._leadAtom=null,this._wingAtom=null,this._lastAtom=null,this._controlPoint=null,this._midPoint=null,this._wingVector=null,this._cylinders=null,this._isValid=!0,this._het=!1,this._molecule=null,this.temperature=null,this.occupancy=null}getChain(){return this._chain}getMolecule(){return this._molecule}getType(){return this._type}getSequence(){return this._sequence}getSecondary(){return this._secondary}getICode(){return this._icode}addAtom(e,t,n,i,s,o,a,l,c,h){const u=new mi(this,e,t,n,i,s,o,a,l,c,h);return this._chain.getComplex().addAtom(u),this._atoms.push(u),this._het=this._het||s,u}getAtomCount(){return this._atoms.length}forEachAtom(e){const t=this._atoms;for(let n=0,i=t.length;n<i&&!e(t[n]);++n);}_findAtomByName(e){let t=null;return this.forEachAtom(n=>n.name===e?(t=n,!0):!1),t}_findFirstAtomInList(e){let t=null;for(let n=0;n<e.length;++n)if(t=this._findAtomByName(e[n]),t!==null)return t;return t}collectMask(){let e=4294967295;const t=this._atoms;for(let n=0,i=t.length;n<i;++n)e&=t[n].mask;this._mask=e}getCylinderTargetList(){const e=this._type._name;for(let t=0,n=zl.length;t<n;++t)for(let i=0,s=zl[t].types.length;i<s;++i)if(e===zl[t].types[i])return zl[t].atoms;return null}_detectLeadWing(e,t,n){const i=this._findFirstAtomInList(a2);let s=this._findFirstAtomInList(rg),o=this._findFirstAtomInList(og);if(s===null&&t!==null&&(s=t._findFirstAtomInList(rg)),o===null&&t!==null&&(o=t._findFirstAtomInList(og)),i===null||s===null||o===null)return;e._leadAtom=i,e._controlPoint=n(i),e._wingVector=n(o).clone().sub(n(s)),e._isValid=!0;const a=this._findFirstAtomInList(l2),l=this.getCylinderTargetList(),c=l!==null?this._findFirstAtomInList(l):null;a===null||c===null||(e._cylinders=[n(a),n(c)])}calcWing(e,t,n,i){const s=t.clone().sub(e),o=e.clone().sub(n);return o.crossVectors(s,o),o.crossVectors(s,o).normalize(),i!==null&&i.length()>1e-4&&o.length()>1e-4&&Math.abs(i.angleTo(o))>Math.PI/2&&o.negate(),o}_innerFinalize(e,t,n,i,s,o){const a=t===null,l=o(this._leadAtom),c=new x.Vector3(l.x,l.y,l.z);if(s){this._detectLeadWing(i,n,o);return}if(a)i._midPoint=o(this._firstAtom).clone();else{const h=t._controlPoint;i._midPoint=h.clone().lerp(c,.5),i._wingVector=this.calcWing(h,c,o(e._wingAtom),t._wingVector)}i._controlPoint=c}_finalize2(e,t,n){this._innerFinalize(e,e,t,this,n,i=>i.position)}isConnected(e){if(this._chain!==e._chain)return!1;if(this===e)return!0;let t=!1;return this.forEachAtom(n=>{const{bonds:i}=n;for(let s=0,o=i.length;s<o;++s){const a=i[s];if(a._left.residue===e||a._right.residue===e)return t=!0,!0}return!1}),t}_finalize(){const e=this;[this._firstAtom]=this._atoms,this._lastAtom=this._atoms[this._atoms.length-1],this._leadAtom=null,this._wingAtom=null;let t=0,n=0,i=0,s=0;this.forEachAtom(o=>(e._leadAtom===null&&o.role===ma.Constants.Lead&&(e._leadAtom=o),e._wingAtom===null&&o.role===ma.Constants.Wing&&(e._wingAtom=o),o.temperature&&(n+=o.temperature,t++),o.occupancy&&(s+=o.occupancy,i++),e._leadAtom!==null&&e._wingAtom!==null)),t>0&&(this.temperature=n/t),i>0&&(this.occupancy=s/i),(this._leadAtom===null||this._wingAtom===null)&&(this._isValid=!1),this._leadAtom===null&&(this._leadAtom=this._firstAtom),this._wingAtom===null&&(this._wingAtom=this._lastAtom)}}const bc=c2;class Ke{constructor(e,t,n){this._name=e,this._fullName=t,this.letterCode=n,this.flags=0}getName(){return this._name}static StandardTypes={ALA:new Ke("ALA","Alanine","A"),ARG:new Ke("ARG","Arginine","R"),ASN:new Ke("ASN","Asparagine","N"),ASP:new Ke("ASP","Aspartic Acid","D"),CYS:new Ke("CYS","Cysteine","C"),GLN:new Ke("GLN","Glutamine","Q"),GLU:new Ke("GLU","Glutamic Acid","E"),GLY:new Ke("GLY","Glycine","G"),HIS:new Ke("HIS","Histidine","H"),ILE:new Ke("ILE","Isoleucine","I"),LEU:new Ke("LEU","Leucine","L"),LYS:new Ke("LYS","Lysine","K"),MET:new Ke("MET","Methionine","M"),PHE:new Ke("PHE","Phenylalanine","F"),PRO:new Ke("PRO","Proline","P"),PYL:new Ke("PYL","Pyrrolysine","O"),SEC:new Ke("SEC","Selenocysteine","U"),SER:new Ke("SER","Serine","S"),THR:new Ke("THR","Threonine","T"),TRP:new Ke("TRP","Tryptophan","W"),TYR:new Ke("TYR","Tyrosine","Y"),VAL:new Ke("VAL","Valine","V"),A:new Ke("A","Adenine","A"),C:new Ke("C","Cytosine","C"),G:new Ke("G","Guanine","G"),I:new Ke("I","Inosine","I"),T:new Ke("T","Thymine","T"),U:new Ke("U","Uracil","U"),DA:new Ke("DA","Adenine","A"),DC:new Ke("DC","Cytosine","C"),DG:new Ke("DG","Guanine","G"),DI:new Ke("DI","Inosine","I"),DT:new Ke("DT","Thymine","T"),DU:new Ke("DU","Uracil","U"),"+A":new Ke("+A","Adenine","A"),"+C":new Ke("+C","Cytosine","C"),"+G":new Ke("+G","Guanine","G"),"+I":new Ke("+I","Inosine","I"),"+T":new Ke("+T","Thymine","T"),"+U":new Ke("+U","Uracil","U"),WAT:new Ke("WAT","Water",""),H2O:new Ke("H2O","Water",""),HOH:new Ke("HOH","Water",""),DOD:new Ke("DOD","Water",""),UNK:new Ke("UNK","Unknown",""),UNL:new Ke("UNL","Unknown Ligand","")};static Flags={PROTEIN:1,BASIC:2,ACIDIC:4,POLAR:8,NONPOLAR:16,AROMATIC:32,NUCLEIC:256,PURINE:512,PYRIMIDINE:1024,DNA:2048,RNA:4096,WATER:65536}}function Gn(r,e){for(let t=0,n=e.length;t<n;++t){const i=Ke.StandardTypes[e[t]];i&&(i.flags|=r)}}const{Flags:Hn}=Ke;Gn(Hn.WATER,["WAT","H2O","HOH","DOD"]);Gn(Hn.PROTEIN,["ALA","ARG","ASN","ASP","CYS","GLY","GLU","GLN","HIS","ILE","LEU","LYS","MET","PHE","PRO","PYL","SEC","SER","THR","TRP","TYR","VAL"]);Gn(Hn.BASIC,["ARG","HIS","LYS"]);Gn(Hn.ACIDIC,["ASP","GLU"]);Gn(Hn.POLAR,["ASN","CYS","GLN","SER","THR","TYR"]);Gn(Hn.NONPOLAR,["ALA","ILE","LEU","MET","PHE","PRO","TRP","VAL","GLY"]);Gn(Hn.AROMATIC,["PHE","TRP","TYR"]);Gn(Hn.NUCLEIC,["A","G","I","DA","DG","DI","+A","+G","+I","C","T","U","DC","DT","DU","+C","+T","+U"]);Gn(Hn.PURINE,["A","G","I","DA","DG","DI","+A","+G","+I"]);Gn(Hn.PYRIMIDINE,["C","T","U","DC","DT","DU","+C","+T","+U"]);Gn(Hn.DNA,["DA","DG","DI","DC","DT","DU"]);Gn(Hn.RNA,["A","G","I","C","T","U"]);const h2={ILE:4.5,VAL:4.2,LEU:3.8,PHE:2.8,CYS:2.5,MET:1.9,ALA:1.8,GLY:-.4,THR:-.7,SER:-.8,TRP:-.9,TYR:-1.3,PRO:-1.6,HIS:-3.2,GLU:-3.5,GLN:-3.5,ASP:-3.5,ASN:-3.5,LYS:-3.9,ARG:-4.5};function u2(r,e){const t=Object.keys(e);for(let n=0,i=t.length;n<i;++n){const s=t[n],o=e[s];Ke.StandardTypes[s][r]=o}}u2("hydrophobicity",h2);const gt=Ke,Lo={UNKNOWN:0,PROTEIN:1,NUCLEIC:2};class d2{constructor(e,t){this._complex=e,this._name=t,this._mask=1,this._index=-1,this._residues=[],this.minSequence=Number.POSITIVE_INFINITY,this.maxSequence=Number.NEGATIVE_INFINITY}getComplex(){return this._complex}getName(){return this._name}getResidues(){return this._residues}_determineType(){const e=this._residues,{PROTEIN:t,NUCLEIC:n}=gt.Flags;this.type=Lo.UNKNOWN;for(let i=0,s=e.length;i<s;++i){const{flags:o}=e[i]._type;if((o&n)!==0){this.type=Lo.NUCLEIC;break}else if((o&t)!==0){this.type=Lo.PROTEIN;break}}}findResidue(e,t){const n=this._residues;for(let i=0,s=n.length;i<s;++i){const o=n[i];if(o._sequence===e&&o._icode===t)return[o,i]}return null}_finalize(){this._determineType();const e=this._residues;let t=null;for(let n=0,i=e.length;n<i;++n){const s=n+1<i?e[n+1]:null,o=e[n];o._finalize2(t,s,this.type===Lo.NUCLEIC),t=o}if(e.length>1&&e[1]._wingVector){const n=e[1]._wingVector;e[0]._wingVector=new x.Vector3(n.x,n.y,n.z)}else e.length>0&&(e[0]._wingVector=new x.Vector3(1,0,0))}updateToFrame(e){const t=this._residues;let n=null,i=null;const s=e._residues,o=t.length;function a(l){return e.getAtomPos(l.index)}for(let l=0;l<o;++l){const c=t[l],h=s[c._index],u=l+1<o?t[l+1]:null;c._innerFinalize(n,i,u,h,this.type===Lo.NUCLEIC,a),n=c,i=h}s[t[0]._index]._wingVector=o>1?s[t[1]._index]._wingVector:new x.Vector3(1,0,0)}addResidue(e,t,n){let i=this._complex.getResidueType(e);i===null&&(i=this._complex.addResidueType(e));const s=new bc(this,i,t,n);return this._complex.addResidue(s),this._residues.push(s),i.flags&(gt.Flags.NUCLEIC|gt.Flags.PROTEIN)&&(this.maxSequence<t&&(this.maxSequence=t),this.minSequence>t&&(this.minSequence=t)),s}getResidueCount(){return this._residues.length}forEachResidue(e){const t=this._residues;for(let n=0,i=t.length;n<i;++n)e(t[n])}collectMask(){let e=4294967295;const t=this._residues;for(let n=0,i=t.length;n<i;++n)e&=t[n]._mask;this._mask=e}}const F0=d2;class Ss{constructor(e,t,n){this.type=e,this.generic=Ss.genericByType[this.type]||"loop",this.init=t,this.term=n}_finalize(e,t,n){if(this.init instanceof bc&&this.term instanceof bc)return;const i=n.splitUnifiedSerial(this.init),s=n.splitUnifiedSerial(this.term);for(let o=i.chain;o<=s.chain;o++)for(let a=i.serial;a<=s.serial;a++)for(let{iCode:l}=i;l<=s.iCode;l++){const c=n.getUnifiedSerial(o,a,l);t[c]&&(t[c]._secondary=this)}this.init=t[this.init],this.term=t[this.term]}}Ss.Type={STRAND:"E",BRIDGE:"B",HELIX_310:"G",HELIX_ALPHA:"H",HELIX_PI:"I",HELIX:"X",TURN_310:"3",TURN_ALPHA:"4",TURN_PI:"5",TURN:"T",BEND:"S",COIL:"C"};Ss.Generic={STRAND:"strand",HELIX:"helix",LOOP:"loop"};const No=Ss.Type,Oo=Ss.Generic;Ss.genericByType={[No.STRAND]:Oo.STRAND,[No.HELIX_310]:Oo.HELIX,[No.HELIX_ALPHA]:Oo.HELIX,[No.HELIX_PI]:Oo.HELIX,[No.HELIX]:Oo.HELIX};const Ln=Ss,cu=Ln.Type,z0={1:cu.HELIX_ALPHA,3:cu.HELIX_PI,5:cu.HELIX_310};class f2 extends Ln{constructor(e,t,n,i,s,o,a){super(z0[e]||Ln.Type.HELIX,t,n),this.serial=i,this.name=s,this.comment=o,this.length=a}}const Ed=f2;class p2 extends Ln{constructor(e,t,n,i,s,o){super(Ln.Type.STRAND,t,n),this.sheet=e,this.sense=i,this.atomCur=s,this.atomPrev=o}_finalize(e,t,n){super._finalize(e,t,n);let i=this.atomCur;i!==null&&!Number.isNaN(i)&&(this.atomCur=e[i]),i=this.atomPrev,i!==null&&!Number.isNaN(i)&&(this.atomPrev=e[i])}}const Tf=p2;class m2{constructor(e,t){this._name=e,this._width=t,this._strands=[]}getName(){return this._name}getWidth(){return this._width}addStrand(e){this._strands.push(e),this._width=this._strands.length}addEmptyStrand(){this._strands.push(new Tf(null,null,null,null,null,null))}_finalize(e,t,n){const i=this._strands;for(let s=0,o=i.length;s<o;++s)i[s]._finalize(e,t,n);if(this._width||(this._width=i.length),i.length!==this._width)throw new Error(`Sheet ${this._name} is inconsistent.`)}}const V0=m2;class g2{constructor(e,t,n,i,s){this._id=e,this._name=t,this._position=n||new x.Vector3,this._atoms=i||[],this._charge=0,this._repeat=1,this._center=null,this.xmlNodeRef=s||null}getName(){return this._name}getPosition(){return this._position}getCentralPoint(){return this._center}_rebuildSGroupOnAtomChange(){if(this._center===null)return;const t=new x.Vector3(1e8,1e8,1e8),n=new x.Vector3(-1e8,-1e8,-1e8);for(let i=0,s=this._atoms.length;i<s;i++){const o=this._atoms[i].position;t.set(Math.min(t.x,o.x),Math.min(t.y,o.y),Math.min(t.z,o.z)),n.set(Math.max(n.x,o.x),Math.max(n.y,o.y),Math.max(n.z,o.z))}this._center.addVectors(t,n),this._center.multiplyScalar(.5)}}const _2=g2;var wc=xn(99);class y2{constructor(e,t){this.min=e,this.max=typeof t>"u"?e:t}includes(e){return this.min<=e&&e<=this.max}toString(){const{min:e,max:t}=this;return e===t?String(e):[e,t].join(":")}toJSON(){return[this.min,this.max]}}class B0{constructor(e){if(e instanceof this.constructor)return e;e instanceof Array?this._values=e.slice(0):e?this._values=[e]:this._values=[]}append(e){const t=this._values;return t[t.length]=e,this}remove(e){const t=this._values,n=t.indexOf(e);return n>=0&&t.splice(n,1),this}toString(){return this._values.join(",")}toJSON(){const e=this._values,t=[];for(let n=0,i=e.length;n<i;++n){const s=e[n];t[n]=s.toJSON?s.toJSON():s}return t}}class k0 extends B0{includes(e){const t=this._values;for(let n=0,i=t.length;n<i;++n)if(t[n].includes(e))return!0;return!1}}const hu=[];class G0 extends B0{constructor(e,t){const n=super(e);if(t){this.upperOnly=!0;const i=n._values;for(let s=0,o=i.length;s<o;++s){const a=i[s];typeof a=="string"&&(i[s]=a.toUpperCase())}}else this.upperOnly=!1;return n}includes(e){return this._values.indexOf(e)!==-1}toString(){const e=this._values;hu.length=0;for(let t=0,n=e.length;t<n;++t)hu[t]=be.correctSelectorIdentifier(String(e[t]));return hu.join(",")}_validate(e){return this.upperOnly&&typeof e=="string"?e.toUpperCase():e}append(e){return super.append(this._validate(e)),this}remove(e){return super.remove(this._validate(e)),this}}class Wn{toString(){return this.keyword}toJSON(){return[this.name]}}Wn.prototype.name="Error";Wn.prototype.keyword="error";class H0 extends Wn{constructor(e){super(),this.list=e}toString(){return`${this.keyword} ${this.list}`}toJSON(){return[this.name,this.list.toJSON()]}}class $c extends H0{constructor(e){super(new k0(e))}}class rr extends H0{constructor(e,t){super(new G0(e,!t))}}class Zc extends Wn{includesAtom(e){return!1}}Zc.prototype.name="None";Zc.prototype.keyword="none";class Cf extends Wn{includesAtom(e){return!0}}Cf.prototype.name="All";Cf.prototype.keyword="all";const Td=new Zc;class Rf extends Wn{constructor(e){super(),this.rhs=e||Td}toString(){const e=this.rhs.priority&&this.rhs.priority>this.priority?`(${this.rhs})`:this.rhs;return`${this.keyword} ${e}`}toJSON(){return[this.name,this.rhs.toJSON()]}}Rf.prototype.priority=1;class Kc extends Wn{constructor(e,t){super(),this.lhs=e||Td,this.rhs=t||Td}toString(){const e=this.lhs.priority&&this.lhs.priority>this.priority?`(${this.lhs})`:this.lhs,t=this.rhs.priority&&this.rhs.priority>this.priority?`(${this.rhs})`:this.rhs;return`${e} ${this.keyword} ${t}`}toJSON(){return[this.name,this.lhs.toJSON(),this.rhs.toJSON()]}}Kc.prototype.priority=1e3;const ga={};function nn(r,e){const t=r.toLowerCase();e.prototype.keyword=t,e.prototype.name=r;const n=function(){for(var i=arguments.length,s=new Array(i),o=0;o<i;o++)s[o]=arguments[o];return new e(...s)};return n.SelectorClass=e,ga[t]=n,e}nn("Serial",class extends $c{includesAtom(e){return this.list.includes(e.serial)}});nn("Name",class extends rr{includesAtom(e){return this.list.includes(e.name)}});nn("AltLoc",class extends rr{includesAtom(e){return this.list.includes(String.fromCharCode(e.location))}});nn("Elem",class extends rr{includesAtom(e){return this.list.includes(e.element.name)}});nn("Residue",class extends rr{includesAtom(e){return this.list.includes(e.residue._type._name)}});nn("Sequence",class extends $c{includesAtom(e){return this.list.includes(e.residue._sequence)}});nn("ICode",class extends rr{constructor(e){super(e,!0)}includesAtom(e){return this.list.includes(e.residue._icode)}});nn("ResIdx",class extends $c{includesAtom(e){return this.list.includes(e.residue._index)}});nn("Chain",class extends rr{constructor(e){super(e,!0)}includesAtom(e){return this.list.includes(e.residue._chain._name)}});nn("Hetatm",class extends Wn{includesAtom(e){return e.het}});nn("PolarH",class extends Wn{includesAtom(e){return(e.flags&mi.Flags.NONPOLARH)===mi.Flags.HYDROGEN}});nn("NonPolarH",class extends Wn{includesAtom(e){return(e.flags&mi.Flags.NONPOLARH)===mi.Flags.NONPOLARH}});nn("All",Cf);nn("None",Zc);const W0=ga.none();function Pf(r,e,t){return t.prototype.priority=e,nn(r,t)}Pf("Not",1,class extends Rf{includesAtom(e){return!this.rhs.includesAtom(e)}});Pf("And",2,class extends Kc{includesAtom(e){return this.lhs.includesAtom(e)&&this.rhs.includesAtom(e)}});Pf("Or",3,class extends Kc{includesAtom(e){return this.lhs.includesAtom(e)||this.rhs.includesAtom(e)}});function ri(r,e){return nn(e,class extends Wn{includesAtom(t){return(t.residue._type.flags&r)!==0}})}ri(gt.Flags.PROTEIN,"Protein");ri(gt.Flags.BASIC,"Basic");ri(gt.Flags.ACIDIC,"Acidic");ri(gt.Flags.BASIC|gt.Flags.ACIDIC,"Charged");ri(gt.Flags.POLAR,"Polar");ri(gt.Flags.NONPOLAR,"NonPolar");ri(gt.Flags.AROMATIC,"Aromatic");ri(gt.Flags.NUCLEIC,"Nucleic");ri(gt.Flags.PURINE,"Purine");ri(gt.Flags.PYRIMIDINE,"Pyrimidine");ri(gt.Flags.WATER,"Water");const Ft=Object.create(ga);Ft.Selector=Wn;Ft.RangeListSelector=$c;Ft.ValueListSelector=rr;Ft.Range=y2;Ft.RangeList=k0;Ft.ValueList=G0;Ft.PrefixOperator=Rf;Ft.InfixOperator=Kc;Ft.Context=Object.create({});Ft.GetSelector=function(r){if(!Ft.Context.hasOwnProperty(r))throw{message:`selector ${r} is not registered`};return Ft.Context[r]||W0};Ft.ClearContext=function(){Object.keys(Ft.Context).forEach(r=>{delete Ft.Context[r]})};Ft.keyword=function(r){return ga[r.toLowerCase()]||ga.none};Ft.parse=function(r){const e={};try{e.selector=wc.parser.parse(r)}catch(t){e.selector=W0,e.error=t.message}return e};wc.parser.yy=Ft;wc.parser.yy.parseError=wc.parser.parseError;const er=Ft;class x2{constructor(e){this._complex=e,this._selector=er.keyword("All")(),this._boundaries={boundingBox:new x.Box3,boundingSphere:new x.Sphere}}computeBoundaries(){const e=this._complex._atoms,t=e.length,n=this._selector,{boundingBox:i}=this._boundaries;if(i.makeEmpty(),t===1){i.expandByPoint(e[0].position);const a=new x.Vector3;i.getCenter(a);const l=2*e[0].element.radius;i.setFromCenterAndSize(a,new x.Vector3(l,l,l))}else for(let a=0;a<t;++a)n.includesAtom(e[a])&&i.expandByPoint(e[a].position);let s=0;const o=new x.Vector3;if(i.getCenter(o),t===1)this._boundaries.boundingSphere.set(o,e[0].element.radius);else{for(let a=0;a<t;++a){if(!n.includesAtom(e[a]))continue;const l=e[a].position,c=o.distanceToSquared(l);s<c&&(s=c)}this._boundaries.boundingSphere.set(o,Math.sqrt(s))}}getTransforms(){return[]}getSelector(){return this._selector}getBoundaries(){return this._boundaries}finalize(){}}const X0=x2;class v2 extends X0{constructor(e){super(e),this.chains=[],this.matrices=[]}computeBoundaries(){super.computeBoundaries();const{matrices:e}=this,t=this._boundaries.boundingSphere.center,n=this._boundaries.boundingSphere.radius,i=this._boundaries.boundingBox=new x.Box3;i.makeEmpty();for(let a=0,l=e.length;a<l;++a)i.expandByPoint(t.clone().applyMatrix4(e[a]));const s=i.max.distanceTo(i.min)/2+n,o=new x.Vector3;i.getCenter(o),this._boundaries.boundingSphere=new x.Sphere().set(o,s),i.max.addScalar(n),i.min.subScalar(n)}addChain(e){this.chains[this.chains.length]=e}addMatrix(e){this.matrices[this.matrices.length]=e}getTransforms(){return this.matrices}finalize(){this.chains.length>0?this._selector=er.keyword("Chain")(this.chains):this._selector=er.keyword("None")()}}const If=v2;class S2{constructor(e){this._complex=e,this._index=-1,this._residueIndices=[],this._cycles=[],this._subDivs=[],this._residueCount=0}getResidues(){return this._complex._residues}getResidueCount(){return this._residueCount}forEachResidue(e){const t=this._complex._residues,n=this._residueIndices;for(let i=0,s=n.length;i<s;++i)for(let o=n[i].start,a=n[i].end;o<=a;++o)e(t[o])}setSubDivs(e){this._subDivs=e;let t=0;const n=[];let i=0;for(let s=0,o=e.length;s<o;++s)if(s===o-1||e[s].end+1!==e[s+1].start){const{start:a}=e[t],{end:l}=e[s];n[n.length]={start:a,end:l},i+=l-a+1,t=s+1}this._residueIndices=n,this._residueCount=i}getComplex(){return this._complex}forEachBond(e){const t=this._complex._bonds;for(let n=0,i=t.length;n<i;++n){const s=t[n];s._left.residue._component===this&&e(s)}}update(){this.forEachCycle(e=>{e.update()})}forEachAtom(e){this.forEachResidue(t=>{t.forEachAtom(e)})}addCycle(e){this._cycles.push(e)}forEachCycle(e){const t=this._cycles;for(let n=0,i=t.length;n<i;++n)e(t[n])}markResidues(){const e=this;e.forEachResidue(t=>{t._component=e})}_forEachSubChain(e,t){const n=this._complex._residues,i=this._subDivs;for(let s=0,o=i.length;s<o;++s)for(let a=i[s].start,l=i[s].end;a<=l;++a){const c=n[a];if(e&c._mask&&c._isValid){let h=a+1;for(;h<=l;++h){const u=n[h];if(!(e&u._mask&&u._isValid))break}t(s,a,h-1),a=h}}}getMaskedSequences(e){const t=[];let n=0;return this._forEachSubChain(e,(i,s,o)=>{t[n++]={start:s,end:o}}),t}getMaskedSubdivSequences(e){const t=[];let n=-1,i=-1;const s=this._subDivs;return this._forEachSubChain(e,(o,a,l)=>{i!==o&&(++n,t[n]={arr:[],boundaries:s[o]},i=o),t[n].arr[t[n].arr.length]={start:a,end:l}}),t}}const ag=S2,Do=32,uu=1024*1024,du=4,b2=14,fu=-1,w2=89237;class M2{constructor(e){this.numPairs=0,this.numMaxPairs=e,this.intBuffer=be.allocateTyped(Int32Array,e*du);for(let t=0;t<e*du;t++)this.intBuffer[t]=fu;this.hashBuffer=be.allocateTyped(Int32Array,uu*Do);for(let t=0;t<uu*Do;t++)this.hashBuffer[t]=fu}destroy(){this.intBuffer=null,this.hashBuffer=null}addPair(e,t){const n=e<t?e:t,i=e>t?e:t,s=n+(i<<b2);let a=(n+i*w2&uu-1)*Do,l=0;for(;l<Do;l++){const c=this.hashBuffer[a+l];if(c===fu)break;if(c===s)return!1}if(l>=Do)throw new Error("addPair: increase cMaxPairsForHashCode");if(this.hashBuffer[a+l]=s,this.numPairs>=this.numMaxPairs)throw new Error("addPair: increase num pairs");return a=this.numPairs*du,this.intBuffer[a]=n,this.intBuffer[a+1]=i,this.intBuffer[a+2]=s,this.numPairs++,!0}}const j0=M2,A2=4,lg=32,cg=.45,E2=.001;function hg(r){const{element:e}=r;if(e)return e.radiusBonding;throw new Error("_getBondingRadius: Logic error.")}function T2(r){return!r.isHet()||r.bonds&&r.bonds.length===0}class C2{constructor(e){this._complex=e,this._maxRad=1.8;const t=this._complex.getDefaultBoundaries().boundingBox;this._vBoxMin=t.min.clone(),this._vBoxMax=t.max.clone(),this._pairCollection=null}_addExistingPairs(){const e=this._complex.getAtoms(),t=e.length;let n=0;const i=this._pairCollection;for(;n<t;n++){const{bonds:s}=e[n],o=s.length;for(let a=0;a<o;a++){const l=s[a];l._left.index===n&&i.addPair(n,l._right.index)}}return 0}_findPairs(){const e=this._complex.getVoxelWorld();if(e===null)return;const t=this._complex._atoms,n=t.length,i=this;let s,o,a,l,c;const h=function(u){if(o&&u.isHydrogen())return;const d=u.location;if(l!==lg&&d!==lg&&l!==d)return;const f=a.distanceToSquared(u.position),p=u.element.radiusBonding,_=s+p+cg;f>_*_||f<E2||i._pairCollection.addPair(c.index,u.index)};for(let u=0;u<n;++u)c=t[u],T2(c)&&(s=c.element.radiusBonding,o=c.isHydrogen(),a=c.position,l=c.location,e.forEachAtomWithinRadius(a,2*this._maxRad+cg,h))}_addPairs(){const e=this._complex._atoms;for(let t=0,n=0;t<this._pairCollection.numPairs;t++,n+=4){const i=this._pairCollection.intBuffer[n],s=this._pairCollection.intBuffer[n+1];this._addPair(e[i],e[s])}}_addPair(e,t){const n=e.bonds,i=e.index,s=t.index;for(let c=0,h=n.length;c<h;++c){const u=n[c];if(u._left.index===s||u._right.index===s)return}const o=i<s?e:t,a=i<s?t:e,l=this._complex.addBond(o,a,0,Ua.BondType.UNKNOWN,!1);n.push(l),t.bonds.push(l)}build(){this._buildInner()}_buildInner(){const e=this._complex._atoms;if(!(e.length<2)){if(e[0].index<0)throw new Error("AutoBond: Atoms in complex were not indexed.");this._calcBoundingBox(),this._pairCollection=new j0(e.length*A2),this._addExistingPairs(),this._findPairs(),this._addPairs()}}_calcBoundingBox(){const e=this._complex._atoms,t=e.length;let n=hg(e[0]);for(let i=1;i<t;++i)n=Math.max(n,hg(e[i]));this._vBoxMax.addScalar(n),this._vBoxMin.addScalar(-n),this._maxRad=n*1.2}destroy(){this._pairCollection&&this._pairCollection.destroy()}}const R2=C2,P2=.1,Lf=Ua.BondType.AROMATIC,ug=[ma.ByName.C.number,ma.ByName.N.number],I2=(function(){const r=new x.Vector3,e=new x.Vector3,t=new x.Vector3;return function(n,i){return r.copy(n).normalize(),e.copy(i).normalize(),t.crossVectors(r,e),t.length()>P2?!1:r.dot(e)>=0}})();function dg(r,e){let t=0;for(;t<r.length&&r[t]<e;)++t;r.splice(t,0,e)}function fg(r,e){return r._left===e?r._right:r._left}function L2(r,e){const t=r.dot(e)/Math.sqrt(r.lengthSq()*e.lengthSq());return x.MathUtils.clamp(t,-1,1)}function N2(r){r._type=Lf}class O2{constructor(e){this.atoms=e,this.update()}update(){const{atoms:e}=this,t=new x.Vector3,n=e.length;for(let i=0;i<n;++i)t.add(e[i].position);t.multiplyScalar(1/n),this.center=t,this.radius=t.distanceTo(e[0].position.clone().lerp(e[1].position,.5))}forEachBond(e){const{atoms:t}=this,n=t.length;let i=t[0],s;function o(a){(a._left===s||a._right===s)&&e(a)}for(let a=0;a<n;++a)s=t[(a+1)%n],i.forEachBond(o),i=s}}function pg(r){return r._type===Lf}function D2(r){if(r.type===Lf)return!0;const e=ug.indexOf(r._right.element.number),t=ug.indexOf(r._left.element.number);return e!==-1&&t!==-1}function U2(r){return r.length>3}function F2(r){return console.assert(r.length>2),!0}class z2{constructor(e){this._complex=e;const t=new Array(e._bonds.length),n=new Array(e._bonds.length);for(let i=0,s=t.length;i<s;++i)t[i]=[],n[i]=!1;this._bondsData=t,this._bondMarks=n,this._resetCycles()}_resetCycles(){this._cycles=[],this._currIdx=-1}_haveSameCycle(e,t,n){const i=e[t._index],s=e[n._index],o=i.length,a=s.length;let l=0,c=0;for(;l<o&&c<a;){if(i[l]===s[c])return!0;i[l]>s[c]?++c:++l}return!1}_tryBond(e,t,n){const i=[],s=this._bondsData,o=fg(e,t),a=t.position.clone().sub(o.position),l=this._currStart,c=this,h=this._bondMarks;let u=this._checkBond;h[e._index]=!0,u=u===void 0?pg:u,t.forEachBond(d=>{if(!u(d)||d===e||h[d._index]||c._haveSameCycle(s,e,d))return;const f=fg(d,t),p=f.position.clone().sub(t.position),_=f===l?-2:1-L2(a,p),g=p.cross(a);if(!I2(g,n))return;let m=0;for(;m<i.length&&i[m].val<_;)++m;i.splice(m,0,{bond:d,val:_,dir:g})});for(let d=0,f=i.length;d<f;++d){const{bond:p}=i[d],_=p._left===t?p._right:p._left;if(_===l)return++this._currIdx,this._cycles.push([t]),h[e._index]=!1,!0;if(this._tryBond(p,_,i[d].dir))return dg(s[p._index],this._currIdx),this._cycles[this._currIdx].push(t),h[e._index]=!1,!0}return h[e._index]=!1,!1}_startCycle(e){this._currStart=e._left,this._tryBond(e,e._right,new x.Vector3)&&(dg(this._bondsData[e._index],this._currIdx),this._cycles[this._currIdx].push(e._left))}_findLoops(e,t){this._checkBond=e;const n=this._complex,i=this;n.forEachComponent(s=>{i._resetCycles(),s.forEachBond(a=>{e(a)&&i._startCycle(a)});const o=i._cycles;for(let a=0,l=o.length;a<l;++a){const c=o[a];if(!t(c))continue;const h=new O2(c);h.forEachBond(N2),s.addCycle(h)}})}markCycles(){this._findLoops(pg,U2)}detectCycles(){this._findLoops(D2,F2)}}const V2=z2;function B2(r,e,t,n){const i=t-r.z,s=n-r.z,o=Math.sqrt(Math.max(e*e-i*i,0)),a=Math.sqrt(Math.max(e*e-s*s,0)),l=Math.min(o,a);let c;return t<=r.z&&n>=r.z?c=e:c=Math.max(o,a),[l,c]}function k2(r,e,t,n){const i=t-r.y,s=n-r.y,o=Math.sqrt(Math.max(e*e-i*i,0)),a=Math.sqrt(Math.max(e*e-s*s,0)),l=Math.min(o,a);let c;return t<=r.y&&n>=r.y?c=e:c=Math.max(o,a),[l,c]}class $n{constructor(e,t){this._box=e.clone();const n=new x.Vector3;e.getSize(n),this._count=n.clone().divide(t).floor().max(new x.Vector3(1,1,1)),this._last=this._count.clone().subScalar(1),this._cellSize=n.clone().divide(this._count),this._cellInnerR=.5*Math.min(Math.min(this._cellSize.x,this._cellSize.y),this._cellSize.z),this._cellOuterR=.5*Math.sqrt(this._cellSize.dot(this._cellSize));const i=this._count.x*this._count.y*this._count.z;this._voxels=be.allocateTyped(Int32Array,i);for(let s=0;s<i;++s)this._voxels[s]=-1;this._atoms=[]}addAtoms(e){const t=this;let n=this._atoms.length;this._atoms.length+=2*e.getAtomCount(),e.forEachAtom(i=>{const s=t._findVoxel(i.position);t._atoms[n]=i,t._atoms[n+1]=t._voxels[s],t._voxels[s]=n,n+=2})}static _zero=new x.Vector3(0,0,0);static _voxel=new x.Vector3;_findVoxel(e){const t=$n._zero,n=$n._voxel;return n.copy(e).sub(this._box.min).divide(this._cellSize).floor().clamp(t,this._last),n.x+this._count.x*(n.y+this._count.y*n.z)}_forEachAtomInVoxel(e,t){for(let n=this._voxels[e];n>=0;n=this._atoms[n+1])t(this._atoms[n])}static _xRange=new x.Vector2;static _yRange=new x.Vector2;static _zRange=new x.Vector2;_forEachVoxelWithinRadius(e,t,n){const i=$n._xRange,s=$n._yRange,o=$n._zRange;if(t/this._cellInnerR<10){this._forEachVoxelWithinRadiusSimple(e,t,n);return}let a,l,c,h,u,d,f,p;o.set(e.z-t,e.z+t),o.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0,this._count.z-1);for(let _=o.x;_<=o.y;++_){u=[this._box.min.z+_*this._cellSize.z,this._box.min.z+(_+1)*this._cellSize.z],p=e.z-t<=u[0]&&u[1]<=e.z+t,a=B2(e,t,u[0],u[1]),s.set(e.y-a[1],e.y+a[1]),s.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0,this._count.y-1);for(let g=s.x;g<=s.y;++g){h=[this._box.min.y+g*this._cellSize.y,this._box.min.y+(g+1)*this._cellSize.y],f=e.y-a[0]<=h[0]&&h[1]<=e.y+a[0],l=k2(e,a[1],h[0],h[1]),i.set(e.x-l[1],e.x+l[1]),i.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0,this._count.x-1);for(let{x:m}=i;m<=i.y;++m)c=[this._box.min.x+m*this._cellSize.x,this._box.min.x+(m+1)*this._cellSize.x],d=e.x-l[0]<=c[0]&&c[1]<=e.x+l[0],n(m+this._count.x*(g+this._count.y*_),d&&f&&p)}}}static _vCenter=new x.Vector3;_forEachVoxelWithinRadiusSimple(e,t,n){const i=$n._xRange,s=$n._yRange,o=$n._zRange,a=$n._vCenter,l=(t+this._cellOuterR)*(t+this._cellOuterR);let c=-1;t>this._cellOuterR&&(c=(t-this._cellOuterR)*(t-this._cellOuterR)),i.set(e.x-t,e.x+t),i.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor(),i.x=Math.min(Math.max(i.x,0),this._count.x-1),i.y=Math.min(Math.max(i.y,0),this._count.x-1),s.set(e.y-t,e.y+t),s.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor(),s.x=Math.min(Math.max(s.x,0),this._count.y-1),s.y=Math.min(Math.max(s.y,0),this._count.y-1),o.set(e.z-t,e.z+t),o.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor(),o.x=Math.min(Math.max(o.x,0),this._count.z-1),o.y=Math.min(Math.max(o.y,0),this._count.z-1);for(let h=o.x;h<=o.y;++h){const u=[this._box.min.z+h*this._cellSize.z,this._box.min.z+(h+1)*this._cellSize.z];a.z=.5*(u[0]+u[1]);for(let d=s.x;d<=s.y;++d){const f=[this._box.min.y+d*this._cellSize.y,this._box.min.y+(d+1)*this._cellSize.y];a.y=.5*(f[0]+f[1]);for(let{x:p}=i;p<=i.y;++p){const _=[this._box.min.x+p*this._cellSize.x,this._box.min.x+(p+1)*this._cellSize.x];a.x=.5*(_[0]+_[1]);const g=e.distanceToSquared(a);g<=l&&n(p+this._count.x*(d+this._count.y*h),g<=c)}}}}forEachAtomWithinRadius(e,t,n){const i=this,s=t*t;i._forEachVoxelWithinRadius(e,t,(o,a)=>{a?i._forEachAtomInVoxel(o,n):i._forEachAtomInVoxel(o,l=>{e.distanceToSquared(l.position)<=s&&n(l)})})}forEachAtomWithinDistFromMasked(e,t,n,i){this._forEachAtomWithinDistFromGroup(s=>{e.forEachAtom(o=>{(o.mask&t)!==0&&s(o)})},n,i)}forEachAtomWithinDistFromSelected(e,t,n,i){this._forEachAtomWithinDistFromGroup(s=>{e.forEachAtom(o=>{t.includesAtom(o)&&s(o)})},n,i)}_forEachAtomWithinDistFromGroup(e,t,n){const i=this,s=t*t,o=[],a=[];let l=0;e(u=>{i._forEachVoxelWithinRadius(u.position,t,(d,f)=>{f?o[d]=-1:typeof o[d]>"u"?(a.push(u),a.push(-1),o[d]=l,l+=2):o[d]!==-1&&(a.push(u),a.push(o[d]),o[d]=l,l+=2)})});let c;const h=function(u){if(!(typeof o[c]>"u")){if(l=o[c],l===-1){n(u);return}for(;l>=0;l=a[l+1])if(u.position.distanceToSquared(a[l].position)<s){n(u);break}}};for(c in o)o.hasOwnProperty(c)&&i._forEachAtomInVoxel(c,h)}}const Y0=$n,Vl=.5,pu=-9.9,mg=-.5,Bl=-27.888,G2=5,H2=1e3;class W2{constructor(e){this._complex=e,this._hbonds=[],this._complex._residues.length>H2?this._buildVW():this._build()}isBond(e,t){if(this._hbonds[e]){const[n,i]=this._hbonds[e].acceptor;if(n&&n.residue===t&&n.energy<mg||i&&i.residue===t&&i.energy<mg)return!0}return!1}_build(){const e=this;for(let t=0;t<this._complex._residues.length-1;++t){const n=this._complex._residues[t];if((n.getType().flags&gt.Flags.PROTEIN)===0)continue;let i=null;t>0&&this._complex._residues[t-1].getType().flags&gt.Flags.PROTEIN&&n._sequence===this._complex._residues[t-1]._sequence+1&&(i=this._complex._residues[t-1]);for(let s=t+1;s<this._complex._residues.length;++s){const o=this._complex._residues[s];if((o.getType().flags&gt.Flags.PROTEIN)===0)continue;let a=null;this._complex._residues[s-1].getType().flags&gt.Flags.PROTEIN&&o._sequence===this._complex._residues[s-1]._sequence+1&&(a=this._complex._residues[s-1]),e._calcHBondEnergy(i,n,o),s!==t+1&&e._calcHBondEnergy(a,o,n)}}}_buildVW(){const e=this,t=this._complex._residues;let n,i;const s=this._complex.getVoxelWorld();if(s===null)return;const o=new j0(this._complex._residues.length*this._complex._residues.length/2);function a(l){const c=l.residue;if(c._index===n._index||(c.getType().flags&gt.Flags.PROTEIN)===0||!o.addPair(n._index,c._index))return;let h=c._index>0?t[c._index-1]:null;h&&((h.getType().flags&gt.Flags.PROTEIN)===0||c._sequence!==h._sequence+1)&&(h=null),e._calcHBondEnergy(i,n,c),c._index!==n._index+1&&e._calcHBondEnergy(h,c,n)}for(let l=0;l<t.length-1;++l)n=t[l],(n.getType().flags&gt.Flags.PROTEIN)!==0&&(i=l>0?t[l-1]:null,i&&((i.getType().flags&gt.Flags.PROTEIN)===0||n._sequence!==i._sequence+1)&&(i=null),s.forEachAtomWithinRadius(this._residueGetCAlpha(n),G2,a))}_residueGetCAlpha(e){for(let t=0;t<e._atoms.length;++t){const{name:n}=e._atoms[t];if(n==="CA"||n==="C1")return e._atoms[t].position}return null}_residueGetCO(e){let t=null,n=null;return e.forEachAtom(i=>{i.name==="C"?t=i.position:i.name==="O"&&(n=i.position)}),[t,n]}_residueGetNH(e,t){const[n,i]=this._residueGetCO(e);let s;if(t.forEachAtom(o=>{o.name==="N"&&(s=o.position)}),n&&i&&s){const o=n.clone();return o.sub(i),o.multiplyScalar(1/o.length()),o.add(s),[s,o]}return[null,null]}_calcHBondEnergy(e,t,n){let i=0;if(e===null)return i;if(t.getType().getName()!=="PRO"){const[a,l]=this._residueGetNH(e,t),[c,h]=this._residueGetCO(n);if(a===null||l===null||c===null||h===null)return i;const u=l.distanceTo(h),d=l.distanceTo(c),f=a.distanceTo(c),p=a.distanceTo(h);u<Vl||d<Vl||f<Vl||p<Vl?i=pu:i=Bl/u-Bl/d+Bl/f-Bl/p,i=Math.round(i*1e3)/1e3,i<pu&&(i=pu)}typeof this._hbonds[t._index]>"u"&&(this._hbonds[t._index]={donor:[],acceptor:[]});const s=this._hbonds[t._index];s.acceptor.length<2&&s.acceptor.push({residue:n._index,energy:i}),s.acceptor.length>1&&(i<s.acceptor[0].energy?(s.acceptor[1].residue=s.acceptor[0].residue,s.acceptor[1].energy=s.acceptor[0].energy,s.acceptor[0].residue=n._index,s.acceptor[0].energy=i):i<s.acceptor[1].energy&&(s.acceptor[1].residue=n._index,s.acceptor[1].energy=i)),typeof this._hbonds[n._index]>"u"&&(this._hbonds[n._index]={donor:[],acceptor:[]});const o=this._hbonds[n._index];return o.donor.length<2&&o.donor.push({residue:t._index,energy:i}),o.donor.length>1&&(i<o.donor[0].energy?(o.donor[1].residue=o.donor[0].residue,o.donor[1].energy=o.donor[0].energy,o.donor[0].residue=t._index,o.donor[0].energy=i):i<o.donor[1].energy&&(o.donor[1].residue=t._index,o.donor[1].energy=i)),i}}const Ci=Object.freeze({NO_BRIDGE:0,PARALLEL:1,ANTI_PARALLEL:2}),Os=Object.freeze({START:1,MIDDLE:2,END:3,START_AND_END:4}),Tn=Object.freeze({STRAND:"E",BRIDGE:"B",HELIX_310:"G",HELIX_ALPHA:"H",HELIX_PI:"I",TURN:"T",BEND:"S",LOOP:" "});class Nf{constructor(e){this._complex=e,this._build()}_build(){const e=this;this._hbonds=new W2(this._complex),this._ss=[],this._sheet=[],this._betaPartners=[],this._bend=[];for(let t=0;t<this._complex.getResidues().length;++t)this._betaPartners[t]=[];this._helixFlags=[],this._helixFlags[3]=[],this._helixFlags[4]=[],this._helixFlags[5]=[],this._chainLengths=[];for(let t=0;t<this._complex._chains.length;++t){const n=this._complex._chains[t].getResidues();let i=0;for(;i<n.length&&(n[i].getType().flags&gt.Flags.PROTEIN)!==0;++i);this._chainLengths[t]=i}this._buildBetaSheets();for(let t=0;t<this._complex._chains.length;++t)e._buildAlphaHelices(this._complex._chains[t].getResidues(),this._chainLengths[t],!1)}_buildAlphaHelices(e,t,n){for(let i=3;i<=5&&!(e.length<i);++i)for(let s=0;s+i<t;++s)if(this._hbonds.isBond(e[s+i]._index,e[s]._index)){this._helixFlags[i][e[s+i]._index]=Os.END;for(let o=s+1;o<s+i;++o)typeof this._helixFlags[i][e[o]._index]>"u"&&(this._helixFlags[i][e[o]._index]=Os.MIDDLE);this._helixFlags[i][e[s]._index]===Os.END?this._helixFlags[i][e[s]._index]=Os.START_AND_END:this._helixFlags[i][e[s]._index]=Os.START}for(let i=2;i<t-2;++i){const s=this._kappa(e[i-2],e[i],e[i+2]);this._bend[e[i]._index]=s!==360&&s>70}for(let i=1;i+4<t;++i)if(this._isHelixStart(e[i]._index,4)&&this._isHelixStart(e[i-1]._index,4))for(let s=i;s<=i+3;++s)this._ss[e[s]._index]=Tn.HELIX_ALPHA;for(let i=1;i+3<t;++i)if(this._isHelixStart(e[i]._index,3)&&this._isHelixStart(e[i-1]._index,3)){let s=!0;for(let o=i;s&&o<=i+2;++o)s=typeof this._ss[e[o]._index]>"u"||this._ss[e[o]._index]===Tn.HELIX_310;if(s)for(let o=i;o<=i+2;++o)this._ss[e[o]._index]=Tn.HELIX_310}for(let i=1;i+5<t;++i)if(this._isHelixStart(e[i]._index,5)&&this._isHelixStart(e[i-1]._index,5)){let s=!0;for(let o=i;s&&o<=i+4;++o)s=typeof this._ss[e[o]._index]>"u"||this._ss[e[o]._index]===Tn.HELIX_PI||n&&this._ss[e[o]._index]===Tn.HELIX_ALPHA;if(s)for(let o=i;o<=i+4;++o)this._ss[e[o]._index]=Tn.HELIX_PI}for(let i=1;i+1<t;++i)if(typeof this._ss[e[i]._index]>"u"){let s=!1;for(let o=3;o<=5&&!s;++o)for(let a=1;a<o&&!s;++a)s=i>=a&&this._isHelixStart(e[i-a]._index,o);s?this._ss[e[i]._index]=Tn.TURN:this._bend[e[i]._index]&&(this._ss[e[i]._index]=Tn.BEND)}}_residueGetCAlpha(e){for(let t=0;t<e._atoms.length;++t){const{name:n}=e._atoms[t];if(n==="CA"||n==="C1")return e._atoms[t].position}return null}_cosinusAngle(e,t,n,i){const s=e.clone().sub(t),o=n.clone().sub(i);let a=0;const l=s.dot(s)*o.dot(o);return l>0&&(a=s.dot(o)/Math.sqrt(l)),a}_kappa(e,t,n){const i=this._residueGetCAlpha(t),s=this._residueGetCAlpha(e),o=this._residueGetCAlpha(n);if(i===null||s===null||o===null)return 180;const a=this._cosinusAngle(i,s,o,i),l=Math.sqrt(1-a*a);return Math.atan2(l,a)*180/Math.PI}_isHelixStart(e,t){return this._helixFlags[t][e]===Os.START||this._helixFlags[t][e]===Os.START_AND_END}_buildBetaSheets(){const e=[];for(let s=0;s<this._complex._chains.length;++s){const o=this._chainLengths[s];if(o<=4)continue;const a=this._complex._chains[s].getResidues();for(let l=s;l<this._complex._chains.length;++l){const c=this._chainLengths[l];if(c<=4)continue;const h=this._complex._chains[l].getResidues();for(let u=1;u+1<o;++u){const d=a[u];let f=1;for(l===s&&(f=u+3);f+1<c;++f){const p=h[f],_=this._testBridge(a,u,h,f);if(_===Ci.NO_BRIDGE)continue;let g=!1;for(const m of e)if(!(_!==m.type||d._index!==m.i[m.i.length-1]+1)){if(_===Ci.PARALLEL&&m.j[m.j.length-1]+1===p._index){m.i.push(d._index),m.j.push(p._index),g=!0;break}if(_===Ci.ANTI_PARALLEL&&m.j[0]-1===p._index){m.i.push(d._index),m.j.unshift(p._index),g=!0;break}}g||e.push({type:_,i:[d._index],chainI:d.getChain()._index,j:[p._index],chainJ:p.getChain()._index})}}}}e.sort((s,o)=>s.chainI<o.chainI||s.chainI===o.chainI&&s.i[0]<o.i[0]?-1:1);for(let s=0;s<e.length;++s)for(let o=s+1;o<e.length;++o){const a=e[s].i[0],l=e[s].i[e[s].i.length-1],c=e[s].j[0],h=e[s].j[e[s].j.length-1],u=e[o].i[0],d=e[o].i[e[o].i.length-1],f=e[o].j[0],p=e[o].j[e[o].j.length-1];if(e[s].type!==e[o].type||this._hasChainBreak(Math.min(a,u),Math.max(l,d))||this._hasChainBreak(Math.min(c,f),Math.max(h,p))||u-l>=6||l>=u&&a<=d)continue;let _=!1;e[s].type===Ci.PARALLEL?_=f-h<6&&u-l<3||f-h<3:_=c-p<6&&u-l<3||c-p<3,_&&(e[s].i=e[s].i.concat(e[o].i),e[s].type===Ci.PARALLEL?e[s].j=e[s].j.concat(e[o].j):e[s].j=e[o].j.concat(e[s].j),e.splice(o--,1))}const t=new Set;for(let s=0;s<e.length;++s)t.add(e[s]);let n=1,i=0;for(;t.size>0;){let s=t.values().next().value;t.delete(s);const o=new Set;o.add(s);let a;do{a=new Set;for(const l of o.values())for(const c of t.values())this._areBridgesLinked(l,c)&&a.add(c);for(s of a.values())o.add(s),t.delete(s)}while(a.size>0);for(s of o.values())s.ladder=i,s.sheet=n,s.link=o,++i;++n}for(let s=0;s<e.length;++s){const o=e[s];let a=0,l=0;for(let h=0;h<o.i.length;++h)if(this._betaPartners[o.i[h]][0]){a=1;break}for(let h=0;h<o.j.length;++h)if(this._betaPartners[o.j[h]][0]){l=1;break}let c=Tn.BRIDGE;if(o.i.length>1&&(c=Tn.STRAND),o.type===Ci.PARALLEL){let h=0;for(let u=0;u<o.i.length;++u)this._betaPartners[o.i[u]][a]={residue:o.j[h++],ladder:o.ladder,parallel:!0};h=0;for(let u=0;u<o.j.length;++u)this._betaPartners[o.j[u]][l]={residue:o.i[h++],ladder:o.ladder,parallel:!0}}else{let h=o.j.length-1;for(let u=0;u<o.i.length;++u)this._betaPartners[o.i[u]][a]={residue:o.j[h--],ladder:o.ladder,parallel:!1};h=o.i.length-1;for(let u=0;u<o.j.length;++u)this._betaPartners[o.j[u]][l]={residue:o.i[h--],ladder:o.ladder,parallel:!1}}for(let h=o.i[0];h<=o.i[o.i.length-1];++h)this._ss[h]!==Tn.STRAND&&(this._ss[h]=c,this._sheet[h]=o.sheet);for(let h=o.j[0];h<=o.j[o.j.length-1];++h)this._ss[h]!==Tn.STRAND&&(this._ss[h]=c,this._sheet[h]=o.sheet)}}_testBridge(e,t,n,i){let s=Ci.NO_BRIDGE;const o=e[t-1]._index,a=e[t]._index,l=e[t+1]._index,c=n[i-1]._index,h=n[i]._index,u=n[i+1]._index,d=this._hbonds.isBond.bind(this._hbonds);return d(l,h)&&d(h,o)||d(u,a)&&d(a,c)?s=Ci.PARALLEL:(d(l,c)&&d(u,o)||d(h,a)&&d(a,h))&&(s=Ci.ANTI_PARALLEL),s}_areBridgesLinked(e,t){const n=new Set(e.i),i=new Set(e.j);for(const s of t.i)if(n.has(s)||i.has(s))return!0;for(const s of t.j)if(n.has(s)||i.has(s))return!0;return!1}_hasChainBreak(e,t){for(let n=e+1;n<=t;++n)if(this._complex._residues[n]._sequence!==this._complex._residues[n-1]._sequence+1)return!0;return!1}}Nf.StructureType=Tn;const mu=5,{StructureType:rs}=Nf,kl=Ln.Type,X2={[rs.HELIX_ALPHA]:1,[rs.HELIX_PI]:3,[rs.HELIX_310]:5},j2={[rs.BRIDGE]:kl.BRIDGE,[rs.TURN]:kl.TURN,[rs.BEND]:kl.BEND,[rs.LOOP]:kl.COIL};class Of{constructor(){this._chains=[],this._components=[],this._helices=[],this._sheets=[],this.structures=[],this._residueTypes=Object.create(gt.StandardTypes),this._atoms=[],this._residues=[],this._bonds=[],this._sgroups=[],this._molecules=[],this._maskNeedsUpdate=!1,this.metadata={},this.symmetry=[],this.units=[new X0(this)],this._currentUnit=0}addAtom(e){const t=this._atoms.length;return this._atoms.push(e),t}addSheet(e){const t=this._sheets.length;return this._sheets.push(e),t}addHelix(e){const t=this._helices.length;return this._helices.push(e),t}getAtoms(){return this._atoms}getBonds(){return this._bonds}getAtomCount(){return this._atoms.length}addResidue(e){const t=this._residues.length;return this._residues.push(e),t}updateToFrame(e){this.forEachChain(t=>{t.updateToFrame(e)})}addResidueType(e){return this._residueTypes[e]=new gt(e,"Unknown","")}getResidueCount(){return this._residues.length}getResidues(){return this._residues}getSGroupCount(){return this._sgroups.length}getSGroups(){return this._sgroups}getAtomByFullname(e){const t=e.split(".");if(t.length!==3)return null;const n=t[0],i=parseInt(t[1],10);if(Number.isNaN(i))return null;const s=t[2].toUpperCase();let o=null;return this.forEachChain(a=>{o||a._name.localeCompare(n)===0&&a.forEachResidue(l=>{o||l._sequence===i&&l.forEachAtom(c=>{o||s.localeCompare(c.name)===0&&(o=c)})})}),o}addChain(e){const t=new F0(this,e);return this._chains.push(t),t}getChain(e){for(let t=0,n=this._chains.length;t<n;++t){const i=this._chains[t];if(i.getName()===e)return i}return null}getChainCount(){return this._chains.length}getMolecules(){return this._molecules}getMoleculeCount(){return this._molecules.length}forEachAtom(e){const t=this._atoms;for(let n=0,i=t.length;n<i;++n)e(t[n])}forEachBond(e){const t=this._bonds;for(let n=0,i=t.length;n<i;++n)e(t[n])}forEachResidue(e){const t=this._residues;for(let n=0,i=t.length;n<i;++n)e(t[n])}forEachChain(e){const t=this._chains;for(let n=0,i=t.length;n<i;++n)e(t[n])}forEachMolecule(e){const t=this._molecules,n=t.length;for(let i=0;i<n;++i)e(t[i])}forEachSGroup(e){const t=this._sgroups;for(let n=0,i=t.length;n<i;++n)e(t[n])}forEachComponent(e){const t=this._components;for(let n=0,i=t.length;n<i;++n)e(t[n])}forEachVisibleComponent(e){const t=this._components;for(let n=0,i=t.length;n<i;++n)e(t[n])}addBond(e,t,n,i,s){const o=new Ua(e,t,n,i,s);return this._bonds.push(o),o}getBondCount(){return this._bonds.length}getResidueType(e){return this._residueTypes[e]||null}getUnifiedSerial(e,t,n){return t+n*65536+e*16777216}splitUnifiedSerial(e){const i=Math.floor(e/16777216),s=e-i*16777216,o=Math.floor(s/65536),a=s-o*65536;return{chain:i,serial:a,iCode:o}}_fillCmpEdit(){const e=this,t=this._components;function n(){const i=new ag(e);return i._index=t.length,t[i._index]=i,i}this.forEachChain(i=>{const s=i._residues,o=s.length;if(o<1)return;let a=n(),l=s[0]._index;for(let c=0;c<o;++c){const h=s[c];h._component=a;const u=c===o-1?null:s[c+1];(!u||!h.isConnected(u)||h._index!==u._index-1)&&(a.setSubDivs([{start:l,end:h._index}]),u&&(l=u._index,a=n()))}})}_fillCmpNoedit(){const e=new ag(this);e._index=0;const t=this._residues,n=t.length;if(n===0)return;const i=[];let s=0;for(let o=0;o<n;++o){const a=t[o];a._component=e;const l=o===n-1?null:t[o+1];(!l||!a.isConnected(l))&&(i[i.length]={start:s,end:o},l&&(s=o+1))}e.setSubDivs(i),this._components[e._index]=e}_fillComponents(e){e?this._fillCmpEdit():this._fillCmpNoedit()}getCurrentUnit(){return this._currentUnit}getDefaultBoundaries(){return this.units[0].getBoundaries()}getBoundaries(){return this.units[this._currentUnit].getBoundaries()}getTransforms(){return this.units[this._currentUnit].getTransforms()}getSelector(){return this.units[this._currentUnit].getSelector()}resetCurrentUnit(){this._currentUnit=0,this.setCurrentUnit(1)}setCurrentUnit(e){return e!=null&&e!==this._currentUnit&&e>=0&&e<this.units.length?(this._currentUnit=e,!0):!1}_computeBounds(){const{units:e}=this;for(let t=0,n=e.length;t<n;++t)e[t].computeBoundaries()}onAtomPositionChanged(){this.forEachChain(e=>{e._finalize()}),this.forEachComponent(e=>{e.update()}),this._computeBounds(),this._finalizeBonds(),this.forEachSGroup(e=>{e._rebuildSGroupOnAtomChange()})}update(){this._maskNeedsUpdate&&(this.updateStructuresMask(),this._maskNeedsUpdate=!1)}_finalizeBonds(){const e=this.getBonds(),t=e.length;for(let n=0;n<t;++n)e[n]._index=n}finalize(e){e=e||{};const t=this._bonds;let n,i;for(n=t.length-1;n>=0;n--){const p=t[n];p._left===null||p._right===null?t.splice(n,1):(p._left.bonds.push(p),p._right.bonds.push(p))}const s=this._residues;for(n=0,i=s.length;n<i;++n)s[n]._finalize();this.forEachChain(p=>{p._finalize()});const{units:o}=this;for(n=0,i=o.length;n<i;++n)o[n].finalize();this.setCurrentUnit(1);const a={};for(n=0,i=s.length;n<i;++n){const p=s[n];a[this.getUnifiedSerial(p.getChain().getName().charCodeAt(0),p.getSequence(),p.getICode().charCodeAt(0))]=p}const{structures:l}=this;for(n=0,i=l.length;n<i;++n)l[n]._finalize(e.serialAtomMap,a,this);const c=this._helices;for(n=0,i=c.length;n<i;++n)c[n]._finalize(e.serialAtomMap,a,this);const h=this._sheets;for(n=0,i=h.length;n<i;++n)h[n]._finalize(e.serialAtomMap,a,this);this._computeBounds();const u=this._atoms;for(n=0,i=u.length;n<i;++n){const p=u[n];p.index=n}if(e.needAutoBonding)try{const p=new R2(this);p.build(),p.destroy()}catch(p){console.warn("Autobonding failed:",p)}const d=this._chains;for(n=0,i=d.length;n<i;++n)d[n]._index=n;for(n=0,i=s.length;n<i;++n)s[n]._index=n;for(n=0,i=u.length;n<i;++n){const p=u[n];if(p.flags&mi.Flags.HYDROGEN&&p.bonds.length===1){const _=p.bonds[0];(_._left!==p&&_._left||_._right).flags&mi.Flags.CARBON&&(p.flags|=mi.Flags.NONPOLARH)}}this._finalizeBonds(),this._fillComponents(e.enableEditing);const f=new V2(this);f.markCycles(),e.detectAromaticLoops&&f.detectCycles(),this._finalizeMolecules()}_finalizeMolecules(){for(let e=0;e<this._molecules.length;e++){const t=this._molecules[e],n=t.residues.length;for(let i=0;i<n;i++){const s=t.residues[i];s._molecule=t}}}updateStructuresMask(){const e=t=>t.collectMask();this.forEachResidue(e),this.forEachChain(e),this.forEachMolecule(e)}countAtomsByMask(e){let t=0;return this.forEachAtom(n=>{(n.mask&e)!==0&&t++}),t}getNumAtomsBySelector(e){let t=0;return this.forEachAtom(n=>{e.includesAtom(n)&&t++}),t}resetAtomMask(e){this.forEachAtom(t=>{t.mask=e})}markAtoms(e,t){const n=t,i=~n;let s=0;const o=er.keyword("And")(e,this.getSelector());return this.forEachAtom(a=>{o.includesAtom(a)?(a.mask|=n,s++):a.mask&=i}),this._maskNeedsUpdate=!0,s}markAtomsAdditionally(e,t){const n=t;let i=0;return this.forEachAtom(s=>{e.includesAtom(s)&&(s.mask&t)!==t&&(s.mask|=n,i++)}),i}clearAtomBits(e){const t=~e;this.forEachAtom(i=>{i.mask&=t});const n=i=>{i._mask&=t};this.forEachAtom(n),this.forEachResidue(n),this.forEachChain(n),this.forEachMolecule(n)}getAtomNames(){if(this.hasOwnProperty("_atomNames"))return this._atomNames;const e={};return this.forEachAtom(t=>{e[t.name]=1}),this._atomNames=Object.keys(e),this._atomNames}getElements(){if(this.hasOwnProperty("_elements"))return this._elements;const e={};return this.forEachAtom(t=>{e[t.element.name]=1}),this._elements=Object.keys(e),this._elements}getResidueNames(){if(this.hasOwnProperty("_residueNames"))return this._residueNames;const e={};return this.forEachResidue(t=>{e[t._type._name]=1}),this._residueNames=Object.keys(e),this._residueNames}getChainNames(){if(this.hasOwnProperty("_chainNames"))return this._chainNames;const e={};return this.forEachChain(t=>{e[t._name]=1}),this._chainNames=Object.keys(e),this._chainNames}getAltLocNames(){if(this.hasOwnProperty("_altlocNames"))return this._altlocNames;const e={};return this.forEachAtom(t=>{e[String.fromCharCode(t.location)]=1}),this._altlocNames=Object.keys(e),this._altlocNames}getVoxelWorld(){if(!this.hasOwnProperty("_voxelWorld"))try{this._voxelWorld=new Y0(this.getDefaultBoundaries().boundingBox,new x.Vector3(mu,mu,mu)),this._voxelWorld.addAtoms(this)}catch{Ut.warn("Unable to create voxel world"),this._voxelWorld=null}return this._voxelWorld}addElement(e,t,n,i){const{length:s}=e;for(let o=0;o<s;++o){const a=e[o];i(a,n),t.push(a)}}joinComplexes(e){this._chains=[],this._components=[],this._helices=[],this._sheets=[],this.structures=[],this._atoms=[],this._residues=[],this._bonds=[],this._sgroups=[];const t=this;let n=0,i=0,s=0,o=0,a=0;function l(p,_){p.serial+=_,p.index+=_}function c(p,_){p._index+=_}function h(p,_){p._index+=_}function u(p,_){p._complex=t,p._index+=_}function d(p,_){p._complex=t,p._index+=_}function f(){}for(let p=0;p<e.length;++p){const _=e[p];this.addElement(_._atoms,this._atoms,n,l),this.addElement(_._bonds,this._bonds,i,c),this.addElement(_._residues,this._residues,s,h),this.addElement(_._chains,this._chains,o,u),this.addElement(_._sheets,this._sheets,0,f),this.addElement(_._helices,this._helices,0,f),this.addElement(_._sgroups,this._sgroups,0,f),this.addElement(_._components,this._components,a,d),this.addElement(_.structures,this.structures,0,f);for(const g in _._residueTypes)_._residueTypes.hasOwnProperty(g)&&(this._residueTypes[g]=_._residueTypes[g]);n+=_._atoms.length,i+=_._bonds.length,s+=_._residues.length,o+=_._chains.length,a+=_._components.length}this._computeBounds()}dssp(){const e=new Nf(this),t=this.structures=[],n=this._helices=[],i=this._sheets=[],s=h=>{let u=i[h];return u||(u=i[h]=new V0(String(h),0)),u};let o,a,l=0,c=null;for(let h=0,u=this._residues.length;h<u;++h){const d=e._ss[h],f=this._residues[h],p=e._sheet[h];if(d===o&&p===a){f._secondary=c,c&&(c.term=f),c instanceof Ed&&c.length++;continue}const _=X2[d],g=j2[d];if(d===rs.STRAND){const m=s(p);c=new Tf(m,f,f,0,null,null),m.addStrand(c)}else _!==void 0?(l++,c=new Ed(_,f,f,l,String(l),"",1),n.push(c)):g!==void 0?c=new Ln(g,f,f):c=null;c&&t.push(c),f._secondary=c,o=d,a=p}this._sheets=i.filter(h=>!0)}}Of.prototype.id="Complex";Of.prototype.name="";const Df=Of;function gg(r){let e=2;for(r=r-1>>1;r;)e<<=1,r>>=1;return e}class Jc{constructor(e,t,n,i,s,o){switch(this._box=n.clone(),this._dimVec=Math.max(Math.floor(i||1),1),this._volumeInfo=o,t instanceof Array?[this._dimX,this._dimY,this._dimZ]=t:(this._dimX=t.x,this._dimY=t.y,this._dimZ=t.z),this._dimX=Math.max(Math.floor(this._dimX),1),this._dimY=Math.max(Math.floor(this._dimY),1),this._dimZ=Math.max(Math.floor(this._dimZ),1),this._rowElements=this._dimVec*this._dimX,this._planeElements=this._rowElements*this._dimY,this._totalElements=this._planeElements*this._dimZ,this._data=s||be.allocateTyped(e,this._totalElements),this._dimVec){case 1:break;case 2:this.getValue=function(a,l,c){const h=a*this._dimVec+l*this._rowElements+c*this._planeElements;return[this._data[h],this._data[h+1]]},this.setValue=function(a,l,c,h,u){const d=a*this._dimVec+l*this._rowElements+c*this._planeElements;this._data[d]=h,this._data[d+1]=u},this.addValue=function(a,l,c,h,u){const d=a*this._dimVec+l*this._rowElements+c*this._planeElements;this._data[d]+=h,this._data[d+1]+=u};break;case 3:this.getValue=function(a,l,c){const h=a*this._dimVec+l*this._rowElements+c*this._planeElements;return[this._data[h],this._data[h+1],this._data[h+2]]},this.setValue=function(a,l,c,h,u,d){const f=a*this._dimVec+l*this._rowElements+c*this._planeElements;this._data[f]=h,this._data[f+1]=u,this._data[f+2]=d},this.addValue=function(a,l,c,h,u,d){const f=a*this._dimVec+l*this._rowElements+c*this._planeElements;this._data[f]+=h,this._data[f+1]+=u,this._data[f+2]+=d};break;default:throw new Error("Volume: invalid vector dimension")}}getValue(e,t,n){return this._data[e+t*this._rowElements+n*this._planeElements]}setValue(e,t,n,i){this._data[e+t*this._rowElements+n*this._planeElements]=i}addValue(e,t,n,i){this._data[e+t*this._rowElements+n*this._planeElements]+=i}getDimensions(){return[this._dimX,this._dimY,this._dimZ]}getBox(){return this._box}getVolumeInfo(){return this._volumeInfo}getCellSize(){const e=new x.Vector3;this._box.getSize(e);const t=new x.Vector3;return t.x=this._dimX>1?e.x/(this._dimX-1):0,t.y=this._dimY>1?e.y/(this._dimY-1):0,t.z=this._dimZ>1?e.z/(this._dimZ-1):0,t}computeGradient(){if(this._dimVec!==1)return null;const e=new Jc(Float32Array,[this._dimX,this._dimY,this._dimZ],this._box,3),t=this.getCellSize(),n=new x.Vector3(-.5/t.x,-.5/t.y,-.5/t.z);function i(h,u,d){return Math.min(d,Math.max(u,h))}const s=this._dimX,o=this._dimY,a=this._dimZ,l=this._data;function c(h,u,d){return l[d*s*o+u*s+h]}for(let h=0;h<a;++h){const u=i(h-1,0,a-1),d=i(h+1,0,a-1);for(let f=0;f<o;++f){const p=i(f-1,0,o-1),_=i(f+1,0,o-1);for(let g=0;g<s;++g){const m=i(g-1,0,s-1),v=i(g+1,0,s-1);e.setValue(g,f,h,(c(v,f,h)-c(m,f,h))*n.x,(c(g,_,h)-c(g,p,h))*n.y,(c(g,f,d)-c(g,f,u))*n.z)}}}return e}normalize(){const e=this._data;let t=e[0],n=e[0];for(let s=1;s<e.length;++s)t=Math.min(t,e[s]),n=Math.max(n,e[s]);const i=1/(n-t);if(i!==0)for(let s=0;s<e.length;++s)e[s]=i*(e[s]-t)}getTiledTextureStride(){return[this._dimX+2,this._dimY+2]}buildTiledTexture(){let e=Math.ceil(Math.sqrt(this._dimZ*this._dimY/this._dimX)),t=e*(this._dimX+2)-1;t=gg(t),e=Math.floor(t/(this._dimX+2));const n=Math.ceil(this._dimZ/e);let i=n*(this._dimY+2)-1;i=gg(i);const s=new Uint8Array(t*i);let o,a;for(let c=0;c<n;++c)for(let h=0;h<this._dimY;++h){o=c*e*this._planeElements+h*this._rowElements,a=t*(c*(this._dimY+2)+h);for(let u=0;u<e;++u){for(let d=0;d<this._dimX;++d)s[a++]=255*this._data[o++];s[a++]=255*this._data[o-1],u<e-1&&(o+=this._planeElements-this._rowElements,s[a++]=255*this._data[o])}}for(let c=0;c<n;++c){o=t*(c*(this._dimY+2)+this._dimY-1),a=o+t;for(let h=0;h<t;++h)s[a++]=s[o++];if(c<n-1){o=t*(c+1)*(this._dimY+2),a=o-t;for(let h=0;h<t;++h)s[a++]=s[o++]}}const l=new x.DataTexture(s,t,i,x.LuminanceFormat,x.UnsignedByteType,x.UVMapping,x.ClampToEdgeWrapping,x.ClampToEdgeWrapping,x.LinearFilter,x.LinearFilter);return l.needsUpdate=!0,l}getData(){return this._data}getDirectIdx(e,t,n){return e*this._dimVec+t*this._rowElements+n*this._planeElements}getStrideX(){return this._dimVec}getStrideY(){return this._rowElements}getStrideZ(){return this._planeElements}}Jc.prototype.id="Volume";const q0=Jc;class Y2{constructor(e,t,n){this.complex=e,this.name=t||"",this.residues=[],this.mask=1,this.index=n||-1}forEachResidue(e){const{residues:t}=this;for(let n=0,i=t.length;n<i;++n)e(t[n])}collectMask(){let e=4294967295;const{residues:t}=this;for(let n=0,i=t.length;n<i;++n)e&=t[n]._mask;this.mask=e}}const q2=Y2,Bt={Atom:mi,Element:ma,Bond:Ua,Residue:bc,ResidueType:gt,Chain:F0,Helix:Ed,Strand:Tf,Sheet:V0,SGroup:_2,Assembly:If,Complex:Df,Volume:q0,VoxelWorld:Y0,selectors:er,Molecule:q2};class Uf extends x.Object3D{constructor(e){super();const t=this;this._element=e,this._element.style.position="absolute",this.addEventListener("removed",()=>{t._element.parentNode!==null&&t._element.parentNode.removeChild(t._element)})}getElement(){return this._element}setTransparency(e){const t=this.getElement();if(t===null)return;if(e===1){t.style.display="none";return}t.style.display="inline";const n=1-e,i=n.toString(),s=n*100;t.style.opacity=i,t.style.filter=`alpha(opacity=${s})`}clone(){const e=new Uf(this._element);return e.copy(this),e}}const Ff=Uf;class $2 extends x.Group{raycast(e,t){if(!this.visible)return;const{children:n}=this;for(let i=0,s=n.length;i<s;++i)n[i].raycast(e,t)}enableSubset(e,t){const{children:n}=this;for(let i=0,s=n.length;i<s;++i)n[i].enableSubset&&n[i].enableSubset(e,t)}disableSubset(e,t){const{children:n}=this;for(let i=0,s=n.length;i<s;++i)n[i].disableSubset&&n[i].disableSubset(e,t)}isEmpty(){return this.children.length===0}updateToFrame(e){const{children:t}=this;for(let n=0,i=t.length;n<i;++n)t[n].updateToFrame&&t[n].updateToFrame(e)}getSubset(e,t){const n=[],{children:i}=this;for(let s=0,o=i.length;s<o;++s)i[s].getSubset&&Array.prototype.push.apply(n,i[s].getSubset(e,t));return n}}const or=$2,bs=`uniform mat4 projectionMatrix;\r
uniform mat4 modelViewMatrix;\r
\r
attribute vec2 uv;\r
attribute vec3 position;\r
\r
varying vec2 vUv;\r
\r
void main() {\r
  vUv = uv;\r
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r
}\r
`,Z2=`precision highp float;\r
\r
varying vec2 vUv;\r
uniform sampler2D srcTex;\r
uniform float opacity;\r
\r
void main() {\r
  vec4 color = texture2D(srcTex, vUv);\r
  gl_FragColor = vec4(color.xyz, color.a * opacity);\r
}\r
`,K2=`precision highp float;\r
\r
varying vec2 vUv;\r
uniform sampler2D srcTex;\r
uniform float coef;\r
\r
void main() {\r
  vec2 uv = vUv * 2.0 - 1.0;\r
  float r2 = dot(uv, uv);\r
  vec2 tc = uv * (1.0 + coef * r2);\r
  if (!all(lessThan(abs(tc), vec2(1.0))))\r
    discard;\r
  tc = 0.5 * (tc + 1.0);\r
  gl_FragColor = texture2D(srcTex, tc);\r
}\r
`,Cd={DEFAULT:0,VOLUME:1,TRANSPARENT:2,PREPASS_TRANSPARENT:3,VOLUME_BFPLANE:4,COLOR_FROM_POSITION:5,SHADOWMAP:6},_g=[Cd.DEFAULT,Cd.TRANSPARENT];x.Object3D.prototype.resetTransform=function(){this.position.set(0,0,0),this.quaternion.set(0,0,0,1),this.scale.set(1,1,1)};x.Object3D.prototype.updateMatrixWorldRecursive=function(){this.parent!=null&&this.parent.updateMatrixWorldRecursive(),this.updateMatrixWorld()};x.Object3D.prototype.addSavingWorldTransform=(function(){const r=new x.Matrix4;return function(e){e instanceof x.Object3D&&(r.copy(this.matrixWorld).invert(),r.multiply(e.matrixWorld),e.matrix.copy(r),e.matrix.decompose(e.position,e.quaternion,e.scale),this.add(e))}})();x.WebGLRenderer.prototype.renderDummyQuad=(function(){const r=new x.MeshBasicMaterial({transparent:!0,opacity:0,depthWrite:!1}),e=new x.Scene,t=new x.Mesh(new x.PlaneGeometry(.01,.01),r);e.add(t);const n=new x.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4);return n.position.z=100,function(){this.render(e,n)}})();x.WebGLRenderer.prototype.renderScreenQuad=(function(){const r=new x.Scene,e=new x.Mesh(new x.PlaneGeometry(1,1));r.add(e);const t=new x.OrthographicCamera(-.5,.5,.5,-.5,-1e4,1e4);return t.position.z=100,function(n){e.material=n,this.render(r,t)}})();x.Matrix4.prototype.isIdentity=(function(){const r=new x.Matrix4;return function(){return r.equals(this)}})();x.Matrix4.prototype.applyToPointsArray=function(r,e,t){if(!r||!e||e<3)return r;t=t||0;const n=this.elements;for(let i=0;i<r.length;i+=e){const s=r[i],o=r[i+1],a=r[i+2],l=1/(n[3]*s+n[7]*o+n[11]*a+n[15]);r[i]=(n[0]*s+n[4]*o+n[8]*a+n[12]*t)*l,r[i+1]=(n[1]*s+n[5]*o+n[9]*a+n[13]*t)*l,r[i+2]=(n[2]*s+n[6]*o+n[10]*a+n[14]*t)*l}return r};class $0 extends x.RawShaderMaterial{constructor(e){e.uniforms===void 0&&(e.uniforms={}),e.uniforms.srcTex={type:"t",value:null},e.vertexShader=bs,e.transparent=!1,e.depthTest=!1,e.depthWrite=!1,super(e)}}x.WebGLRenderer.prototype.renderScreenQuadFromTex=(function(){const r=new $0({uniforms:{opacity:{type:"f",value:1}},fragmentShader:Z2,transparent:!0});return function(e,t){r.uniforms.srcTex.value=e,r.transparent=t<1,r.uniforms.opacity.value=t,this.renderScreenQuad(r)}})();x.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion=(function(){const r=new $0({uniforms:{coef:{type:"f",value:1}},fragmentShader:K2});return function(e,t){r.uniforms.srcTex.value=e,r.uniforms.coef.value=t,this.renderScreenQuad(r)}})();x.PerspectiveCamera.prototype.setMinimalFov=function(r){this.aspect>=1?this.fov=r:this.fov=x.MathUtils.radToDeg(2*Math.atan(Math.tan(x.MathUtils.degToRad(r)*.5)/this.aspect))};x.StereoCamera.prototype.updateHalfSized=function(r,e){const t=r.aspect,n=r.fov;r.aspect=t/2,r.setMinimalFov(e),r.updateProjectionMatrix(),this.update(r),r.aspect=t,r.fov=n,r.updateProjectionMatrix()};x.PerspectiveCamera.prototype.setDistanceToFit=function(r,e){this.position.z=r/Math.sin(.5*x.MathUtils.degToRad(e))};x.Raycaster.prototype.intersectVisibleObject=function(r,e,t,n){const i=this.intersectObject(r,!1);if(i.length===0)return null;const s=Math.min(e.near,t);let o,a=i[0];const l=new x.Vector3;for(o=0;o<i.length&&(a=i[o],l.copy(a.point),l.applyMatrix4(e.matrixWorldInverse),!(l.z<=-s));++o);if(o===i.length)return null;const c=Math.min(e.far,n);return l.copy(a.point),l.applyMatrix4(e.matrixWorldInverse),l.z<=-c?null:a};x.Matrix4.prototype.extractScale=(function(){const r=new x.Vector3;return function(e){e===void 0&&(Ut.debug("extractScale(): new is too expensive operation to do it on-the-fly"),e=r.clone());const t=this.elements;return e.x=r.set(t[0],t[1],t[2]).length(),e.y=r.set(t[4],t[5],t[6]).length(),e.z=r.set(t[8],t[9],t[10]).length(),this.determinant()<0&&(e.x=-e.x),e}})();function J2(r,e,t){const n=r.clone().lerp(e,.5),i=new x.Matrix4;i.makeScale(t,r.distanceTo(e),t);const s=new x.Matrix4;s.makeRotationX(Math.PI/2);const o=new x.Matrix4,a=new x.Vector3(0,1,0);return o.lookAt(n,e,a),o.multiply(s),o.multiply(i),o.setPosition(n),o}function Q2(r,e,t,n){const i=new x.Matrix4;i.makeScale(n.x,n.y,0);const s=new x.Matrix4;return s.lookAt(r,e,t),s.multiply(i),s.setPosition(r),s}function eC(r){let e=!1;return r.traverse(t=>{(t.hasOwnProperty("geometry")||t instanceof Ff)&&(e=!0)}),e}function tC(r,e,t){function n(o){let l=0,c=o,h=1;for(;Math.abs(c-l)>1e-5;)h=1+t*c,l=c,c=o/(h*h);return 1/h}const i=new x.PlaneGeometry(2,2,r,e),s=i.getAttribute("position");for(let o=0;o<s.count;++o){const a=s.array[3*o],l=s.array[3*o+1],c=n(a*a+l*l);s.setXY(o,c*a,c*l)}return i}x.BufferAttribute.prototype.copyAtList=function(r,e){console.assert(this.itemSize===r.itemSize,"DEBUG: BufferAttribute.copyAtList buffers have different item size.");const{itemSize:t}=this;for(let n=0,i=e.length;n<i;++n)for(let s=0;s<t;++s)this.array[n*t+s]=r.array[e[n]*t+s];return this};function nC(r,e,t,n){t=typeof t<"u"?t:0,n=typeof n<"u"?n:r.length;for(let i=t;i<n;++i)r[i]=e}function iC(r){const{children:e}=r;for(let t=0,n=e.length;t<n;++t){const i=e[t];i.parent=null,i.dispatchEvent({type:"removed"})}r.children=[]}function Z0(r){r.traverse(e=>{(e instanceof x.Mesh||e instanceof x.LineSegments||e instanceof x.Line)&&e.geometry.dispose()}),iC(r)}function sC(r){Z0(r),r.parent?r.parent.remove(r):r.dispatchEvent({type:"removed"})}function rC(r){for(let e=0;e<_g.length;e++)if((r.layers.mask>>_g[e]&1)===1)return!0;return!1}function oC(r,e){const t=+(e!=="BA");r.traverse(n=>{n.isGroup&&(n.renderOrder=t)})}function aC(r){r.traverse(e=>{"material"in e&&(e.material=e.material.clone(!0),e.material.setValues({depthFunc:x.LessEqualDepth,overrideColor:!0,fog:!1,lights:!1,shadowmap:!1}),e.material.setUberOptions({fixedColor:new x.Color(16776960),zOffset:-1e-6}))})}function lC(r,e,t){const n=t||new x.Vector3;return n.set(0,0,0),n.addScaledVector(r,.5),n.addScaledVector(e,.5),n}const cC=x.InstancedBufferGeometry.prototype.copy;x.InstancedBufferGeometry.prototype.copy=function(r){cC.call(this,r),this.instanceCount===void 0&&(this.instanceCount=1/0)};const Je={calcCylinderMatrix:J2,calcChunkMatrix:Q2,groupHasGeometryToRender:eC,buildDistorionMesh:tC,RCGroup:or,fillArray:nC,clearTree:Z0,destroyObject:sC,belongToSelectLayers:rC,processObjRenderOrder:oC,applySelectionMaterial:aC,getMiddlePoint:lC,LAYERS:Cd},hC={boundingBox:new x.Box3(new x.Vector3(-1,-1,-1),new x.Vector3(1,1,1)),boundingSphere:new x.Sphere(new x.Vector3(0,0,0),1)};class uC extends Je.RCGroup{constructor(e,t){super(e,t),this.name=e,this._dataSource=t}release(){this.parent&&this.parent.remove(this)}getDataSource(){return this._dataSource}getBoundaries(){return hC}}const _a=uC;function yg(r){return r==null||Array.isArray(r)?r:[r]}class Jr{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:["id"];this._list=[],this._dict={},this._indices=[...t],this._indices.forEach(n=>{this._dict[n]={}}),e.forEach(n=>this.register(n))}static registerInList(e,t){e.includes(t)||e.push(t)}static unregisterFromList(e,t){const n=e.indexOf(t);n!==-1&&e.splice(n,1)}static registerInDict(e,t,n){t.forEach(i=>{i=i.toLowerCase();const s=e[i]=e[i]||[];s.includes(n)||s.push(n)})}static unregisterFromDict(e,t,n){t.forEach(i=>{i=i.toLowerCase();const s=e[i];if(s){const o=s.indexOf(n);o!==-1&&s.splice(o,1),s.length===0&&delete e[i]}})}register(e){Jr.registerInList(this._list,e),this._indices.forEach(t=>{Jr.registerInDict(this._dict[t],yg(e[t]),e)})}unregister(e){Jr.unregisterFromList(this._list,e),this._indices.forEach(t=>{Jr.unregisterFromDict(this._dict[t],yg(e[t]),e)})}get all(){return[...this._list]}get first(){return this._list[0]}keys(e){return Object.keys(this._dict[e||this._indices[0]])}get(e,t){const n=this._dict[t||this._indices[0]];if(n){const i=n[e&&e.toLowerCase()];return i&&i.length>0?i[0]:void 0}}}const ar=Jr;function dC(r){Object.defineProperties(r,{logger:{get(){return this.context&&this.context.logger?this.context.logger:Ut}},settings:{get(){return this.context&&this.context.settings?this.context.settings:te}}})}const Fa=dC;class zf{constructor(e,t){this._position=e,this._radius=t}static _sphere=new x.Sphere;raycast(e){const t=zf._sphere;t.set(this._position,this._radius);const n=new x.Vector3;return e.ray.intersectSphere(t,n)?{distance:e.ray.origin.distanceTo(n),point:n}:null}}const fC=r=>class extends r{constructor(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),i=1;i<t;i++)n[i-1]=arguments[i];super(...n),this._objects=new Array(e),this.boundingSphere=null,this.boundingBox=null}setSphere(e,t,n){this._objects[e]=new zf(t,n)}raycast(e,t){for(let n=0,i=this._objects.length;n<i;++n){const s=this._objects[n].raycast(e);s&&(s.chunkIdx=n,t.push(s))}}computeBoundingBox(){const e=this._objects;let{boundingBox:t}=this;t===null&&(this.boundingBox=t=new x.Box3),t.makeEmpty();for(let n=0,i=e.length;n<i;++n)t.expandByPoint(e[n]._position)}computeBoundingSphere(){this.computeBoundingBox();const e=this._objects,{boundingBox:t}=this;let n=0;const i=new x.Vector3;t.getCenter(i);for(let s=0,o=e.length;s<o;++s){const a=e[s]._position,l=i.distanceToSquared(a);n<l&&(n=l)}this.boundingSphere===null&&(this.boundingSphere=new x.Sphere),this.boundingSphere.set(i,Math.sqrt(n))}},K0=fC,Gl=new x.Color,Hl=4,Wl=3,{copySubArrays:xg}=be;function pC(r,e,t,n,i){r[e]=t,r[e+1]=n,r[e+2]=i}function mC(r,e,t,n,i,s){r[e]=t,r[e+1]=n,r[e+2]=i,r[e+3]=s}class gC extends K0(x.InstancedBufferGeometry){constructor(e,t,n){super(e),this._sphGeometry=n?new x.PlaneGeometry(2,2,1,1):new x.SphereBufferGeometry(1,t*2,t,0,Math.PI*2,0,Math.PI),this._init(e,this._sphGeometry)}setItem(e,t,n){mC(this._offsets,e*Hl,t.x,t.y,t.z,n),this.setSphere(e,t,n)}setColor(e,t){Gl.set(t),pC(this._colors,e*Wl,Gl.r,Gl.g,Gl.b)}startUpdate(){return!0}finishUpdate(){this.getAttribute("offset").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(e,t){const n=this._alpha;for(let i=0,s=e.length;i<s;++i)n[e[i]]=t;this.getAttribute("alphaColor").needsUpdate=!0}getSubset(e){const t=e.length,n=new x.InstancedBufferGeometry;return this._init.call(n,t,this._sphGeometry),xg(this._offsets,n._offsets,e,Hl),xg(this._colors,n._colors,e,Wl),n.boundingSphere=this.boundingSphere,n.boundingBox=this.boundingBox,[n]}_init(e,t){this.copy(t),this._offsets=be.allocateTyped(Float32Array,e*Hl),this._colors=be.allocateTyped(Float32Array,e*Wl);const n=this._alpha=be.allocateTyped(Float32Array,e);de.default.fill(n,1),this.setAttribute("offset",new x.InstancedBufferAttribute(this._offsets,Hl,!1,1)),this.setAttribute("color",new x.InstancedBufferAttribute(this._colors,Wl,!1,1)),this.setAttribute("alphaColor",new x.InstancedBufferAttribute(n,1,!1,1))}}const J0=gC,_C=65535,Ki=3,Xl=new x.Color;class Vf extends x.BufferGeometry{constructor(e,t){if(super(),this.constructor===Vf)throw new Error("Can not instantiate abstract class!");this._chunkGeo=e,this._init(e,t)}startUpdate(){return!0}finishUpdate(){this.getAttribute("position").needsUpdate=!0,this.getAttribute("normal").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0}setColor(e,t){Xl.set(t);const n=this._colors,i=this._chunkSize;for(let s=e*i,o=s+i;s<o;++s){const a=s*Ki;n[a]=Xl.r,n[a+1]=Xl.g,n[a+2]=Xl.b}}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(e,t){const n=this._alpha,i=this._chunkSize;for(let s=0,o=e.length;s<o;++s){const a=e[s]*i;de.default.fill(n,t,a,a+i)}this.getAttribute("alphaColor").needsUpdate=!0}raycast(e,t){const n=[],i=new x.Mesh;i.geometry=this,i.raycast(e,n);const s=this._chunkGeo.index.count/3;for(let o=0,a=n.length;o<a;++o)n[o].hasOwnProperty("faceIndex")&&(n[o].chunkIdx=Math.floor(n[o].faceIndex/s),t.push(n[o]))}getSubset(e){const t=e.length,n=new x.BufferGeometry;this._init.call(n,this._chunkGeo,t);const i=this._positions,s=this._normals,o=this._colors,a=n._positions,l=n._normals,c=n._colors,h=this._chunkSize*Ki;for(let u=0,d=e.length;u<d;++u){const f=u*h,p=e[u]*h,_=p+h;a.set(i.subarray(p,_),f),l.set(s.subarray(p,_),f),c.set(o.subarray(p,_),f)}return n.boundingSphere=this.boundingSphere,n.boundingBox=this.boundingBox,[n]}_init(e,t){const n=this._chunkSize=e.attributes.position.count,i=e.index.array,s=i.length,o=this._chunkSize*t,a=o>_C,l=s*t,c=this._index=be.allocateTyped(a?Uint32Array:Uint16Array,l);this._positions=be.allocateTyped(Float32Array,o*Ki),this._normals=be.allocateTyped(Float32Array,o*Ki),this._colors=be.allocateTyped(Float32Array,o*Ki);const h=this._alpha=be.allocateTyped(Float32Array,o);de.default.fill(h,1);for(let u=0;u<t;++u){const d=u*s,f=u*n;c.set(i,d);for(let p=0;p<s;++p)c[d+p]+=f}this.setIndex(new x.BufferAttribute(this._index,1)),this.setAttribute("position",new x.BufferAttribute(this._positions,Ki)),this.setAttribute("normal",new x.BufferAttribute(this._normals,Ki)),this.setAttribute("color",new x.BufferAttribute(this._colors,Ki)),this.setAttribute("alphaColor",new x.BufferAttribute(h,1))}}const Bf=Vf,Or=3,Dr=new x.Vector3,Ur=new x.Vector3,vg=new x.Matrix3;class yC extends Bf{constructor(e,t){const n=new x.CylinderGeometry(1,1,1,Math.max(3,t),2,!0);super(n,2*e);const i=this._chunkSize;this._chunkPos=this._chunkGeo.attributes.position.array,this._chunkNorms=this._chunkGeo.attributes.normal.array,this._tmpVector=be.allocateTyped(Float32Array,i*Or)}setItem(e,t,n,i){const s=this._chunkSize,o=s*2*e*Or,a=o+s*Or,l=this._tmpVector,c=this._chunkPos,h=this._chunkNorms;Dr.lerpVectors(t,n,.5);const u=Je.calcCylinderMatrix(t,Dr,i);vg.getNormalMatrix(u);let d;for(let f=0;f<s;++f)d=f*Or,Ur.fromArray(c,d),Ur.applyMatrix4(u),Ur.toArray(l,d);this._positions.set(l,o),Dr.sub(t);for(let f=0;f<s;++f)d=f*Or,l[d]+=Dr.x,l[d+1]+=Dr.y,l[d+2]+=Dr.z;this._positions.set(l,a);for(let f=0;f<s;++f)d=f*Or,Ur.fromArray(h,d),Ur.applyMatrix3(vg),Ur.toArray(l,d);this._normals.set(l,o),this._normals.set(l,a)}setColor(e,t,n){const i=2*e;super.setColor(i,t);const s=i+1;super.setColor(s,n)}}const Q0=yC,xC=65536,Uo=3;class kf extends x.BufferGeometry{constructor(e,t,n,i,s,o){super();const a=0,l=2*Math.PI;this.type="CylinderBufferGeometry",this.parameters={radiusTop:e,radiusBottom:t,height:n,radialSegments:i,heightSegments:s,openEnded:o};const c=o===!1&&e>0,h=o===!1&&t>0,u=(s+1)*i+c*(i+1)+h*(i+1),d=(2*s+c+h)*i,f=n/2,p=new x.BufferAttribute(be.allocateTyped(Float32Array,u*3),3),_=new x.BufferAttribute(be.allocateTyped(Float32Array,u*3),3),g=new x.Uint16BufferAttribute(be.allocateTyped(Uint16Array,d*Uo),1),m=new x.BufferAttribute(be.allocateTyped(Float32Array,u*2),2);console.assert(u<xC,"DEBUG: Cylinder Geometry has too many vertices (65536 max).");let v=0,y=0;const S=-(t-e)/n;for(let b=0;b<=s;b++){if(b!==s)for(let T=0;T<i;T++){const w=v+T,A=v+i+T,D=v+i+(T+1)%i,k=v+(T+1)%i;g.setXYZ(y*Uo,w,k,A),y++,g.setXYZ(y*Uo,A,k,D),y++}const M=b/s,E=M*(t-e)+e;for(let T=0;T<i;T++){const w=T/i,A=E*Math.sin(w*l+a),D=M*n-f,k=E*Math.cos(w*l+a),G=new x.Vector3(A,Math.sqrt(A*A+k*k)*S,k).normalize();p.setXYZ(v,A,D,k),_.setXYZ(v,G.x,G.y,G.z),m.setXY(v,w,M),++v}}if(c){const b=v,M=v+i;for(let E=0;E<i;++E){const T=v-i;p.setXYZ(v,p.getX(T),p.getY(T),p.getZ(T)),_.setXYZ(v,0,1,0),m.setXY(v,1,1);const w=b+(E+1)%i;g.setXYZ(y*Uo,v,w,M),y++,v++}p.setXYZ(v,0,f,0),_.setXYZ(v,0,1,0),m.setXY(v,1,1),++v}if(h){const b=v,M=v+i;for(let E=0;E<i;++E){const T=E;p.setXYZ(v,p.getX(T),p.getY(T),p.getZ(T)),_.setXYZ(v,0,-1,0),m.setXY(v,0,0);const w=b+(E+1)%i;g.setXYZ(y*Uo,w,v,M),y++,v++}p.setXYZ(v,0,-f,0),_.setXYZ(v,0,-1,0),m.setXY(v,0,0)}this.setIndex(g),this.setAttribute("position",p),this.setAttribute("normal",_),this.setAttribute("uv",m)}clone(){const{parameters:e}=this;return new kf(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded)}}const vC=kf,Ji=new x.Color,Sg=new x.Matrix4,Dt=4,Li=3,{copySubArrays:Qi}=be;function bg(r,e,t,n,i){r[e]=t,r[e+1]=n,r[e+2]=i}function Fr(r,e,t,n,i,s){r[e]=t,r[e+1]=n,r[e+2]=i,r[e+3]=s}function SC(r,e){return r-e}function bC(r){r.sort(SC);const e=[],t=[];for(let n=0,i=r.length;n<i;++n){const s=r[n],o=(s|0)%2===0,a={first:!1,second:!1};o?(a.first=!0,a.second=n+1<i&&r[n+1]===r[n]+1,a.second&&++n):a.second=!0,e.push(Math.floor(s/2)),t.push(a)}return{indices:e,cylinderInfo:t}}function wC(r,e,t){for(let n=0,i=r.length;n<i;++n){const s=r[n];s.first||(e[Li*n]=-.5),s.second||(t[Li*n]=-.5)}}class MC extends x.InstancedBufferGeometry{constructor(e,t,n,i){super(),this._useZSprites=n,this._cylGeometry=n?new x.PlaneGeometry(2,2,1,1):new vC(1,1,1,Math.max(3,t),2,i),this._init(e,this._cylGeometry,this._useZSprites),this._collisionGeo=new Q0(e,3)}setItem(e,t,n,i){const s=Je.calcCylinderMatrix(t,n,i);let o=s.elements;const a=e*Dt;this._collisionGeo.setItem(e,t,n,i),Fr(this._matVector1,a,o[0],o[4],o[8],o[12]),Fr(this._matVector2,a,o[1],o[5],o[9],o[13]),Fr(this._matVector3,a,o[2],o[6],o[10],o[14]),this._useZSprites&&(Sg.copy(s).invert(),o=Sg.elements,Fr(this._invmatVector1,a,o[0],o[4],o[8],o[12]),Fr(this._invmatVector2,a,o[1],o[5],o[9],o[13]),Fr(this._invmatVector3,a,o[2],o[6],o[10],o[14]))}setColor(e,t,n){const i=e*Li;Ji.set(t),bg(this._color1,i,Ji.r,Ji.g,Ji.b),Ji.set(n),bg(this._color2,i,Ji.r,Ji.g,Ji.b)}computeBoundingSphere(){this._collisionGeo.computeBoundingSphere(),this.boundingSphere=this._collisionGeo.boundingSphere}computeBoundingBox(){this._collisionGeo.computeBoundingBox(),this.boundingBox=this._collisionGeo.boundingBox}raycast(e,t){this._collisionGeo.raycast(e,t)}startUpdate(){return!0}finishUpdate(){this.getAttribute("matVector1").needsUpdate=!0,this.getAttribute("matVector2").needsUpdate=!0,this.getAttribute("matVector3").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0,this.getAttribute("color2").needsUpdate=!0,this.getAttribute("alphaColor").needsUpdate=!0,this._useZSprites&&(this.getAttribute("invmatVector1").needsUpdate=!0,this.getAttribute("invmatVector2").needsUpdate=!0,this.getAttribute("invmatVector3").needsUpdate=!0),this._collisionGeo.finishUpdate()}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(e,t){const n=this._alpha;for(let i=0,s=e.length;i<s;++i)n[Math.floor(e[i]/2)]=t;this.getAttribute("alphaColor").needsUpdate=!0}getSubset(e){const t=bC(e),n=t.indices,i=n.length,s=new x.InstancedBufferGeometry;return this._init.call(s,i,this._cylGeometry,this._useZSprites),Qi(this._matVector1,s._matVector1,n,Dt),Qi(this._matVector2,s._matVector2,n,Dt),Qi(this._matVector3,s._matVector3,n,Dt),this._useZSprites&&(Qi(this._invmatVector1,s._invmatVector1,n,Dt),Qi(this._invmatVector2,s._invmatVector2,n,Dt),Qi(this._invmatVector3,s._invmatVector3,n,Dt)),Qi(this._color1,s._color1,n,Li),Qi(this._color2,s._color2,n,Li),wC(t.cylinderInfo,s._color1,s._color2),s.boundingSphere=this.boundingSphere,s.boundingBox=this.boundingBox,[s]}getGeoParams(){return this._cylGeometry.parameters}_init(e,t,n){this.copy(t),this._matVector1=be.allocateTyped(Float32Array,e*Dt),this._matVector2=be.allocateTyped(Float32Array,e*Dt),this._matVector3=be.allocateTyped(Float32Array,e*Dt),this._color1=be.allocateTyped(Float32Array,e*Li),this._color2=be.allocateTyped(Float32Array,e*Li);const i=this._alpha=be.allocateTyped(Float32Array,e);de.default.fill(i,1),this.setAttribute("matVector1",new x.InstancedBufferAttribute(this._matVector1,Dt,!1,1)),this.setAttribute("matVector2",new x.InstancedBufferAttribute(this._matVector2,Dt,!1,1)),this.setAttribute("matVector3",new x.InstancedBufferAttribute(this._matVector3,Dt,!1,1)),this.setAttribute("color",new x.InstancedBufferAttribute(this._color1,Li,!1,1)),this.setAttribute("color2",new x.InstancedBufferAttribute(this._color2,Li,!1,1)),this.setAttribute("alphaColor",new x.InstancedBufferAttribute(this._alpha,1,!1,1)),n&&(this._invmatVector1=be.allocateTyped(Float32Array,e*Dt),this._invmatVector2=be.allocateTyped(Float32Array,e*Dt),this._invmatVector3=be.allocateTyped(Float32Array,e*Dt),this.setAttribute("invmatVector1",new x.InstancedBufferAttribute(this._invmatVector1,Dt,!1,1)),this.setAttribute("invmatVector2",new x.InstancedBufferAttribute(this._invmatVector2,Dt,!1,1)),this.setAttribute("invmatVector3",new x.InstancedBufferAttribute(this._invmatVector3,Dt,!1,1)))}}const ey=MC,Qt=3,gu=3,zr=new x.Vector3,Vr=new x.Vector3,jl=new x.Vector3,AC=new x.Vector3(1,0,0),wg=new x.Vector3,Mg=new x.Vector3;function EC(r,e){const t=new x.BufferGeometry,n=r.length,i=n*e,s=i<=65536?Uint16Array:Uint32Array,o=(e-1)*n*2,a=new x.BufferAttribute(be.allocateTyped(s,o*gu),1);let l=0,c=0;for(let u=0;u<e;u++){if(u!==e-1)for(let d=0;d<n;d++){const f=l+d,p=l+n+d,_=l+n+(d+1)%n,g=l+(d+1)%n;a.setXYZ(c*gu,f,g,p),c++,a.setXYZ(c*gu,p,g,_),c++}l+=n}t.setIndex(a);const h=be.allocateTyped(Float32Array,i*Qt);return t.setAttribute("position",new x.BufferAttribute(h,Qt)),t._positions=r,t}class TC extends Bf{constructor(e,t,n){const i=EC(e,t);super(i,n),this._ringsCount=t;const s=this._tmpShape=[];for(let o=0;o<e.length;++o)s[o]=new x.Vector3}setItem(e,t){let n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1,i=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1;const s=this._chunkGeo._positions.length,o=this._ringsCount,a=s*this._ringsCount*e*Qt;this._setPoints(t,s,o,a),n?this._setSlopeNormals(s,o,a):this._setBaseNormals(s,o,a),i&&this._addCut(s,o,a)}_setPoints(e,t,n,i){const s=this._tmpShape,o=this._positions,a=this._chunkGeo._positions;for(let l=0,c=i;l<n;++l){const h=e[l];for(let u=0;u<t;++u,c+=Qt)s[u].copy(a[u]).applyMatrix4(h).toArray(o,c)}}_setBaseNormals(e,t,n){const i=e*Qt;for(let s=0,o=n;s<t;++s,o+=i)this._countNormalsInRing(e,o,!1)}_setSlopeNormals(e,t,n){const i=this._normals,s=e*Qt;let o=n;for(let a=0;a<e;++a,o+=Qt)AC.toArray(i,o);if(o-2*s>0)for(let a=0;a<e;++a,o+=Qt)jl.fromArray(i,o-2*s).toArray(i,o);else this._countNormalsInRing(e,o,!0,+s),o+=s;for(let a=2;a<t;++a,o+=s)this._countNormalsInRing(e,o,!0,-s)}_countNormalsInRing(e,t,n,i){const s=this._tmpShape,o=this._normals;s[0].fromArray(this._positions,t),s[e-1].fromArray(this._positions,t+(e-1)*Qt);for(let a=0;a<e;++a,t+=Qt)a<e-1&&s[a+1].fromArray(this._positions,t+Qt),n?(Mg.fromArray(this._positions,t+i),zr.subVectors(s[(a+e-1)%e],s[(a+1)%e]).normalize(),Vr.subVectors(s[a],Mg).normalize(),jl.crossVectors(Vr,zr).normalize().toArray(o,t)):(zr.subVectors(s[a],s[(a+e-1)%e]).normalize(),Vr.subVectors(s[a],s[(a+1)%e]).normalize(),jl.addVectors(zr,Vr).normalize().toArray(o,t))}_addCut(e,t,n){if(e<3||t<2)return;const i=this._positions,s=this._normals,o=this._tmpShape,a=e*Qt;o[0].fromArray(i,n),o[1].fromArray(i,n+Qt),o[2].fromArray(i,n+2*Qt),zr.subVectors(o[1],o[0]).normalize(),Vr.subVectors(o[1],o[2]).normalize(),wg.crossVectors(zr,Vr).normalize();let l=n;for(let c=0;c<e*2;++c,l+=Qt)wg.toArray(s,l);if(t>2)for(let c=0;c<e;++c,l+=Qt)jl.fromArray(i,l-a).toArray(i,l)}}const CC=TC,RC=65535,Cn=4,Ri=4,es=3,ts=3,En=new x.Color,dn=new x.Vector3;function ns(r,e,t,n,i){r[e]=t,r[e+1]=n,r[e+2]=i}function Yl(r,e,t,n,i,s){r[e]=t,r[e+1]=n,r[e+2]=i,r[e+3]=s}function ql(r,e,t,n){const i=e*Cn,s=i+t*Cn;return r.subarray(i*n,s*n)}class PC extends x.BufferGeometry{constructor(e){super(),this._initVertices(e)}startUpdate(){return!0}finishUpdate(){this.getAttribute("position").needsUpdate=!0,this.getAttribute("color").needsUpdate=!0,this.getAttribute("alphaColor").needsUpdate=!0,this.getAttribute("direction").needsUpdate=!0}setColor(e,t){En.set(t);let n=e*Cn*ts;ns(this._colors,n,En.r,En.g,En.b),n+=ts,ns(this._colors,n,En.r,En.g,En.b),n+=ts,ns(this._colors,n,En.r,En.g,En.b),n+=ts,ns(this._colors,n,En.r,En.g,En.b)}setSegment(e,t,n){dn.subVectors(t,n),dn.normalize();const i=this._positions,s=this._directions;let o=e*Cn*Ri,a=e*Cn*es;Yl(i,o,t.x,t.y,t.z,.5),ns(s,a,dn.x,dn.y,dn.z),o+=Ri,a+=es,Yl(i,o,t.x,t.y,t.z,-.5),ns(s,a,dn.x,dn.y,dn.z),o+=Ri,a+=es,Yl(i,o,n.x,n.y,n.z,.5),ns(s,a,dn.x,dn.y,dn.z),o+=Ri,a+=es,Yl(i,o,n.x,n.y,n.z,-.5),ns(s,a,dn.x,dn.y,dn.z)}setOpacity(e,t,n){const i=e*Cn,s=t*Cn;de.default.fill(this.alpha,n,s,i),this.getAttribute("alphaColor").needsUpdate=!0}getSubsetSegments(e,t){return[ql(this._positions,e,t,Ri),ql(this._directions,e,t,es)]}getSubsetColors(e,t){return ql(this._colors,e,t,ts)}getSubsetOpacities(e,t){return ql(this._alpha,e,t,1)}getNumVertexPerSegment(){return Cn}getPositionSize(){return Ri}setSegments(e,t){const n=e*Cn*Ri;if(t instanceof Array&&t.length===2){this._positions.set(t[0],n);const i=e*Cn*es;this._directions.set(t[1],i)}else this._positions.set(t,n)}setColors(e,t){const n=e*Cn*ts;this._colors.set(t,n)}_initVertices(e){this._buffersSize=e*Cn;const t=this._buffersSize,n=t>RC;this._index=be.allocateTyped(n?Uint32Array:Uint16Array,e*6),this._positions=be.allocateTyped(Float32Array,t*Ri),this._colors=be.allocateTyped(Float32Array,t*ts),this._directions=be.allocateTyped(Float32Array,t*es);const i=this._alpha=be.allocateTyped(Float32Array,t);de.default.fill(i,1);const s=this._index;let o=0,a=0;for(let l=0;l<e;l++,o+=6,a+=Cn)s[o]=a,s[o+1]=a+1,s[o+2]=a+3,s[o+3]=a,s[o+4]=a+2,s[o+5]=a+3;this.setIndex(new x.BufferAttribute(this._index,1)),this.setAttribute("position",new x.BufferAttribute(this._positions,Ri)),this.setAttribute("color",new x.BufferAttribute(this._colors,ts)),this.setAttribute("alphaColor",new x.BufferAttribute(i,1)),this.setAttribute("direction",new x.BufferAttribute(this._directions,es))}}const ty=PC;class IC extends ty{startUpdate(){return!0}computeBoundingSphere(){const{boundingBox:e}=this;let t=0;const n=new x.Vector3;e&&e.getCenter(n);const i=this._positions,s=this.boundingSphere||new x.Sphere,o=this._positions.length,a=new x.Vector3,l=this.getPositionSize();for(let c=0;c<o;c+=l){a.set(i[c],i[c+1],i[c+2]);const h=n.distanceToSquared(a);t<h&&(t=h)}s.set(n,Math.sqrt(t)),this.boundingSphere=s}computeBoundingBox(){const e=this._positions,t=new x.Box3,n=this._positions.length,i=new x.Vector3,s=this.getPositionSize();for(let o=0;o<n;o+=s)i.set(e[o],e[o+1],e[o+2]),t.expandByPoint(i);this.boundingBox=t}finalize(){this.finishUpdate(),this.computeBoundingSphere()}}const ny=IC,$l=3,Br=new x.Vector3,Ag=new x.Matrix3;class LC extends Bf{constructor(e,t){const n=new x.CylinderGeometry(1,1,1,Math.max(3,t),2,!0);super(n,e);const i=this._chunkSize;this._chunkPos=this._chunkGeo.attributes.position.array,this._chunkNorms=this._chunkGeo.attributes.normal.array,this._tmpVector=be.allocateTyped(Float32Array,i*$l)}setItem(e,t,n,i){const s=this._chunkSize,o=s*e*$l,a=this._tmpVector,l=this._chunkPos,c=this._chunkNorms,h=Je.calcCylinderMatrix(t,n,i);Ag.getNormalMatrix(h);let u;for(let d=0;d<s;++d)u=d*$l,Br.fromArray(l,u),Br.applyMatrix4(h),Br.toArray(a,u);this._positions.set(a,o);for(let d=0;d<s;++d)u=d*$l,Br.fromArray(c,u),Br.applyMatrix3(Ag),Br.toArray(a,u);this._normals.set(a,o)}}const NC=LC,OC=.1;class Gf extends ny{constructor(e,t,n){super(e*t),this._init(t),this._collisionGeo=n?new NC(e*t,3):null}startUpdate(){return!0}computeBoundingSphere(){const e=this._collisionGeo;if(e){e.computeBoundingSphere(),this.boundingSphere=e.boundingSphere;return}super.computeBoundingSphere()}computeBoundingBox(){const e=this._collisionGeo;if(e){e.computeBoundingBox(),this.boundingBox=e.boundingBox;return}super.computeBoundingBox()}raycast(e,t){if(!this._collisionGeo)return;const i=this._chunkSize;this._collisionGeo.raycast(e,t);for(let s=0,o=t.length;s<o;++s){let{chunkIdx:a}=t[s];a!==void 0&&(a=a/i|0,t[s].chunkIdx=a)}}setColor(e,t){const n=this._chunkSize;for(let i=e*n,s=i+n;i<s;++i)super.setColor(i,t)}setSegment(e,t,n,i){const s=this._chunkSize,o=e*s+t;super.setSegment(o,n,i),this._collisionGeo&&this._collisionGeo.setItem(e*s+t,n,i,OC)}finalize(){this.finishUpdate(),this.computeBoundingSphere()}setOpacity(e,t){const n=this._chunkSize;for(let i=0,s=e.length;i<s;++i){const o=e[i]*n;super.setOpacity(o,o+n-1,t)}}getSubset(e){const t=e.length,n=this._chunkSize,i=new Gf(t,n,!1);for(let s=0,o=e.length;s<o;++s){const a=s*n,l=e[s]*n;i.setSegments(a,this.getSubsetSegments(l,n)),i.setColors(a,this.getSubsetColors(l,n))}return i.boundingSphere=this.boundingSphere,i.boundingBox=this.boundingBox,[i]}_init(e){this._chunkSize=e}}const iy=Gf,DC=.3,_u=new x.Vector3;class Hf extends ny{constructor(e){super(e*2),this._init(e),this._collisionGeo=new Q0(e,3)}setItem(e,t,n){this._collisionGeo.setItem(e,t,n,DC);const i=2*e;_u.lerpVectors(t,n,.5),super.setSegment(i,t,_u),super.setSegment(i+1,_u,n)}setColor(e,t,n){const i=2*e;super.setColor(i,t),super.setColor(i+1,n)}raycast(e,t){this._collisionGeo&&this._collisionGeo.raycast(e,t)}getSubset(e){const t=e.length,n=new Hf(t,!1);for(let i=0,s=t;i<s;++i){const o=e[i];n.setSegments(i,this.getSubsetSegments(o,1)),n.setColors(i,this.getSubsetColors(o,1))}return n.boundingSphere=this.boundingSphere,n.boundingBox=this.boundingBox,[n]}_init(e){this._segCounts=e*2}}const UC=Hf,zs=[new x.Vector3(1,0,0),new x.Vector3(-1,0,0),new x.Vector3(0,1,0),new x.Vector3(0,-1,0),new x.Vector3(0,0,1),new x.Vector3(0,0,-1)],Eg=zs.length,Zl=new x.Vector3,Kl=new x.Vector3;class FC extends K0(iy){constructor(e){super(e,e,Eg/2|0,!1)}setItem(e,t,n){this.setSphere(e,t,n);for(let i=0;i<Eg/2;++i){const s=i*2;Zl.x=t.x+zs[s].x*n,Zl.y=t.y+zs[s].y*n,Zl.z=t.z+zs[s].z*n;const o=s+1;Kl.x=t.x+zs[o].x*n,Kl.y=t.y+zs[o].y*n,Kl.z=t.z+zs[o].z*n,this.setSegment(e,i,Zl,Kl)}}}const zC=FC,Tg=4,Cg=3,Jl=new x.Color;class VC extends x.BufferGeometry{constructor(e,t){super(),this._opts=t,this.zClip=this._opts.zClip,this._posRad=be.allocateTyped(Float32Array,e*Tg),this._colors=be.allocateTyped(Float32Array,e*Cg)}setItem(e,t,n){const i=this._posRad;let s=Tg*e;i[s++]=t.x,i[s++]=t.y,i[s++]=t.z,i[s]=n}setColor(e,t){Jl.set(t);const n=this._colors;let i=Cg*e;n[i++]=Jl.r,n[i++]=Jl.g,n[i]=Jl.b}finalize(){this.finishUpdate(),this.computeBoundingSphere()}finishUpdate(){this._build()}setOpacity(){}raycast(){}getSubset(){return[]}}const sy=VC;class ry{constructor(){this.pointsValuesLinear=null,this.hasIntersection=null,this.bitsInside=null}create(e){const n=e*e*e;if(n>117440512)throw new Error("Too large cube dimension: lead to memory huge uasge");return this.pointsValuesLinear=be.allocateTyped(Float32Array,32*n),this.hasIntersection=be.allocateTyped(Int32Array,n),this.bitsInside=be.allocateTyped(Int32Array,n),0}destroy(){this.bitsInside=null,this.hasIntersection=null,this.pointsValuesLinear=null}}ry.prototype.striIndicesMarchCube=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,9,8,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,2,10,0,2,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,8,3,2,10,8,10,9,8,-1,-1,-1,-1,-1,-1,-1,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,8,11,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,11,2,1,9,11,9,8,11,-1,-1,-1,-1,-1,-1,-1,3,10,1,11,10,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,10,1,0,8,10,8,11,10,-1,-1,-1,-1,-1,-1,-1,3,9,0,3,11,9,11,10,9,-1,-1,-1,-1,-1,-1,-1,9,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,7,3,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,1,9,4,7,1,7,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,8,4,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,4,7,3,0,4,1,2,10,-1,-1,-1,-1,-1,-1,-1,9,2,10,9,0,2,8,4,7,-1,-1,-1,-1,-1,-1,-1,2,10,9,2,9,7,2,7,3,7,9,4,-1,-1,-1,-1,8,4,7,3,11,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,4,7,11,2,4,2,0,4,-1,-1,-1,-1,-1,-1,-1,9,0,1,8,4,7,2,3,11,-1,-1,-1,-1,-1,-1,-1,4,7,11,9,4,11,9,11,2,9,2,1,-1,-1,-1,-1,3,10,1,3,11,10,7,8,4,-1,-1,-1,-1,-1,-1,-1,1,11,10,1,4,11,1,0,4,7,11,4,-1,-1,-1,-1,4,7,8,9,0,11,9,11,10,11,0,3,-1,-1,-1,-1,4,7,11,4,11,9,9,11,10,-1,-1,-1,-1,-1,-1,-1,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,5,4,1,5,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,5,4,8,3,5,3,1,5,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,10,4,9,5,-1,-1,-1,-1,-1,-1,-1,5,2,10,5,4,2,4,0,2,-1,-1,-1,-1,-1,-1,-1,2,10,5,3,2,5,3,5,4,3,4,8,-1,-1,-1,-1,9,5,4,2,3,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,11,2,0,8,11,4,9,5,-1,-1,-1,-1,-1,-1,-1,0,5,4,0,1,5,2,3,11,-1,-1,-1,-1,-1,-1,-1,2,1,5,2,5,8,2,8,11,4,8,5,-1,-1,-1,-1,10,3,11,10,1,3,9,5,4,-1,-1,-1,-1,-1,-1,-1,4,9,5,0,8,1,8,10,1,8,11,10,-1,-1,-1,-1,5,4,0,5,0,11,5,11,10,11,0,3,-1,-1,-1,-1,5,4,8,5,8,10,10,8,11,-1,-1,-1,-1,-1,-1,-1,9,7,8,5,7,9,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,3,0,9,5,3,5,7,3,-1,-1,-1,-1,-1,-1,-1,0,7,8,0,1,7,1,5,7,-1,-1,-1,-1,-1,-1,-1,1,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,7,8,9,5,7,10,1,2,-1,-1,-1,-1,-1,-1,-1,10,1,2,9,5,0,5,3,0,5,7,3,-1,-1,-1,-1,8,0,2,8,2,5,8,5,7,10,5,2,-1,-1,-1,-1,2,10,5,2,5,3,3,5,7,-1,-1,-1,-1,-1,-1,-1,7,9,5,7,8,9,3,11,2,-1,-1,-1,-1,-1,-1,-1,9,5,7,9,7,2,9,2,0,2,7,11,-1,-1,-1,-1,2,3,11,0,1,8,1,7,8,1,5,7,-1,-1,-1,-1,11,2,1,11,1,7,7,1,5,-1,-1,-1,-1,-1,-1,-1,9,5,8,8,5,7,10,1,3,10,3,11,-1,-1,-1,-1,5,7,0,5,0,9,7,11,0,1,0,10,11,10,0,-1,11,10,0,11,0,3,10,5,0,8,0,7,5,7,0,-1,11,10,5,7,11,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,0,1,5,10,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,8,3,1,9,8,5,10,6,-1,-1,-1,-1,-1,-1,-1,1,6,5,2,6,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,6,5,1,2,6,3,0,8,-1,-1,-1,-1,-1,-1,-1,9,6,5,9,0,6,0,2,6,-1,-1,-1,-1,-1,-1,-1,5,9,8,5,8,2,5,2,6,3,2,8,-1,-1,-1,-1,2,3,11,10,6,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,0,8,11,2,0,10,6,5,-1,-1,-1,-1,-1,-1,-1,0,1,9,2,3,11,5,10,6,-1,-1,-1,-1,-1,-1,-1,5,10,6,1,9,2,9,11,2,9,8,11,-1,-1,-1,-1,6,3,11,6,5,3,5,1,3,-1,-1,-1,-1,-1,-1,-1,0,8,11,0,11,5,0,5,1,5,11,6,-1,-1,-1,-1,3,11,6,0,3,6,0,6,5,0,5,9,-1,-1,-1,-1,6,5,9,6,9,11,11,9,8,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,3,0,4,7,3,6,5,10,-1,-1,-1,-1,-1,-1,-1,1,9,0,5,10,6,8,4,7,-1,-1,-1,-1,-1,-1,-1,10,6,5,1,9,7,1,7,3,7,9,4,-1,-1,-1,-1,6,1,2,6,5,1,4,7,8,-1,-1,-1,-1,-1,-1,-1,1,2,5,5,2,6,3,0,4,3,4,7,-1,-1,-1,-1,8,4,7,9,0,5,0,6,5,0,2,6,-1,-1,-1,-1,7,3,9,7,9,4,3,2,9,5,9,6,2,6,9,-1,3,11,2,7,8,4,10,6,5,-1,-1,-1,-1,-1,-1,-1,5,10,6,4,7,2,4,2,0,2,7,11,-1,-1,-1,-1,0,1,9,4,7,8,2,3,11,5,10,6,-1,-1,-1,-1,9,2,1,9,11,2,9,4,11,7,11,4,5,10,6,-1,8,4,7,3,11,5,3,5,1,5,11,6,-1,-1,-1,-1,5,1,11,5,11,6,1,0,11,7,11,4,0,4,11,-1,0,5,9,0,6,5,0,3,6,11,6,3,8,4,7,-1,6,5,9,6,9,11,4,7,9,7,11,9,-1,-1,-1,-1,10,4,9,6,4,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,10,6,4,9,10,0,8,3,-1,-1,-1,-1,-1,-1,-1,10,0,1,10,6,0,6,4,0,-1,-1,-1,-1,-1,-1,-1,8,3,1,8,1,6,8,6,4,6,1,10,-1,-1,-1,-1,1,4,9,1,2,4,2,6,4,-1,-1,-1,-1,-1,-1,-1,3,0,8,1,2,9,2,4,9,2,6,4,-1,-1,-1,-1,0,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,3,2,8,2,4,4,2,6,-1,-1,-1,-1,-1,-1,-1,10,4,9,10,6,4,11,2,3,-1,-1,-1,-1,-1,-1,-1,0,8,2,2,8,11,4,9,10,4,10,6,-1,-1,-1,-1,3,11,2,0,1,6,0,6,4,6,1,10,-1,-1,-1,-1,6,4,1,6,1,10,4,8,1,2,1,11,8,11,1,-1,9,6,4,9,3,6,9,1,3,11,6,3,-1,-1,-1,-1,8,11,1,8,1,0,11,6,1,9,1,4,6,4,1,-1,3,11,6,3,6,0,0,6,4,-1,-1,-1,-1,-1,-1,-1,6,4,8,11,6,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,10,6,7,8,10,8,9,10,-1,-1,-1,-1,-1,-1,-1,0,7,3,0,10,7,0,9,10,6,7,10,-1,-1,-1,-1,10,6,7,1,10,7,1,7,8,1,8,0,-1,-1,-1,-1,10,6,7,10,7,1,1,7,3,-1,-1,-1,-1,-1,-1,-1,1,2,6,1,6,8,1,8,9,8,6,7,-1,-1,-1,-1,2,6,9,2,9,1,6,7,9,0,9,3,7,3,9,-1,7,8,0,7,0,6,6,0,2,-1,-1,-1,-1,-1,-1,-1,7,3,2,6,7,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,11,10,6,8,10,8,9,8,6,7,-1,-1,-1,-1,2,0,7,2,7,11,0,9,7,6,7,10,9,10,7,-1,1,8,0,1,7,8,1,10,7,6,7,10,2,3,11,-1,11,2,1,11,1,7,10,6,1,6,7,1,-1,-1,-1,-1,8,9,6,8,6,7,9,1,6,11,6,3,1,3,6,-1,0,9,1,11,6,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,8,0,7,0,6,3,11,0,11,6,0,-1,-1,-1,-1,7,11,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,8,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,1,9,11,7,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,1,9,8,3,1,11,7,6,-1,-1,-1,-1,-1,-1,-1,10,1,2,6,11,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,8,6,11,7,-1,-1,-1,-1,-1,-1,-1,2,9,0,2,10,9,6,11,7,-1,-1,-1,-1,-1,-1,-1,6,11,7,2,10,3,10,8,3,10,9,8,-1,-1,-1,-1,7,2,3,6,2,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,7,0,8,7,6,0,6,2,0,-1,-1,-1,-1,-1,-1,-1,2,7,6,2,3,7,0,1,9,-1,-1,-1,-1,-1,-1,-1,1,6,2,1,8,6,1,9,8,8,7,6,-1,-1,-1,-1,10,7,6,10,1,7,1,3,7,-1,-1,-1,-1,-1,-1,-1,10,7,6,1,7,10,1,8,7,1,0,8,-1,-1,-1,-1,0,3,7,0,7,10,0,10,9,6,10,7,-1,-1,-1,-1,7,6,10,7,10,8,8,10,9,-1,-1,-1,-1,-1,-1,-1,6,8,4,11,8,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,6,11,3,0,6,0,4,6,-1,-1,-1,-1,-1,-1,-1,8,6,11,8,4,6,9,0,1,-1,-1,-1,-1,-1,-1,-1,9,4,6,9,6,3,9,3,1,11,3,6,-1,-1,-1,-1,6,8,4,6,11,8,2,10,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,3,0,11,0,6,11,0,4,6,-1,-1,-1,-1,4,11,8,4,6,11,0,2,9,2,10,9,-1,-1,-1,-1,10,9,3,10,3,2,9,4,3,11,3,6,4,6,3,-1,8,2,3,8,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,0,4,2,4,6,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,9,0,2,3,4,2,4,6,4,3,8,-1,-1,-1,-1,1,9,4,1,4,2,2,4,6,-1,-1,-1,-1,-1,-1,-1,8,1,3,8,6,1,8,4,6,6,10,1,-1,-1,-1,-1,10,1,0,10,0,6,6,0,4,-1,-1,-1,-1,-1,-1,-1,4,6,3,4,3,8,6,10,3,0,3,9,10,9,3,-1,10,9,4,6,10,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,5,7,6,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,5,11,7,6,-1,-1,-1,-1,-1,-1,-1,5,0,1,5,4,0,7,6,11,-1,-1,-1,-1,-1,-1,-1,11,7,6,8,3,4,3,5,4,3,1,5,-1,-1,-1,-1,9,5,4,10,1,2,7,6,11,-1,-1,-1,-1,-1,-1,-1,6,11,7,1,2,10,0,8,3,4,9,5,-1,-1,-1,-1,7,6,11,5,4,10,4,2,10,4,0,2,-1,-1,-1,-1,3,4,8,3,5,4,3,2,5,10,5,2,11,7,6,-1,7,2,3,7,6,2,5,4,9,-1,-1,-1,-1,-1,-1,-1,9,5,4,0,8,6,0,6,2,6,8,7,-1,-1,-1,-1,3,6,2,3,7,6,1,5,0,5,4,0,-1,-1,-1,-1,6,2,8,6,8,7,2,1,8,4,8,5,1,5,8,-1,9,5,4,10,1,6,1,7,6,1,3,7,-1,-1,-1,-1,1,6,10,1,7,6,1,0,7,8,7,0,9,5,4,-1,4,0,10,4,10,5,0,3,10,6,10,7,3,7,10,-1,7,6,10,7,10,8,5,4,10,4,8,10,-1,-1,-1,-1,6,9,5,6,11,9,11,8,9,-1,-1,-1,-1,-1,-1,-1,3,6,11,0,6,3,0,5,6,0,9,5,-1,-1,-1,-1,0,11,8,0,5,11,0,1,5,5,6,11,-1,-1,-1,-1,6,11,3,6,3,5,5,3,1,-1,-1,-1,-1,-1,-1,-1,1,2,10,9,5,11,9,11,8,11,5,6,-1,-1,-1,-1,0,11,3,0,6,11,0,9,6,5,6,9,1,2,10,-1,11,8,5,11,5,6,8,0,5,10,5,2,0,2,5,-1,6,11,3,6,3,5,2,10,3,10,5,3,-1,-1,-1,-1,5,8,9,5,2,8,5,6,2,3,8,2,-1,-1,-1,-1,9,5,6,9,6,0,0,6,2,-1,-1,-1,-1,-1,-1,-1,1,5,8,1,8,0,5,6,8,3,8,2,6,2,8,-1,1,5,6,2,1,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,6,1,6,10,3,8,6,5,6,9,8,9,6,-1,10,1,0,10,0,6,9,5,0,5,6,0,-1,-1,-1,-1,0,3,8,5,6,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,10,5,6,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,7,5,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,11,5,10,11,7,5,8,3,0,-1,-1,-1,-1,-1,-1,-1,5,11,7,5,10,11,1,9,0,-1,-1,-1,-1,-1,-1,-1,10,7,5,10,11,7,9,8,1,8,3,1,-1,-1,-1,-1,11,1,2,11,7,1,7,5,1,-1,-1,-1,-1,-1,-1,-1,0,8,3,1,2,7,1,7,5,7,2,11,-1,-1,-1,-1,9,7,5,9,2,7,9,0,2,2,11,7,-1,-1,-1,-1,7,5,2,7,2,11,5,9,2,3,2,8,9,8,2,-1,2,5,10,2,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,8,2,0,8,5,2,8,7,5,10,2,5,-1,-1,-1,-1,9,0,1,5,10,3,5,3,7,3,10,2,-1,-1,-1,-1,9,8,2,9,2,1,8,7,2,10,2,5,7,5,2,-1,1,3,5,3,7,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,8,7,0,7,1,1,7,5,-1,-1,-1,-1,-1,-1,-1,9,0,3,9,3,5,5,3,7,-1,-1,-1,-1,-1,-1,-1,9,8,7,5,9,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,5,8,4,5,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,5,0,4,5,11,0,5,10,11,11,3,0,-1,-1,-1,-1,0,1,9,8,4,10,8,10,11,10,4,5,-1,-1,-1,-1,10,11,4,10,4,5,11,3,4,9,4,1,3,1,4,-1,2,5,1,2,8,5,2,11,8,4,5,8,-1,-1,-1,-1,0,4,11,0,11,3,4,5,11,2,11,1,5,1,11,-1,0,2,5,0,5,9,2,11,5,4,5,8,11,8,5,-1,9,4,5,2,11,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,5,10,3,5,2,3,4,5,3,8,4,-1,-1,-1,-1,5,10,2,5,2,4,4,2,0,-1,-1,-1,-1,-1,-1,-1,3,10,2,3,5,10,3,8,5,4,5,8,0,1,9,-1,5,10,2,5,2,4,1,9,2,9,4,2,-1,-1,-1,-1,8,4,5,8,5,3,3,5,1,-1,-1,-1,-1,-1,-1,-1,0,4,5,1,0,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,4,5,8,5,3,9,0,5,0,3,5,-1,-1,-1,-1,9,4,5,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,11,7,4,9,11,9,10,11,-1,-1,-1,-1,-1,-1,-1,0,8,3,4,9,7,9,11,7,9,10,11,-1,-1,-1,-1,1,10,11,1,11,4,1,4,0,7,4,11,-1,-1,-1,-1,3,1,4,3,4,8,1,10,4,7,4,11,10,11,4,-1,4,11,7,9,11,4,9,2,11,9,1,2,-1,-1,-1,-1,9,7,4,9,11,7,9,1,11,2,11,1,0,8,3,-1,11,7,4,11,4,2,2,4,0,-1,-1,-1,-1,-1,-1,-1,11,7,4,11,4,2,8,3,4,3,2,4,-1,-1,-1,-1,2,9,10,2,7,9,2,3,7,7,4,9,-1,-1,-1,-1,9,10,7,9,7,4,10,2,7,8,7,0,2,0,7,-1,3,7,10,3,10,2,7,4,10,1,10,0,4,0,10,-1,1,10,2,8,7,4,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,7,1,3,-1,-1,-1,-1,-1,-1,-1,4,9,1,4,1,7,0,8,1,8,7,1,-1,-1,-1,-1,4,0,3,7,4,3,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,4,8,7,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,9,10,8,10,11,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,11,9,10,-1,-1,-1,-1,-1,-1,-1,0,1,10,0,10,8,8,10,11,-1,-1,-1,-1,-1,-1,-1,3,1,10,11,3,10,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,2,11,1,11,9,9,11,8,-1,-1,-1,-1,-1,-1,-1,3,0,9,3,9,11,1,2,9,2,11,9,-1,-1,-1,-1,0,2,11,8,0,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,3,2,11,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,10,8,9,-1,-1,-1,-1,-1,-1,-1,9,10,2,0,9,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,2,3,8,2,8,10,0,1,8,1,10,8,-1,-1,-1,-1,1,10,2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,3,8,9,1,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,9,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,3,8,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];const oy=ry,Rg=[0,265,515,778,1030,1295,1541,1804,2060,2309,2575,2822,3082,3331,3593,3840,400,153,915,666,1430,1183,1941,1692,2460,2197,2975,2710,3482,3219,3993,3728,560,825,51,314,1590,1855,1077,1340,2620,2869,2111,2358,3642,3891,3129,3376,928,681,419,170,1958,1711,1445,1196,2988,2725,2479,2214,4010,3747,3497,3232,1120,1385,1635,1898,102,367,613,876,3180,3429,3695,3942,2154,2403,2665,2912,1520,1273,2035,1786,502,255,1013,764,3580,3317,4095,3830,2554,2291,3065,2800,1616,1881,1107,1370,598,863,85,348,3676,3925,3167,3414,2650,2899,2137,2384,1984,1737,1475,1226,966,719,453,204,4044,3781,3535,3270,3018,2755,2505,2240,2240,2505,2755,3018,3270,3535,3781,4044,204,453,719,966,1226,1475,1737,1984,2384,2137,2899,2650,3414,3167,3925,3676,348,85,863,598,1370,1107,1881,1616,2800,3065,2291,2554,3830,4095,3317,3580,764,1013,255,502,1786,2035,1273,1520,2912,2665,2403,2154,3942,3695,3429,3180,876,613,367,102,1898,1635,1385,1120,3232,3497,3747,4010,2214,2479,2725,2988,1196,1445,1711,1958,170,419,681,928,3376,3129,3891,3642,2358,2111,2869,2620,1340,1077,1855,1590,314,51,825,560,3728,3993,3219,3482,2710,2975,2197,2460,1692,1941,1183,1430,666,915,153,400,3840,3593,3331,3082,2822,2575,2309,2060,1804,1541,1295,1030,778,515,265,0];function BC(r,e,t){const n=r.getValue(e.x,e.y,e.z);t.set(n[0],n[1],n[2])}class kC{constructor(){this._arrSize=8,this.p=new Array(this._arrSize),this.g=new Array(this._arrSize),this.val=new Array(this._arrSize);for(let e=0;e<this._arrSize;++e)this.p[e]=new x.Vector3,this.g[e]=new x.Vector3;this.cubeIndex=0}}class GC{constructor(){this.a={p:new x.Vector3,n:new x.Vector3},this.b={p:new x.Vector3,n:new x.Vector3},this.c={p:new x.Vector3,n:new x.Vector3}}}function Pg(r){const e=new Array(r);for(let t=0;t<r;++t)e[t]=new x.Vector3;return e}class ci{constructor(){this._numTriangles=0,this._numVertices=0,this._position=[],this._normals=[],this._colors=null,this._indices=[],this._volumetricData=null,this._xAxis=new x.Vector3,this._yAxis=new x.Vector3,this._zAxis=new x.Vector3,this._xDir=new x.Vector3,this._yDir=new x.Vector3,this._zDir=new x.Vector3}_prepareAxesAndDirs(){const t=this._volumetricData.getCellSize(),n=this._xAxis,i=this._yAxis,s=this._zAxis,o=this._xDir,a=this._yDir,l=this._zDir;n.set(t.x,0,0),i.set(0,t.y,0),s.set(0,0,t.z),o.set(1,0,0),a.set(0,1,0),l.set(0,0,1);const c=new x.Vector3;if(c.crossVectors(o,a),c.dot(l)<0&&(o.negate(),a.negate(),l.negate()),o.x<0||o.y<0||o.z<0||a.x<0||a.y<0||a.z<0||l.x<0||l.y<0||l.z<0)return!1;const h=u=>Math.abs(u)>Number.EPSILON;return!(h(n.y)||h(n.z)||h(i.x)||h(i.z)||h(s.x)||h(s.y))}_vertexInterp(e,t,n,i,s,o){const a=t.p[n],l=t.p[i],c=t.g[n],h=t.g[i],u=t.val[n],d=t.val[i],f=e-u,p=d-u;let _=0;Math.abs(p)>0&&(_=f/p),_=_>1?1:_,s.lerpVectors(a,l,_),o.lerpVectors(c,h,_)}static _triTable=oy.prototype.striIndicesMarchCube;static _arrSize=12;static _firstIndices=[0,1,2,3,4,5,6,7,0,1,2,3];static _secondIndices=[1,2,3,0,5,6,7,4,4,5,6,7];static _vertexList=Pg(ci._arrSize);static _normalList=Pg(ci._arrSize);_polygonize(e,t,n){const{cubeIndex:i}=e;let s=0;const o=ci._arrSize,a=ci._firstIndices,l=ci._secondIndices,c=ci._vertexList,h=ci._normalList;for(;s<o;++s)Rg[i]&1<<s&&this._vertexInterp(t,e,a[s],l[s],c[s],h[s]);let u=0;const d=i*16,f=ci._triTable;for(s=0;f[d+s]!==-1;s+=3)n[u].a.p.copy(c[f[d+s]]),n[u].a.n.copy(h[f[d+s]]),n[u].b.p.copy(c[f[d+s+1]]),n[u].b.n.copy(h[f[d+s+1]]),n[u].c.p.copy(c[f[d+s+2]]),n[u].c.n.copy(h[f[d+s+2]]),++u;return u}_doGridPosNorms(e,t,n){const i=this._volumetricData,s=this._volumetricData.getData(),o=i.getDimensions(),a=o[0],l=o[1],c=o[2],h=t*i.getStrideX(),u=t*i.getStrideY(),d=t*i.getStrideZ(),f=new kC,p=f.val,_=f.val.length,g=[new x.Vector3(0,0,0),new x.Vector3(t,0,0),new x.Vector3(t,t,0),new x.Vector3(0,t,0),new x.Vector3(0,0,t),new x.Vector3(t,0,t),new x.Vector3(t,t,t),new x.Vector3(0,t,t)],m=5,v=new Array(m);for(let w=0;w<m;++w)v[w]=new GC;let y;const S=this,b=this._position,M=this._normals;n?y=(function(){const w=new x.Vector3(S._xAxis.x,S._yAxis.y,S._zAxis.z);return function(A){const D=A.p.clone();D.multiply(w),b.push(D.add(S._origin)),M.push(A.n.clone())}})():y=(function(){const w=new x.Matrix3;w.set(S._xAxis.x,S._yAxis.x,S._zAxis.x,S._xAxis.y,S._yAxis.y,S._zAxis.y,S._xAxis.z,S._yAxis.z,S._zAxis.z);const A=new x.Matrix3;return A.set(S._xDir.x,S._yDir.x,S._zDir.x,S._xDir.y,S._yDir.y,S._zDir.y,S._xDir.z,S._yDir.z,S._zDir.z),function(D){b.push(D.p.clone().applyMatrix3(w).add(S._origin)),M.push(D.n.clone().applyMatrix3(A))}})();const E=this._indices;let T=0;for(let w=0;w<c-t;w+=t)for(let A=0;A<l-t;A+=t){let D=i.getDirectIdx(0,A,w);for(let k=0;k<a-t;k+=t,D+=h){p[0]=s[D],p[1]=s[D+h],p[3]=s[D+u],p[2]=s[D+h+u],p[4]=s[D+d],p[5]=s[D+h+d],p[7]=s[D+u+d],p[6]=s[D+h+u+d];let G=0,P=0;for(;P<_;++P)p[P]<e&&(G|=1<<P);if(Rg[G]===0)continue;for(f.cubeIndex=G,P=0;P<_;++P)f.p[P].set(k+g[P].x,A+g[P].y,w+g[P].z),BC(this._gradient,f.p[P],f.g[P]);const N=this._polygonize(f,e,v);for(T+=N,P=0;P<N;++P)E.push(this._numTriangles*3),E.push(this._numTriangles*3+1),E.push(this._numTriangles*3+2),++this._numTriangles,y(v[P].a),y(v[P].b),y(v[P].c)}}return T}compute(e,t,n,i){this._volumetricData=e,this._origin=t,this._gradient=e.computeGradient(),this._doGridPosNorms(n,i,this._prepareAxesAndDirs())}_remapIndices(e,t){const n=this._indices,i=be.allocateTyped(Uint32Array,t);for(let s=0;s<t;++s)n[s]=e[n[s]],i[s]=n[s];this._indices=i}_remapVertices(e,t,n){const i=be.allocateTyped(Float32Array,n*3),s=be.allocateTyped(Float32Array,n*3);for(let o=0;o<n;++o){const a=e[o];i[o*3]=a.x,i[o*3+1]=a.y,i[o*3+2]=a.z;const l=t[o].normalize();s[o*3]=l.x,s[o*3+1]=l.y,s[o*3+2]=l.z}this._position=i,this._normals=s}vertexFusion(e,t){const n=this._indices.length,i=this._position,s=this._normals,o=i.length|0;if(n===0||o===0)return;const a=be.allocateTyped(Uint32Array,o);a[0]=0;let l=1,c=1;for(;c<o;++c){const h=l-e<0?0:l-e,u=h+t>l?l:h+t;let d=-1;for(let f=h;f<u;++f)if(Math.abs(i[c]-i[f])<Number.EPSILON){d=f;break}d!==-1?a[c]=d:(i[l].copy(i[c]),s[l].copy(s[c]),a[c]=l,++l)}this._remapIndices(a,n),this._remapVertices(i,s,l)}setColorVolTex(e,t,n,i){let s,o;const a=this._position.length/3,l=this._position,c=this._origin,h=this._volumetricData.getDimensions(),u=h[0]-1,d=h[1]-1,f=h[2]-1,p=e.getData(),_=e.getStrideX(),g=e.getStrideY(),m=e.getStrideZ();let v,y,S,b;i!==null&&(v=n.getData(),y=n.getStrideX(),S=n.getStrideY(),b=n.getStrideZ());const M=1/this._xAxis.x,E=1/this._yAxis.y,T=1/this._zAxis.z;let w=[],A=[];const D=be.allocateTyped(Float32Array,a*3);function k(B,H,W,$){$[0]=(1-B)*p[H]+B*p[W],$[1]=(1-B)*p[H+1]+B*p[W+1],$[2]=(1-B)*p[H+2]+B*p[W+2]}function G(B,H,W,$){const oe=t[B];if(oe!=null){w[oe.index]=oe;const Se=H*W*$*v[B];typeof A[oe.index]>"u"?A[oe.index]=Se:A[oe.index]+=Se}}const P=be.allocateTyped(Int32Array,a);let N=0;for(s=0;s<a;s++){const B=s*3,H=(l[B]-c.x)*M,W=(l[B+1]-c.y)*E,$=(l[B+2]-c.z)*T,oe=Math.min(Math.max(H,0),u)|0,Se=Math.min(Math.max(W,0),d)|0,K=Math.min(Math.max($,0),f)|0,ce=H-oe,Z=W-Se,_e=$-K;if(i!=null){w=[],A=[],o=n.getDirectIdx(oe,Se,K),G(o,1-ce,1-Z,1-_e),G(o+y,ce,1-Z,1-_e),G(o+S,1-ce,Z,1-_e),G(o+y+S,ce,Z,1-_e),G(o+b,1-ce,1-Z,_e),G(o+y+b,ce,1-Z,_e),G(o+S+b,1-ce,Z,_e),G(o+y+S+b,ce,Z,_e);let ie=0,ne=-1;for(const Ae in A)A[Ae]>ie&&(ne=Ae,ie=A[Ae]);if(ne<0||!i.includesAtom(w[ne])){P[s]=-1;continue}}P[s]=N++;const xe=oe<u?_:0,Ee=Se<d?g:0,Ne=K<f?m:0,Oe=[0,0,0],Ve=[0,0,0],De=[0,0,0],z=[0,0,0];o=e.getDirectIdx(oe,Se,K),k(ce,o,o+xe,Oe),k(ce,o+Ee,o+xe+Ee,Ve),k(ce,o+Ne,o+xe+Ne,De),k(ce,o+Ee+Ne,o+xe+Ee+Ne,z);const ye=[0,0,0];ye[0]=(1-Z)*Oe[0]+Z*Ve[0],ye[1]=(1-Z)*Oe[1]+Z*Ve[1],ye[2]=(1-Z)*Oe[2]+Z*Ve[2];const X=[0,0,0];X[0]=(1-Z)*De[0]+Z*z[0],X[1]=(1-Z)*De[1]+Z*z[1],X[2]=(1-Z)*De[2]+Z*z[2],D[B]=(1-_e)*ye[0]+_e*X[0],D[B+1]=(1-_e)*ye[1]+_e*X[1],D[B+2]=(1-_e)*ye[2]+_e*X[2]}if(this._colors=D,i!=null){for(s=0;s<a;++s){const W=P[s];W<0||(this._position[W*3]=this._position[s*3],this._position[W*3+1]=this._position[s*3+1],this._position[W*3+2]=this._position[s*3+2],this._normals[W*3]=this._normals[s*3],this._normals[W*3+1]=this._normals[s*3+1],this._normals[W*3+2]=this._normals[s*3+2],this._colors[W*3]=this._colors[s*3],this._colors[W*3+1]=this._colors[s*3+1],this._colors[W*3+2]=this._colors[s*3+2])}const B=this._indices.length/3;let H=0;for(s=0;s<B;++s){const W=P[this._indices[3*s]],$=P[this._indices[3*s+1]],oe=P[this._indices[3*s+2]];W>=0&&$>=0&&oe>=0&&(this._indices[3*H]=W,this._indices[3*H+1]=$,this._indices[3*H+2]=oe,++H)}this._position=new Float32Array(this._position.buffer.slice(0,N*3*4)),this._normals=new Float32Array(this._normals.buffer.slice(0,N*3*4)),this._colors=new Float32Array(this._colors.buffer.slice(0,N*3*4)),this._indices=new Uint32Array(this._indices.buffer.slice(0,H*3*4))}}toMesh(){const e=new x.BufferGeometry;return e.setIndex(new x.BufferAttribute(this._indices,1)),e.setAttribute("position",new x.BufferAttribute(this._position,3)),e.setAttribute("normal",new x.BufferAttribute(this._normals,3)),e.setAttribute("color",new x.BufferAttribute(this._colors,3)),e.computeBoundingSphere(),e}}const HC=ci;class WC extends sy{_build(){const e=this._opts;this.numVoxels=[128,128,128],this.xAxis=new x.Vector3(1,0,0),this.yAxis=new x.Vector3(0,1,0),this.zAxis=new x.Vector3(0,0,1),this.origin=new x.Vector3(0,0,0),this._visibilitySelector=e.visibilitySelector,this._calcSurface(e)}_findMinMax(e){const n=e.length/4,i=[e[0],e[1],e[2],e[3]],s=[e[0],e[1],e[2],e[3]];for(let o=1;o<n;++o){const a=o*4;for(let l=0;l<4;++l){const c=e[a+l];i[l]=Math.max(c,i[l]),s[l]=Math.min(c,s[l])}}return{maxPosRad:i,minPosRad:s}}_findNumVoxels(e,t){const{numVoxels:n}=this,i=this._findMinMax(e),s=i.minPosRad,o=i.maxPosRad;s[3]>4&&(t.gridSpacing*=s[3]);let a=t.radScale*o[3]*1.7,l=a;l=.65*Math.sqrt(4/3*Math.PI*l*l*l),a=Math.max(a,l);let c=0;for(;c<3;++c)s[c]-=a,o[c]+=a;for(c=0;c<3;++c)n[c]=Math.ceil((o[c]-s[c])/t.gridSpacing);return this.xAxis.x=(n[0]-1)*t.gridSpacing,this.yAxis.y=(n[1]-1)*t.gridSpacing,this.zAxis.z=(n[2]-1)*t.gridSpacing,[this.origin.x,this.origin.y,this.origin.z]=s,{bbox:i,dim:n}}_makeSurface(e,t){const n=new HC;n.compute(e.volMap,this.origin,t.isoValue,1),n.vertexFusion(9,9),n._numTriangles>0?(n.setColorVolTex(e.volTexMap,e.atomMap,e.atomWeightMap,this._visibilitySelector),this.setIndex(new x.BufferAttribute(n._indices,1)),this.setAttribute("position",new x.BufferAttribute(n._position,3)),this.setAttribute("normal",new x.BufferAttribute(n._normals,3)),this.setAttribute("color",new x.BufferAttribute(n._colors,3))):this.setAttribute("position",new x.BufferAttribute(be.allocateTyped(Float32Array,0),3))}_calcSurface(e){const t={posRad:this._posRad,colors:this._colors,atoms:this._opts.atoms};if(t.posRad.length===0)return;const n=this._findNumVoxels(t.posRad,e),i=new x.Box3(this.origin,new x.Vector3(this.xAxis.x,this.yAxis.y,this.zAxis.z).add(this.origin)),s=this._computeSurface(t,i,n,e);this._makeSurface(s,e)}}const ay=WC,{Volume:yu}=Bt;class XC extends ay{_computeSurface(e,t,n,i){this._shiftByOrigin(e.posRad);const s={volMap:new yu(Float32Array,this.numVoxels,t),volTexMap:new yu(Float32Array,this.numVoxels,t,3)};return this._visibilitySelector!=null&&(s.atomMap=[],s.atomWeightMap=new yu(Float32Array,this.numVoxels,t)),this.gaussdensity(s,e,null,i),s}gaussdensity(e,t,n,i){const s=t.posRad.length/4,{posRad:o,colors:a}=t,{numVoxels:l}=this,{radScale:c,gaussLim:h,gridSpacing:u}=i,d=1/i.isoValue,f=1/u,p=l[0]-1,_=l[1]-1,g=l[2]-1,{volMap:m,volTexMap:v}=e,y=m.getData(),S=m.getStrideX(),b=v.getData(),M=v.getStrideX();let E;this._visibilitySelector!=null&&(E=e.atomWeightMap.getData());const{atomMap:T}=e;for(let w=0;w<s;++w){const A=w*4,D=o[A+3]*c,k=n===null?1:n[w],G=1/(2*D*D);let P=h*D;const N=P*P;P*=f;let B=o[A]*f;const H=Math.max(B-P|0,0),W=Math.min(B+P|0,p);B=o[A+1]*f;const $=Math.max(B-P|0,0),oe=Math.min(B+P|0,_);B=o[A+2]*f;const Se=Math.max(B-P|0,0),K=Math.min(B+P|0,g);let ce=Se*u-o[A+2];for(let Z=Se;Z<=K;++Z,ce+=u){let _e=$*u-o[A+1];for(let xe=$;xe<=oe;++xe,_e+=u){const Ee=_e*_e+ce*ce;if(Ee>=N)continue;let Ne=m.getDirectIdx(H,xe,Z),Oe=v.getDirectIdx(H,xe,Z),Ve=H*u-o[A];for(let De=H;De<=W;++De,Ve+=u,Ne+=S,Oe+=M){const ye=-(Ve*Ve+Ee)*G;let X=Math.exp(ye)*k;this._visibilitySelector!=null&&X>E[Ne]&&(E[Ne]=X,T[Ne]=t.atoms[w]),y[Ne]+=X,X*=d;const ie=w*3;b[Oe]+=X*a[ie],b[Oe+1]+=X*a[ie+1],b[Oe+2]+=X*a[ie+2]}}}}}_shiftByOrigin(e){const t=this.origin.x,n=this.origin.y,i=this.origin.z,s=4,o=e.length/s;for(let a=0;a<o;++a){const l=a*s;e[l]-=t,e[l+1]-=n,e[l+2]-=i}}}const jC=XC;function YC(r,e,t,n){const s=r.length/4,o=e[0],a=e[1],l=e[2],c=t[0],h=t[1],u=t[2];function d(k,G){return Math.floor((k-G)/n)}const f=d(c,o)+1,p=d(h,a)+1,_=d(u,l)+1,g=f*p*_,m=p*_,v=function(k,G,P){return(d(k,o)*p+d(G,a))*_+d(P,l)},y=[];let S,b;for(S=0;S<s;S++){const k=4*S;b=v(r[k],r[k+1],r[k+2]),y[b]===void 0?y[b]=[S]:y[b].push(S)}const M=be.allocateTyped(Uint32Array,g),E=be.allocateTyped(Uint16Array,g),T=be.allocateTyped(Uint32Array,s);let w=0,A=0,D;for(S=0;S<g;S++){const k=M[S]=w,G=y[S];if(G!==void 0)for(D=0;D<G.length;D++)T[w]=G[D],w++;const P=w-k;E[S]=P,P>A&&(A=P)}this.neighbourListLength=27*A+1,this.withinRadii=function(k,G,P,N,B){let H=0;const W=d(k,o),$=d(G,a),oe=d(P,l),Se=Math.max(0,W-1),K=Math.max(0,$-1),ce=Math.max(0,oe-1),Z=Math.min(f-1,W+1),_e=Math.min(p-1,$+1),xe=Math.min(_-1,oe+1);for(S=Se;S<=Z;++S){const Ee=S*m;for(D=K;D<=_e;++D){const Ne=D*_;for(let Oe=ce;Oe<=xe;++Oe){b=Ee+Ne+Oe;const Ve=M[b],De=Ve+E[b];for(let z=Ve;z<De;z++){const X=4*T[z],ie=r[X]-k,ne=r[X+1]-G,Ae=r[X+2]-P,Pe=r[X+3]+N;ie*ie+ne*ne+Ae*Ae<=Pe*Pe&&(B[H++]=T[z])}}}}B[H]=-1}}function qC(r,e,t,n){const{posRad:s,colors:o,atoms:a}=r,l=s.length/4,{bbox:c}=e,h=c.minPosRad,u=c.maxPosRad;let d,f,p,_,g,m=-1,v,y,S,b,M=null,E=null,T=null,w,A,D,k,G,P,N;const B=new x.Vector3(0,0,0),H=new x.Vector3(0,0,0),W=new x.Vector3(0,0,0);let $;function oe(X,ie,ne){const Ae=be.allocateTyped(X,ie);for(let Pe=0;Pe<ie;++Pe)Ae[Pe]=ne;return Ae}function Se(X,ie,ne){for(let Ae=0;Ae<X.length;Ae++)X[Ae]=ie+ne*Ae}function K(){({scaleFactor:_}=t),{dim:v}=e,$=Math.min(5,2+Math.floor(p*_));const X=v[0]*v[1]*v[2];y=oe(Float32Array,X,-1001),S=be.allocateTyped(Float32Array,X*3),b=be.allocateTyped(Float32Array,X),T&&(M=be.allocateTyped(Float32Array,X),E=[]),w=be.allocateTyped(Float32Array,v[0]),A=be.allocateTyped(Float32Array,v[1]),D=be.allocateTyped(Float32Array,v[2]),Se(w,h[0],1/_),Se(A,h[1],1/_),Se(D,h[2],1/_)}function ce(){let X=0;const ie=2*Math.PI/g;G=be.allocateTyped(Float32Array,g),k=be.allocateTyped(Float32Array,g);for(let ne=0;ne<g;ne++)G[ne]=Math.cos(X),k[ne]=Math.sin(X),X+=ie}function Z(){P=new YC(s,h,u,2.01*f),N=new Int32Array(P.neighbourListLength)}function _e(){({probeRadius:p,scaleFactor:_,probePositions:g,visibilitySelector:T}=t),d=be.allocateTyped(Float32Array,l),f=0;for(let X=0;X<l;++X){const ie=s[X*4+3]+=p;ie>f&&(f=ie),d[X]=ie*ie}K(),ce(),Z(),m=-1}function xe(X,ie,ne,Ae){const Pe=4*X,Ie=d[X],Ge=s[Pe]-ie,Ye=s[Pe+1]-ne,et=s[Pe+2]-Ae;return Ge*Ge+Ye*Ye+et*et<Ie}function Ee(X,ie,ne,Ae,Pe){let Ie;if(m!==-1){if(Ie=m,Ie!==Ae&&Ie!==Pe&&xe(Ie,X,ie,ne))return Ie;m=-1}let Ge=0;for(Ie=N[Ge];Ie>=0;){if(Ie!==Ae&&Ie!==Pe&&xe(Ie,X,ie,ne))return m=Ie,Ie;Ie=N[++Ge]}return m=-1,-1}function Ne(){const ie=1.3333333333333333,ne=1/(2*ie*ie);for(let Ae=0;Ae<l;Ae++){const Pe=4*Ae,Ie=s[Pe],Ge=s[Pe+1],Ye=s[Pe+2],et=s[Pe+3],U=d[Ae];P.withinRadii(Ie,Ge,Ye,et,N);const I=Math.ceil(et*_),fe=Math.floor(_*(Ie-h[0])),Ce=Math.floor(_*(Ge-h[1])),Re=Math.floor(_*(Ye-h[2])),Ue=Math.max(0,fe-I),ke=Math.max(0,Ce-I),C=Math.max(0,Re-I),R=Math.min(v[0],fe+I+2),O=Math.min(v[1],Ce+I+2),j=Math.min(v[2],Re+I+2),q=Ae*3,he=o[q],ee=o[q+1],we=o[q+2];for(let Le=C;Le<j;Le++){const V=D[Le]-Ye,Me=v[1]*v[0]*Le;for(let se=ke;se<O;se++){const ae=A[se]-Ge,ge=V*V+ae*ae,Fe=Me+v[0]*se;for(let Y=Ue;Y<R;Y++){const We=Y+Fe,J=w[Y]-Ie,Qe=ge+J*J;if(Qe<U){const ue=Math.exp(-Qe*ne),it=We*3;S[it]+=he*ue,S[it+1]+=ee*ue,S[it+2]+=we*ue,b[We]+=ue,T!==null&&ue>M[We]&&(M[We]=ue,E[We]=a[Ae]),y[We]<0&&(y[We]=-y[We]);const Xt=Math.sqrt(Qe),$t=et/Xt;let Fn=J*$t,Zt=ae*$t,xt=V*$t;if(Fn+=Ie,Zt+=Ge,xt+=Ye,Ee(Fn,Zt,xt,Ae,-1)===-1){const kt=et-Xt;kt<y[We]&&(y[We]=kt)}}}}}}}function Oe(X,ie){return X.x=X.y=X.z=1,ie.x!==0?X.x=(ie.y+ie.z)/-ie.x:ie.y!==0?X.y=(ie.x+ie.z)/-ie.y:ie.z!==0&&(X.z=(ie.x+ie.y)/-ie.z),X}function Ve(X,ie){const ne=4*X,Ae=4*ie,Pe=s[ne],Ie=s[ne+1],Ge=s[ne+2],Ye=s[ne+3];let et=B.x=s[Ae]-Pe,U=B.y=s[Ae+1]-Ie,I=B.z=s[Ae+2]-Ge;const fe=s[Ae+3];let Ce=et*et+U*U+I*I;const Re=Math.sqrt(Ce),Ue=(Ye*Ye+Re*Re-fe*fe)/(2*Ye*Re),ke=Ye*Ue;B.normalize(),Oe(H,B),H.normalize(),W.crossVectors(B,H),W.normalize();const C=Math.sqrt(Ye*Ye-ke*ke);H.multiplyScalar(C),W.multiplyScalar(C),B.multiplyScalar(ke),B.x+=Pe,B.y+=Ie,B.z+=Ge,m=-1;const R=$;for(let O=0;O<g;O++){const j=G[O],q=k[O],he=B.x+j*H.x+q*W.x,ee=B.y+j*H.y+q*W.y,we=B.z+j*H.z+q*W.z;if(Ee(he,ee,we,X,ie)===-1){const Le=Math.floor(_*(he-h[0])),V=Math.floor(_*(ee-h[1])),Me=Math.floor(_*(we-h[2])),se=Math.max(0,Le-R),ae=Math.max(0,V-R),ge=Math.max(0,Me-R),Fe=Math.min(v[0],Le+R+2),Y=Math.min(v[1],V+R+2),We=Math.min(v[2],Me+R+2);for(let J=ge;J<We;J++){I=we-D[J];const Qe=v[1]*v[0]*J;for(let ue=ae;ue<Y;ue++){U=ee-A[ue];const it=I*I+U*U,Xt=Qe+v[0]*ue;for(let $t=se;$t<Fe;$t++){et=he-w[$t],Ce=it+et*et;const Fn=$t+Xt,Zt=y[Fn];Zt>0&&Ce<Zt*Zt&&(y[Fn]=Math.sqrt(Ce))}}}}}}function De(){for(let X=0;X<l;X++){const ie=4*X;P.withinRadii(s[ie],s[ie+1],s[ie+2],s[ie+3],N);let ne=0,Ae=N[ne];for(;Ae>=0;)X<Ae&&Ve(X,Ae),Ae=N[++ne]}}function z(){for(let X=0,ie=y.length;X<ie;X++){y[X]<0&&(y[X]=0);let ne=b[X];if(ne>0){ne=1/ne;const Ae=X*3;S[Ae]*=ne,S[Ae+1]*=ne,S[Ae+2]*=ne}}}function ye(){console.time("ContactSurface.getVolume"),console.time("ContactSurface.init"),_e(),console.timeEnd("ContactSurface.init"),console.time("ContactSurface.projectPoints"),Ne(),console.timeEnd("ContactSurface.projectPoints"),console.time("ContactSurface.projectTorii"),De(),console.timeEnd("ContactSurface.projectTorii"),z(),console.timeEnd("ContactSurface.getVolume")}this.build=function(){ye(),this.volTexMap=S,this.weightsMap=M,this.atomMap=E,this.volMap=y}}const $C=qC,{Volume:xu}=Bt;class ZC extends ay{_computeSurface(e,t,n,i){const s=new $C(e,n,i);return s.build(),{volMap:new xu(Float32Array,this.numVoxels,t,1,s.volMap),volTexMap:new xu(Float32Array,this.numVoxels,t,3,s.volTexMap),atomMap:s.atomMap,atomWeightMap:new xu(Float32Array,this.numVoxels,t,1,s.weightsMap)}}}const KC=ZC;class JC{constructor(e,t){this.coord=new x.Vector3,this.coord.copy(e),this.radius=t,this.colorX=.99999,this.colorY=0,this.colorZ=0,this.atomType=0,this.srcAtom=null}}const QC=JC;class e3{constructor(e,t,n,i,s){this._numAtoms=e,this._atoms=t,this._vBoxMin=new x.Vector3,this._vBoxMax=new x.Vector3,this._vBoxMin.copy(n),this._vBoxMax.copy(i),this._probeRadius=s,this._atomsList=null,this._voxelList=null}createVoxels(){let e,t;const i=this._numAtoms|0,s=this._atoms,o=this._vBoxMax.x-this._vBoxMin.x,a=this._vBoxMax.y-this._vBoxMin.y,l=this._vBoxMax.z-this._vBoxMin.z;let c=o<a?o:a;c=l<c?l:c;let h=0,u=0,d;for(d=0;d<i;d++)t=(s[d].radius+this._probeRadius)*2,h=t>h?t:h,u+=t;let f=Math.floor(c/h);f<2&&(f=2),u/=i,this._numCells=f,this._aveRad=u,this._maxRad=h;const p=f,_=f*f,g=f*f*f,m=this._xScale=1/(this._vBoxMax.x-this._vBoxMin.x),v=this._yScale=1/(this._vBoxMax.y-this._vBoxMin.y),y=this._zScale=1/(this._vBoxMax.z-this._vBoxMin.z);let S=0;const b=m*f,M=v*f,E=y*f;for(d=0;d<i;d++){const A=(s[d].radius+this._probeRadius)*4.5*2;let D=Math.floor(b*A+.8),k=Math.floor(M*A+.8),G=Math.floor(E*A+.8);D++,k++,G++,S+=D*k*G}this._voxelList=be.allocateTyped(Int32Array,g);const T=[];if(T.length=S,this._voxelList===null||T===null)return-1;for(d=0;d<g;d++)this._voxelList[d]=-1;for(e=0,d=0;d<i;d++){t=(s[d].radius+this._probeRadius)*4.5;let w=Math.floor((s[d].coord.x-this._vBoxMin.x-t)*f*m),A=Math.floor((s[d].coord.y-this._vBoxMin.y-t)*f*v),D=Math.floor((s[d].coord.z-this._vBoxMin.z-t)*f*y),k=Math.floor((s[d].coord.x-this._vBoxMin.x+t)*f*m),G=Math.floor((s[d].coord.y-this._vBoxMin.y+t)*f*v),P=Math.floor((s[d].coord.z-this._vBoxMin.z+t)*f*y);w=w>=0?w:0,A=A>=0?A:0,D=D>=0?D:0,k=k<f?k:f-1,G=G<f?G:f-1,P=P<f?P:f-1;for(let N=D;N<=P;N++)for(let B=A;B<=G;B++)for(let H=w;H<=k;H++){const W=H+B*p+N*_;if(this._voxelList[W]<0){T[e*2+0]=d,T[e*2+1]=-1,this._voxelList[W]=e,e++;continue}const $=this._voxelList[W];this._voxelList[W]=e,T[e*2+0]=d,T[e*2+1]=$,e++}}return this._atomsList=Int32Array.from(T),0}destroyVoxels(){this._atomsList=null,this._voxelList=null,this._atoms=null,this._vertices=null,this._vBoxMin=null,this._vBoxMax=null}forEachRelatedAtom(e,t){const n=Math.floor((e.x-this._vBoxMin.x)*this._numCells*this._xScale),i=Math.floor((e.y-this._vBoxMin.y)*this._numCells*this._yScale),s=Math.floor((e.z-this._vBoxMin.z)*this._numCells*this._zScale),o=n+i*this._numCells+s*this._numCells*this._numCells,a=this._atoms;for(let l=this._voxelList[o];l>=0;l=this._atomsList[l*2+1]){const c=this._atomsList[l*2];t(a[c])}}getClosestAtom(e){let t=null,n=Number.MAX_VALUE;return this.forEachRelatedAtom(e,i=>{const s=e.distanceToSquared(i.coord);s<n&&(n=s,t=i)}),t}buildNormals(e,t,n){const i=this;let s=0,o=0,a=0,l=0,c,h=0,u=0,d=0,f=0,p=0;const _=2.5,g=.1,m=this._aveRad*_,v=m*m,y=-this._aveRad*g,S=function(b){const M=o-b.coord.x,E=a-b.coord.y,T=l-b.coord.z;if(c=M*M+E*E+T*T,c>v)return;const w=b.radius+i._probeRadius;f=c-w*w,f<0&&(f=-f),p=Math.exp(y*f),h+=M*p,u+=E*p,d+=T*p,s++};for(let b=0;b<e;b++)o=t[b].x,a=t[b].y,l=t[b].z,s=0,h=u=d=0,this.forEachRelatedAtom(t[b],S),c=h*h+u*u+d*d,s>0&&(f=1/Math.sqrt(c),h*=f,u*=f,d*=f),n[b].x=h,n[b].y=u,n[b].z=d;return 0}buildColors(e,t,n,i){const s=this;let o=0,a=0,l=0,c=0,h=0;const u=.8,d=i,f=d*d;let p=[],_=[],g=0;const m=function(v){const y=o-v.coord.x,S=a-v.coord.y,b=l-v.coord.z,M=y*y+S*S+b*b;if(M>f)return;const E=v.radius+s._probeRadius;c=M-E*E,c<0&&(c=-c),h=1/(u+c),p.push([v.colorX,v.colorY,v.colorZ]),_.push(h),g+=h};for(let v=0;v<e;v++){o=t[v].x,a=t[v].y,l=t[v].z,p=[],_=[],g=0,this.forEachRelatedAtom(t[v],m);for(let y=0;y<p.length;++y){const S=_[y]/g;n[v].x+=p[y][0]*S,n[v].y+=p[y][1]*S,n[v].z+=p[y][2]*S}}return 0}}const t3=e3;class n3{constructor(e,t,n){this._maxNumVertices=e,this._maxNumTriangles=t,this._vertices=new Array(e),this._normals=new Array(e),this._colors=null,n&&(this._colors=new Array(e)),this._indices=new Array(t*3),this._numVertices=0,this._numTriangles=0;let i;for(i=0;i<e;i++)this._vertices[i]=new x.Vector3,this._normals[i]=new x.Vector3;for(i=0;i<t*3;i++)this._indices[i]=-1;if(n)for(i=0;i<e;i++)this._colors[i]=new x.Vector3}destroy(){this._vertices=null,this._normals=null,this._indices=null}}const Ig=n3,i3=3,vu=32768,{Element:s3}=Bt;class r3 extends sy{_build(){this._innerBuild();const e=this.getGeo();this.destroy(),this._fromGeo(e)}_fromGeo(e){let t=null;const n=be.allocateTyped(Float32Array,3*e._numVertices),i=be.allocateTyped(Float32Array,3*e._numVertices);e._colors!==null&&(t=be.allocateTyped(Float32Array,3*e._numVertices));const s=be.allocateTyped(Uint32Array,3*e._numTriangles);for(let a=0,l=0;a<e._numVertices;a++)n[l+0]=e._vertices[a].x,n[l+1]=e._vertices[a].y,n[l+2]=e._vertices[a].z,i[l+0]=e._normals[a].x,i[l+1]=e._normals[a].y,i[l+2]=e._normals[a].z,l+=3;if(t!==null)for(let a=0,l=0;a<e._numVertices;a++,l+=3)t[l+0]=e._colors[a].x,t[l+1]=e._colors[a].y,t[l+2]=e._colors[a].z;const o=e._numTriangles*3;for(let a=0;a<o;a++)s[a]=e._indices[a];this.setIndex(new x.BufferAttribute(s,1)),this.setAttribute("position",new x.BufferAttribute(n,3)),this.setAttribute("normal",new x.BufferAttribute(i,3)),this.setAttribute("color",new x.BufferAttribute(t,3)),this.computeBoundingBox(),this.computeBoundingSphere(),e.destroy()}convertToAtomsColored(e,t){const{atoms:n,colors:i}=e;for(let s=0,o=n.length;s<o;s++){const a=n[s].position,{radius:l}=n[s].element;t[s]=new QC(a,l);const c=n[s].element.number;t[s].atomType=this.getType(c);let h=i3*s;t[s].colorX=i[h++],t[s].colorY=i[h++],t[s].colorZ=i[h],t[s].srcAtom=n[s]}}getGeo(){return this.geoOut}destroy(){this.atoms=null,this.hashLines=null,this.hashEntries=null}getBoundingBox(e,t,n){t.x=t.y=t.z=1e7,n.x=n.y=n.z=-1e7;const s=this.probeRadius*this.atomRadiusScale;let o=0;for(let a=0,l=e.length;a<l;a++){const c=e[a].coord,h=e[a].radius+s;o=h>o?h:o,c.x-h<t.x&&(t.x=c.x-h),c.y-h<t.y&&(t.y=c.y-h),c.z-h<t.z&&(t.z=c.z-h),c.x+h>n.x&&(n.x=c.x+h),c.y+h>n.y&&(n.y=c.y+h),c.z+h>n.z&&(n.z=c.z+h)}t.x-=o,t.y-=o,t.z-=o,n.x+=o,n.y+=o,n.z+=o}getCornerCoord(e,t,n,i,s,o,a){const l=1/(o-1),c=n*l,h=i*l,u=s*l;a.x=e.x*(1-c)+t.x*c,a.y=e.y*(1-h)+t.y*h,a.z=e.z*(1-u)+t.z*u}buildEdgePoint(e,t,n,i,s,o){if(n[e]^n[t]){const l=(0-i.pointsValuesLinear[s+24+e])/(i.pointsValuesLinear[s+24+t]-i.pointsValuesLinear[s+24+e]),c=i.pointsValuesLinear[s+e*3+0],h=i.pointsValuesLinear[s+e*3+1],u=i.pointsValuesLinear[s+e*3+2],d=i.pointsValuesLinear[s+t*3+0],f=i.pointsValuesLinear[s+t*3+1],p=i.pointsValuesLinear[s+t*3+2];o.x=c*(1-l)+d*l,o.y=h*(1-l)+f*l,o.z=u*(1-l)+p*l}}isTriangleVisible(e,t,n){const i=this.voxelWorld.getClosestAtom(e),s=this.voxelWorld.getClosestAtom(t),o=this.voxelWorld.getClosestAtom(n);return i===null||s===null||o===null||i.srcAtom===null||s.srcAtom===null||o.srcAtom===null?!1:this.visibilitySelector.includesAtom(i.srcAtom)&&this.visibilitySelector.includesAtom(s.srcAtom)&&this.visibilitySelector.includesAtom(o.srcAtom)}addTriangle(e,t,n){if(this.visibilitySelector&&!this.isTriangleVisible(e,t,n))return!0;const i=this.geoOut;if(i._numTriangles>=this.maxNumTriangles)return!1;const s=this.addVertexToGeo(i,e),o=this.addVertexToGeo(i,t),a=this.addVertexToGeo(i,n);if((s|o|a)<0)return!1;const l=3*i._numTriangles;return i._indices[l+0]=s,i._indices[l+1]=o,i._indices[l+2]=a,i._numTriangles++,!0}buildGeoFromCorners(e,t,n,i,s,o){const c=e-1,h=e,u=e*e,d=new Array(12);for(let m=0;m<12;m++)d[m]=new x.Vector3;const f=[];for(let m=0;m<8;m++)f[m]=1;const p=new x.Vector3;let _=0,g=0;for(let m=0;m<c;m++,g+=u){let v=0;for(let y=0;y<c;y++,v+=h)for(let S=0;S<c;S++){if(!o.hasIntersection[_]){_++;continue}const b=o.bitsInside[_];this.getCornerCoord(t,n,S,m,y,e,p);const M=_*32;for(let w=0,A=0;w<8;w++)o.pointsValuesLinear[M+A++]=p.x,o.pointsValuesLinear[M+A++]=p.y,o.pointsValuesLinear[M+A++]=p.z;o.pointsValuesLinear[M+3]+=s.x,o.pointsValuesLinear[M+6]+=s.x,o.pointsValuesLinear[M+15]+=s.x,o.pointsValuesLinear[M+18]+=s.x,o.pointsValuesLinear[M+6+2]+=s.z,o.pointsValuesLinear[M+9+2]+=s.z,o.pointsValuesLinear[M+18+2]+=s.z,o.pointsValuesLinear[M+21+2]+=s.z,o.pointsValuesLinear[M+12+1]+=s.y,o.pointsValuesLinear[M+15+1]+=s.y,o.pointsValuesLinear[M+18+1]+=s.y,o.pointsValuesLinear[M+21+1]+=s.y;const E=M+24;for(let w=0;w<8;++w)f[w]=o.pointsValuesLinear[E+w]<0?1:0;this.buildEdgePoint(0,1,f,o,M,d[0]),this.buildEdgePoint(1,2,f,o,M,d[1]),this.buildEdgePoint(2,3,f,o,M,d[2]),this.buildEdgePoint(3,0,f,o,M,d[3]),this.buildEdgePoint(4,5,f,o,M,d[4]),this.buildEdgePoint(5,6,f,o,M,d[5]),this.buildEdgePoint(6,7,f,o,M,d[6]),this.buildEdgePoint(7,4,f,o,M,d[7]),this.buildEdgePoint(0,4,f,o,M,d[8]),this.buildEdgePoint(1,5,f,o,M,d[9]),this.buildEdgePoint(2,6,f,o,M,d[10]),this.buildEdgePoint(3,7,f,o,M,d[11]);const T=b*16;for(let w=0,A=0;w<6;w++,A+=3){const D=o.striIndicesMarchCube[T+A];if(D<0)break;const k=o.striIndicesMarchCube[T+A+1],G=o.striIndicesMarchCube[T+A+2];if(!this.addTriangle(d[D],d[k],d[G]))return-2}_++}}return 0}getNumIntersectedCells(e,t,n,i){const s=e*e,o=8;let a=0,l=0,c=0;for(let h=0;h<t;h++,c+=s){let u=0;for(let d=0;d<t;d++,u+=e)for(let f=0;f<t;f++){const p=l*32+24,_=f+u+c;i.pointsValuesLinear[p]=n[_],i.pointsValuesLinear[p+1]=n[_+1],i.pointsValuesLinear[p+2]=n[_+e+1],i.pointsValuesLinear[p+3]=n[_+e],i.pointsValuesLinear[p+4]=n[s+_],i.pointsValuesLinear[p+5]=n[s+_+1],i.pointsValuesLinear[p+6]=n[s+_+e+1],i.pointsValuesLinear[p+7]=n[s+_+e];let g=0;for(let m=0;m<o;++m)i.pointsValuesLinear[p+m]<0&&(g|=1<<m);g===0||g===(1<<o)-1?i.hasIntersection[l]=!1:(i.hasIntersection[l]=!0,a++),i.bitsInside[l]=g,l++}}return a}getType(e){const t=[0,0,1,1,2,6,3,6,4,6,5,6,6,0,7,3,8,2,9,6,10,6,11,6,12,6,13,6,14,6,15,4,16,5,17,6,18,6,19,6,20,6,21,6,22,6,23,6,24,6,25,6,26,6,27,6,28,6,29,6,30,6,31,6,32,6,33,6,34,6,35,6,36,6,37,6,38,6,39,6,40,6,41,6,42,6,43,6,44,6,45,6,46,6,47,6,48,6,49,6,50,6,51,6,52,6,53,6,54,6,55,6,56,6,57,6,58,6,59,6,60,6,61,6,62,6,63,6,64,6,65,6,66,6,67,6,68,6,69,6,70,6,71,6,72,6,73,6,74,6,75,6,76,6,77,6,78,6,79,6,80,6,81,6,82,6,83,6,84,6,85,6,86,6,87,6,88,6,89,6,90,6,91,6,92,6,93,6,94,6,95,6,96,6,97,6,98,6,99,6,100,6,101,6,102,6,103,6,104,6,105,6,106,6,107,6,108,6,109,6];if(e<1||e>t.length/2||Object.keys(s3.ByAtomicNumber).length*2!==t.length)throw new Error("atomT.length  should be equal Element.ByAtomicNumber.length * 2");return t[e*2]}calculateGridCorners(e,t,n,i,s,o){const a=t*t,l=a*t,c=new x.Vector3,h=new x.Vector3,u=1e12;for(let _=0;_<l;_++)e[_]=u;const d=(t-1)/(i.x-n.x),f=(t-1)/(i.y-n.y),p=(t-1)/(i.z-n.z);for(let _=0,g=s.length;_<g;_++){const m=s[_],v=m.radius+o,y=(m.coord.x-v-n.x)*d,S=(m.coord.y-v-n.y)*f,b=(m.coord.z-v-n.z)*p,M=Math.floor(y),E=Math.floor(S),T=Math.floor(b);let w=Math.floor((m.coord.x+v-n.x)*d),A=Math.floor((m.coord.y+v-n.y)*f),D=Math.floor((m.coord.z+v-n.z)*p);w++,A++,D++,w=w<=t-1?w:t-1,A=A<=t-1?A:t-1,D=D<=t-1?D:t-1;for(let k=E;k<=A;k++){const G=k*a;for(let P=T;P<=D;P++){const N=P*t;for(let B=M;B<=w;B++){const H=G+N+B;this.getCornerCoord(n,i,B,k,P,t,c),h.x=c.x-m.coord.x,h.y=c.y-m.coord.y,h.z=c.z-m.coord.z;const $=Math.sqrt(h.x*h.x+h.y*h.y+h.z*h.z)-v;$<e[H]&&(e[H]=$)}}}}}createVertexHash(e,t){if(this.hashLines=be.allocateTyped(Int32Array,vu*2),this.hashLines===null)return-1;for(let n=0,i=0;n<vu;n++)this.hashLines[i++]=0,this.hashLines[i++]=-1;if(this.maxNumVertices=e,this.maxNumTriangles=t,this.numHashEtriesAllocated=e,this.hashEntries=be.allocateTyped(Int32Array,2*this.numHashEtriesAllocated),this.hashEntries===null)return-1;for(let n=0,i=0;n<this.numHashEtriesAllocated;n++)this.hashEntries[i++]=-1,this.hashEntries[i++]=-1;return this.numHashEntryIndex=0,0}getNewHashEntry(){if(this.numHashEntryIndex<this.numHashEtriesAllocated){const e=this.numHashEntryIndex;return this.numHashEntryIndex++,e}return-1}addVertexToGeo(e,t){let n;const c=this.marCubeResoultion<<2,h=new x.Vector3,u=Math.floor(c*(t.x-this.vBoxMin.x)/(this.vBoxMax.x+.01-this.vBoxMin.x)),d=Math.floor(c*(t.y-this.vBoxMin.y)/(this.vBoxMax.y+.01-this.vBoxMin.y)),f=Math.floor(c*(t.z-this.vBoxMin.z)/(this.vBoxMax.z+.01-this.vBoxMin.z));let p=u*815851+f*37633+d*2453543;p&=vu-1;const _=p+p;if(this.vBoxMin!==null&&this.vBoxMax!==null)for(n=this.hashLines[_+1];n>=0;n=this.hashEntries[n*2+1]){const m=this.hashEntries[n*2+0];if(h.copy(e._vertices[m]),h.x-=t.x,h.y-=t.y,h.z-=t.z,h.x*h.x+h.y*h.y+h.z*h.z<1e-6)return m}if(e._numVertices>=this.maxNumVertices)return-1;const g=e._numVertices;if(e._vertices[g].copy(t),this.vBoxMin!==null&&this.vBoxMax!==null){if(n=this.getNewHashEntry(),n<0)return-1;const m=this.hashLines[_+1];this.hashLines[_+1]=n,this.hashEntries[n*2+0]=g,this.hashEntries[n*2+1]=m,this.hashLines[_+0]++}return e._numVertices++,g}modifyExcludedFromGeo(e,t,n,i,s,o){let a,l,c;function u(){c>0&&o[a]<0&&(o[a]=c),c>o[a]&&(o[a]=c)}const d=e*e,f=(e-1)/(i.x-n.x),p=(e-1)/(i.y-n.y),_=(e-1)/(i.z-n.z),g=t*2*(t*2),m=1/(e-1);for(let v=0;v<s._numVertices;v++){const y=s._vertices[v],S=t*1.1;let b=Math.floor((y.x-S-n.x)*f),M=Math.floor((y.y-S-n.y)*p),E=Math.floor((y.z-S-n.z)*_),T=Math.floor((y.x+S-n.x)*f),w=Math.floor((y.y+S-n.y)*p),A=Math.floor((y.z+S-n.z)*_);b=b>=0?b:0,M=M>=0?M:0,E=E>=0?E:0,T=T<=e-1?T:e-1,w=w<=e-1?w:e-1,A=A<=e-1?A:e-1;for(let D=M;D<=w;D++){const k=D*d;for(let G=E;G<=A;G++){const P=G*e;for(let N=b;N<=T;N++){a=k+P+N;let B=N*m;const H=n.x*(1-B)+i.x*B;B=D*m;const W=n.y*(1-B)+i.y*B;B=G*m;const $=n.z*(1-B)+i.z*B,oe=H-y.x,Se=W-y.y,K=$-y.z,ce=oe*oe+Se*Se+K*K;ce<g&&(l=Math.sqrt(ce),c=-(l-t),u())}}}}return 0}_innerBuild(){let e;const n={posRad:this._posRad,colors:this._colors,atoms:this._opts.atoms};this.complex=this._opts.parent,this.atoms=n.atoms,this.meshResolution=this._opts.gridSpacing,this.atomRadiusScale=this._opts.radScale,this.colorMode=this._opts.colorMode,this.probeRadius=this._opts.probeRadius,this.useVertexColors=!0,this.excludeProbe=this._opts.excludeProbe,this.visibilitySelector=this._opts.visibilitySelector,this.geoOut=null,this.hashLines=null,this.hashEntries=null,this.numHashEtriesAllocated=0,this.numHashEntryIndex=0,this.maxNumVertices=0,this.maxNumTriangles=0;const i=new Array(this.atoms.length);this.convertToAtomsColored(n,i);const s=this.vBoxMin=new x.Vector3,o=this.vBoxMax=new x.Vector3;this.getBoundingBox(i,s,o);const a=this.marCubeResoultion=this.meshResolution*4,l=a,h=l*l*l,u=be.allocateTyped(Float32Array,h),d=this.probeRadius*this.atomRadiusScale;this.calculateGridCorners(u,l,s,o,i,d);const f=a-1,p=new oy;if(e=p.create(f),e<0)return e;const _=new x.Vector3;_.x=(o.x-s.x)/f,_.y=(o.y-s.y)/f,_.z=(o.z-s.z)/f;let g=this.getNumIntersectedCells(l,f,u,p),m=Math.floor(g*1.2),v=Math.floor(g*1.2*2);if(this.geoOut=new Ig(m,v,this.useVertexColors),e=this.createVertexHash(m,v),e<0)return e;let y=d;if(this.excludeProbe&&(y=.01),this.voxelWorld=new t3(i.length,i,s,o,y),this.voxelWorld.createVoxels(),e=this.buildGeoFromCorners(a,s,o,u,_,p),this.excludeProbe){if(this.modifyExcludedFromGeo(l,d,s,o,this.geoOut,u),this.geoOut._vertices=null,this.geoOut._colors=null,this.geoOut._indices=null,this.geoOut._normals=null,this.geoOut._numVertices=0,this.geoOut._numTriangles=0,this.geoOut=null,g=this.getNumIntersectedCells(l,f,u,p),m=Math.floor(g*1.2),v=Math.floor(g*1.2*2),this.geoOut=new Ig(m,v,this.useVertexColors),e=this.createVertexHash(m,v),e<0)return e;e=this.buildGeoFromCorners(l,s,o,u,_,p)}this.voxelWorld.buildNormals(this.geoOut._vertices.length,this.geoOut._vertices,this.geoOut._normals);let S=6.5;return this.excludeProbe&&(S-=1.5),this.useVertexColors&&this.voxelWorld.buildColors(this.geoOut._vertices.length,this.geoOut._vertices,this.geoOut._colors,S),this.voxelWorld.destroyVoxels(),this.voxelWorld=null,p.destroy(),e}}const o3=r3;function a3(r,e){const t=document.createElement("div");if(t.className=e,typeof r=="string"){const n=document.createElement("span");n.style.fontSize="150%";const i=r.split(`
`);for(let s=0,o=i.length;s<o;++s){const a=document.createElement("span"),l=document.createTextNode(i[s]);a.appendChild(l),n.appendChild(a),s<o-1&&n.appendChild(document.createElement("br"))}t.appendChild(n)}else t.appendChild(r);return t.worldPos=new x.Vector3,t}class l3 extends Dn{constructor(e,t){super(),this._opts=t,this.items=[],this.needsUpdate=!1;let n=-50,i=-50;switch(t.horizontalAlign){case"left":n=0;break;case"right":n=-100;break}switch(t.verticalAlign){case"top":i=-100;break;case"bottom":i=0;break}const s=new x.Vector3(t.dx||0,t.dy||0,t.dz||0);this.userData={translation:`translate(${n}%, ${i}%)`,offset:s}}setItem(e,t,n){const i=this._opts,s=this.items[e]||a3(n,"label");s.worldPos.copy(t),s.style.textAlign=i.horizontalAlign,s.style.verticalAlign=i.verticalAlign,this.items[e]=s}setColor(e,t,n){const i=this.items[e];i.opts={color:t,background:n}}startUpdate(){return!0}finishUpdate(){this.needsUpdate=!0,this.dispatchEvent({type:"update"})}finalize(){this.finishUpdate()}raycast(){}setOpacity(){}getSubset(){return[]}}const c3=l3,ai={InstancedSpheresGeometry:J0,Instanced2CCylindersGeometry:ey,ExtrudedObjectsGeometry:CC,ChunkedLinesGeometry:iy,TwoColorLinesGeometry:UC,CrossGeometry:zC,QuickSurfGeometry:jC,ContactSurfaceGeometry:KC,SSIsosurfaceGeometry:o3,LabelsGeometry:c3},h3=`float INSTANCED_SPRITE_OVERSCALE = 1.3;\r
\r
attribute vec3 normal;\r
\r
#ifdef NORMALS_TO_G_BUFFER\r
  varying vec3 viewNormal;\r
#endif\r
#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r
  varying vec3 vNormal;\r
#endif\r
\r
#ifdef THICK_LINE\r
  attribute vec4 position; // W contains vert pos or neg offset\r
#else\r
  attribute vec3 position;\r
#endif\r
\r
varying vec3 vWorldPosition;\r
varying vec3 vViewPosition;\r
\r
#ifdef ATTR_ALPHA_COLOR\r
  attribute float alphaColor;\r
  varying float alphaCol;\r
#endif\r
\r
#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r
	#if NUM_DIR_LIGHTS > 0\r
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r
		varying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r
	#endif\r
#endif\r
\r
#ifdef ATTR_COLOR\r
  attribute vec3 color;\r
  varying vec3 vColor;\r
#endif\r
\r
#ifdef ATTR_COLOR2\r
  attribute vec3 color2;\r
  varying vec3 vColor2;\r
  attribute vec2 uv;\r
  #ifndef CYLINDER_SPRITE\r
    varying vec2 vUv;\r
  #endif\r
#endif\r
\r
#ifdef INSTANCED_POS\r
  attribute vec4 offset;\r
  #ifdef SPHERE_SPRITE\r
    varying vec4 instOffset;\r
  varying vec4 spritePosEye;\r
  #endif\r
#endif\r
\r
#ifdef INSTANCED_MATRIX\r
  attribute vec4 matVector1;\r
  attribute vec4 matVector2;\r
  attribute vec4 matVector3;\r
  attribute vec4 invmatVector1;\r
  attribute vec4 invmatVector2;\r
  attribute vec4 invmatVector3;\r
\r
  #ifdef CYLINDER_SPRITE\r
    varying vec4 matVec1;\r
    varying vec4 matVec2;\r
    varying vec4 matVec3;\r
    varying vec4 invmatVec1;\r
    varying vec4 invmatVec2;\r
    varying vec4 invmatVec3;\r
    varying vec4 spritePosEye;\r
  #endif\r
#endif\r
\r
uniform mat4 modelViewMatrix; // optional\r
uniform mat4 projectionMatrix; // optional\r
uniform mat3 normalMatrix; // optional\r
uniform mat4 modelMatrix; // optional\r
\r
#ifdef DASHED_LINE\r
  attribute float lineDistance;\r
  varying float vLineDistance;\r
#endif\r
\r
#ifdef THICK_LINE\r
  attribute vec3 direction;\r
  uniform mat4 projMatrixInv;\r
  uniform vec2 viewport;\r
  uniform float lineWidth;\r
\r
  vec4 transform(vec4 coord){\r
    return projectionMatrix * modelViewMatrix * coord;\r
  }\r
\r
  vec2 project(vec4 device){\r
    vec3 device_normal = device.xyz/device.w;\r
    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r
    return clip_pos * viewport;\r
  }\r
\r
  vec4 unproject(vec2 screen, float z, float w){\r
    vec2 clip_pos = screen/viewport;\r
    vec2 device_normal = clip_pos*2.0-1.0;\r
    return vec4(device_normal*w, z, w);\r
  }\r
#endif\r
\r
\r
/////////////////////////////////////////// Main ///////////////////////////////////////////////\r
void main() {\r
\r
#ifdef ATTR_ALPHA_COLOR\r
  alphaCol = alphaColor;\r
#endif\r
\r
#ifdef INSTANCED_MATRIX\r
  vec3 objectNormal = vec3(\r
    dot(normal, matVector1.xyz),\r
    dot(normal, matVector2.xyz),\r
    dot(normal, matVector3.xyz));\r
#else\r
  vec3 objectNormal = vec3( normal );\r
#endif\r
\r
vec3 transformedNormal = normalMatrix * objectNormal;\r
\r
#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r
  vNormal = normalize(transformedNormal);\r
#endif\r
\r
#ifdef NORMALS_TO_G_BUFFER\r
  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r
#endif\r
\r
  vec4 localPos = vec4(position.xyz, 1.0);\r
  vec4 worldPos = modelMatrix * localPos;\r
  vec4 mvPosition = modelViewMatrix * localPos;\r
\r
// make thick line offset\r
#ifdef THICK_LINE\r
   // get screen pos\r
   vec4 dPos = transform(vec4(position.xyz, 1.0));\r
   vec2 sPos = project(dPos);\r
   // move pos forward\r
   vec3 position2 = position.xyz + direction.xyz * 0.5;\r
   // get screen offset pos\r
   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r
   vec2 sPos2 = project(dPos2);\r
   // screen line direction\r
   vec2 sDir = normalize(sPos2 - sPos);\r
   // vertex offset (orthogonal to line direction)\r
   vec2 offset1 = vec2(-sDir.y, sDir.x);\r
   // move screen vertex\r
   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r
   // get moved pos in view space\r
   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r
   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r
#endif // THICK_LINE\r
\r
#ifdef INSTANCED_POS\r
  #ifdef SPHERE_SPRITE\r
    instOffset = offset;\r
\r
    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r
    float scale = length(modelViewMatrix[0]);\r
    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r
    posEye.w = offset.w * scale;\r
\r
    spritePosEye = posEye;\r
 #else\r
    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r
    worldPos = modelMatrix * localPos;\r
    mvPosition = modelViewMatrix * localPos;\r
  #endif\r
#endif\r
\r
#ifdef INSTANCED_MATRIX\r
  #ifdef CYLINDER_SPRITE\r
    matVec1 = matVector1;\r
    matVec2 = matVector2;\r
    matVec3 = matVector3;\r
    invmatVec1 = invmatVector1;\r
    invmatVec2 = invmatVector2;\r
    invmatVec3 = invmatVector3;\r
\r
    // calculate eye coords of cylinder endpoints\r
    vec4 v = vec4(0, -0.5, 0, 1);\r
    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r
    v.y = 0.5;\r
    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r
\r
    // sprite is placed at the center of cylinder\r
    vec4 posEye;\r
    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r
    posEye.w = 1.0;\r
    spritePosEye = posEye;\r
\r
    // cylinder radius in eye space\r
    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r
    vec2 spriteSize;\r
    #ifdef ORTHOGRAPHIC_CAMERA\r
      // In ortho projection we skip z coordinate\r
      // basic sprite size at screen plane (covers only cylinder axis)\r
      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r
\r
      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r
    #else\r
      // basic sprite size at screen plane (covers only cylinder axis)\r
      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r
\r
      // full sprite size in eye coords\r
      float minZ = min(abs(p1.z), abs(p2.z));\r
      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r
    #endif\r
\r
    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r
  #else\r
    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r
    worldPos = modelMatrix * localPos;\r
    mvPosition = modelViewMatrix * localPos;\r
  #endif\r
#endif\r
\r
  gl_Position = projectionMatrix * mvPosition;\r
\r
  vWorldPosition = worldPos.xyz;\r
  vViewPosition = - mvPosition.xyz;\r
\r
#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r
	#if NUM_DIR_LIGHTS > 0\r
	  vec4 worldPosition;\r
	  // see THREE.WebGLProgram.unrollLoops\r
	  #pragma unroll_loop_start\r
	  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r
      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r
      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r
	  }\r
	  #pragma unroll_loop_end\r
	#endif\r
#endif\r
\r
#ifdef ATTR_COLOR\r
  vColor = color.xyz;\r
#endif\r
\r
#ifdef ATTR_COLOR2\r
  vColor2 = color2;\r
  #ifndef CYLINDER_SPRITE\r
    vUv = uv;\r
  #endif\r
#endif\r
\r
#ifdef DASHED_LINE\r
  vLineDistance = lineDistance;\r
#endif\r
}\r
`,u3=`#if defined (NORMALS_TO_G_BUFFER)\r
  #define fragColor gl_FragData[0]\r
#else\r
  #define fragColor gl_FragColor\r
#endif\r
\r
#ifdef ATTR_ALPHA_COLOR\r
  varying float alphaCol;\r
#endif\r
\r
#ifdef COLOR_FROM_POS\r
  uniform mat4 world2colorMatrix;\r
#endif\r
\r
#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r
	#if NUM_DIR_LIGHTS > 0\r
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r
    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r
		varying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r
    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r
    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r
\r
    #ifdef SHADOWMAP_PCF_RAND\r
      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r
      // unroll_loop and unroll_loop has pattern:\r
      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r
      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r
      uniform sampler2D noiseTex;\r
      uniform vec2 noiseTexelSize;\r
      uniform vec2 srcTexelSize;\r
      uniform mat4 projectionMatrix;\r
    #endif\r
	#endif\r
#endif\r
\r
#ifdef ATTR_COLOR\r
  varying vec3 vColor;\r
#endif\r
\r
#ifdef ATTR_COLOR2\r
  varying vec3 vColor2;\r
  #ifndef CYLINDER_SPRITE\r
    varying vec2 vUv;\r
  #endif\r
#endif\r
\r
uniform vec3 diffuse;\r
uniform vec3 emissive;\r
uniform vec3 specular;\r
uniform float shininess;\r
uniform vec3 fixedColor;\r
uniform float opacity;\r
uniform float zClipValue;\r
uniform float clipPlaneValue;\r
\r
#ifdef NORMALS_TO_G_BUFFER\r
  varying vec3 viewNormal;\r
#endif\r
\r
#define RECIPROCAL_PI 0.31830988618\r
#define saturate(a) clamp( a, 0.0, 1.0 )\r
\r
#ifdef USE_FOG\r
  uniform vec3 fogColor;\r
  uniform float fogAlpha;\r
  uniform float fogNear;\r
  uniform float fogFar;\r
#endif\r
\r
varying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r
varying vec3 vViewPosition;\r
\r
#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r
  varying vec3 vNormal;\r
#endif\r
\r
/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r
#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r
  uniform float nearPlaneValue;\r
#endif\r
\r
#ifdef SPHERE_SPRITE\r
  varying vec4 spritePosEye;\r
#endif\r
\r
#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r
  uniform float zOffset;\r
\r
  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r
    uniform mat4 projectionMatrix;\r
  #endif\r
\r
  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r
    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r
    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r
  }\r
#endif\r
\r
#ifdef SPHERE_SPRITE\r
  varying vec4 instOffset;\r
  uniform mat4 modelMatrix;\r
  uniform mat4 modelViewMatrix;\r
  uniform mat4 invModelViewMatrix;\r
  uniform mat3 normalMatrix;\r
\r
\r
  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r
\r
    // intersect XZ-projected ray with circle\r
    float a = dot(ray, ray);\r
    float b = dot(ray, origin);\r
    float c = dot(origin, origin) - 1.0;\r
    float det = b * b - a * c;\r
    if (det < 0.0) return false;\r
    float t1 = (-b - sqrt(det)) / a;\r
    float t2 = (-b + sqrt(det)) / a;\r
\r
    // calculate both intersection points\r
    vec3 p1 = origin + ray * t1;\r
    vec3 p2 = origin + ray * t2;\r
\r
    // choose nearest point inside frustum\r
    #ifdef ORTHOGRAPHIC_CAMERA\r
      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r
      // t1 is always smaller than t2 (from calculations)\r
      point = p1;\r
      frontFaced = 1.0;\r
      return true;\r
    #else\r
      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r
      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r
      if (t1 >= 0.0) {\r
        point = p1;\r
        frontFaced = 1.0;\r
        return true;\r
      }\r
      if (t2 >= 0.0) {\r
        point = p2;\r
        frontFaced = -1.0;\r
        return true;\r
      }\r
    #endif\r
\r
    return false;\r
  }\r
\r
  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r
    vec3 origin, ray;\r
\r
    #ifdef ORTHOGRAPHIC_CAMERA\r
      // transform vector from sprite center to curPixel into sphere local coords\r
      origin = pixelPosEye.xyz - spritePosEye.xyz;\r
      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r
\r
      // transform camera orientation vector into sphere local coords\r
      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r
    #else\r
      // find point of intersection near plane by the ray from camera to curPixel\r
      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r
\r
      // transform intersection point into sphere local coords\r
      v = invModelViewMatrix * v;\r
      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r
\r
      // transform vector from camera pos to curPixel into sphere local coords\r
      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r
    #endif\r
    ray = normalize(ray);\r
\r
    return intersect_ray_sphere(origin, ray, point, frontFaced);\r
  }\r
#endif\r
\r
#ifdef CYLINDER_SPRITE\r
  varying vec4 matVec1;\r
  varying vec4 matVec2;\r
  varying vec4 matVec3;\r
  varying vec4 invmatVec1;\r
  varying vec4 invmatVec2;\r
  varying vec4 invmatVec3;\r
\r
  uniform mat4 modelMatrix;\r
  uniform mat4 modelViewMatrix;\r
  uniform mat4 invModelViewMatrix;\r
  uniform mat3 normalMatrix;\r
\r
  varying vec4 spritePosEye;\r
\r
  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r
\r
    // intersect XZ-projected ray with circle\r
    float a = dot(ray.xz, ray.xz);\r
    float b = dot(ray.xz, origin.xz);\r
    float c = dot(origin.xz, origin.xz) - 1.0;\r
    float det = b * b - a * c;\r
    if (det < 0.0) return false;\r
    float t1 = (-b - sqrt(det)) / a;\r
    float t2 = (-b + sqrt(det)) / a;\r
\r
    // calculate both intersection points\r
    vec3 p1 = origin + ray * t1;\r
    vec3 p2 = origin + ray * t2;\r
\r
    float halfHeight = 0.5;\r
\r
    // choose nearest point\r
    #ifdef ORTHOGRAPHIC_CAMERA\r
      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r
      // if it is not outside of cylinnder (t1 is always smaller than t2).\r
      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r
        point = p1;\r
        frontFaced = 1.0;\r
        return true;\r
      }\r
      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r
        point = p2;\r
        frontFaced = -1.0;\r
        return true;\r
      }\r
    #else\r
      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r
      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r
      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r
        point = p1;\r
        frontFaced = 1.0;\r
        return true;\r
      }\r
      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r
        point = p2;\r
        frontFaced = -1.0;\r
        return true;\r
      }\r
    #endif\r
\r
    return false;\r
  }\r
\r
  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r
    vec3 origin, ray;\r
    vec4 v;\r
\r
    #ifdef ORTHOGRAPHIC_CAMERA\r
      // transform vector from sprite center to curPixel into cylinder local coords\r
      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r
      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r
\r
      // transform camera orientation vector into cylinder local coords\r
      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r
      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r
    #else\r
      // find point of intersection near plane by the ray from camera to curPixel\r
      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r
\r
      // transform intersection point into cylinder local coords\r
      v = invModelViewMatrix * v;\r
      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r
\r
      // transform vector from camera pos to curPixel into cylinder local coords\r
      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r
      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r
    #endif\r
    ray = normalize(ray);\r
\r
    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r
  }\r
#endif\r
\r
///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r
const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r
\r
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r
\r
\r
const float ShiftRight8 = 1. / 256.;\r
\r
vec4 packDepthToRGBA( const in float v ) {\r
  vec4 r = vec4( fract( v * PackFactors ), v );\r
  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r
  return r * PackUpscale;\r
}\r
\r
float unpackRGBAToDepth( const in vec4 v ) {\r
  return dot( v, UnpackFactors );\r
}\r
\r
////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r
#ifdef TOON_SHADING\r
  #define LOW_TOON_BORDER 0.0\r
  #define MEDIUM_TOON_BORDER 0.7\r
  #define HIGH_TOON_BORDER 1.0\r
\r
  #define MEDIUM_TOON_RANGE 0.5\r
  #define HIGH_TOON_RANGE 0.95\r
#endif\r
#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r
  struct ReflectedLight {\r
    vec3 directDiffuse;\r
    vec3 directSpecular;\r
    vec3 indirectDiffuse;\r
  };\r
\r
  struct BlinnPhongMaterial {\r
    vec3  diffuseColor;\r
    vec3  specularColor;\r
    float specularShininess;\r
  };\r
\r
  struct GeometricContext {\r
    vec3 normal;\r
    vec3 viewDir;\r
  };\r
\r
  struct DirectionalLight {\r
    vec3 direction;\r
    vec3 color;\r
  };\r
  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r
\r
  struct DirectionalLightShadow {\r
     vec2 shadowMapSize;\r
     float shadowBias;\r
     float shadowRadius;\r
   };\r
  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r
\r
  uniform vec3 ambientLightColor;\r
\r
  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r
\r
  #if defined(SHADOWMAP)\r
  	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r
  		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r
  	}\r
\r
    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r
   	  float shadow = 0.0;\r
\r
      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r
      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r
      shadowCoord.xyz /= shadowCoord.w;\r
\r
      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r
      bool inFrustum = all( inFrustumVec );\r
      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r
      bool frustumTest = all( frustumTestVec );\r
\r
      if ( frustumTest ) {\r
        #ifdef SHADOWMAP_BASIC\r
      	  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r
      	#endif\r
\r
      	#ifdef SHADOWMAP_PCF_SHARP\r
      	  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r
\r
            float dx0 = - texelSize.x * dirLight.shadowRadius;\r
            float dy0 = - texelSize.y * dirLight.shadowRadius;\r
            float dx1 = + texelSize.x * dirLight.shadowRadius;\r
            float dy1 = + texelSize.y * dirLight.shadowRadius;\r
\r
            shadow = (\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r
            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r
            ) * ( 1.0 / 9.0 );\r
        #endif\r
\r
        #ifdef SHADOWMAP_PCF_RAND\r
          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r
\r
          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r
          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r
\r
          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r
          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r
\r
          vec2 offset;\r
          #pragma unroll_loop_start\r
          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r
            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r
            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r
          }\r
          #pragma unroll_loop_end\r
          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r
        #endif\r
      }\r
      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r
   }\r
  #endif\r
\r
  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r
\r
  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r
    return RECIPROCAL_PI * diffuseColor;\r
  } // validated\r
\r
  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r
    // Original approximation by Christophe Schlick '94\r
    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r
    // Optimized variant (presented by Epic at SIGGRAPH '13)\r
    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r
    return ( 1.0 - specularColor ) * fresnel + specularColor;\r
  } // validated\r
\r
  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r
    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r
    return 0.25;\r
  }\r
\r
  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r
    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r
  }\r
\r
  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r
    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r
    float dotNH = saturate(dot( geometry.normal, halfDir ));\r
    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r
\r
    vec3 F = F_Schlick( specularColor, dotLH );\r
    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r
    float D = D_BlinnPhong( shininess, dotNH );\r
\r
    return F * ( G * D );\r
  } // validated\r
\r
  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r
\r
    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r
    #ifdef TOON_SHADING\r
      if(dotNL < MEDIUM_TOON_RANGE){\r
        dotNL = LOW_TOON_BORDER;\r
      }\r
      else if(dotNL < HIGH_TOON_RANGE){\r
        dotNL = MEDIUM_TOON_BORDER;\r
      }\r
      else{\r
        dotNL = HIGH_TOON_BORDER;\r
      }\r
    #endif\r
\r
    vec3 irradiance = dotNL * directLight.color;\r
    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r
    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r
  }\r
\r
  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r
    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r
  }\r
\r
  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r
    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r
    vec3 irradiance = ambientLightColor;\r
\r
    float shadowMask = 1.0;\r
    // see THREE.WebGLProgram.unrollLoops\r
  	#pragma unroll_loop_start\r
  	  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r
  	    #ifdef SHADOWMAP\r
  	      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r
        #endif\r
\r
  		  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r
  		}\r
  		#pragma unroll_loop_end\r
\r
    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r
\r
    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r
  }\r
#endif\r
\r
/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r
#ifdef DASHED_LINE\r
  uniform float dashedLineSize;\r
  uniform float dashedLinePeriod;\r
  varying float vLineDistance;\r
#endif\r
\r
/////////////////////////////////////////// Main ///////////////////////////////////////////////\r
void main() {\r
\r
#ifdef CLIP_PLANE\r
  if (vViewPosition.z < clipPlaneValue) discard;\r
#endif\r
\r
#ifdef ZCLIP\r
  if (vViewPosition.z < zClipValue) discard;\r
#endif\r
\r
#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r
  #if NUM_DIR_LIGHTS > 0\r
    // see THREE.WebGLProgram.unrollLoops\r
    #pragma unroll_loop_start\r
    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r
      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r
      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r
    }\r
    #pragma unroll_loop_end\r
  #endif\r
#endif\r
\r
  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r
  vec4 pixelPosEye;\r
\r
#ifdef SPHERE_SPRITE\r
\r
  vec3 viewNormalSprites;\r
  float frontFaced = 1.0;\r
  vec3 normal;\r
\r
/* quick-and-dirty method\r
  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r
  float r2 = dot(normal.xy, normal.xy);\r
  if (r2 > 1.0) discard;\r
  float normalZ = sqrt(1.0 - r2);\r
  normal.z = normalZ;\r
  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r
  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r
  pixelPosEye.z += spritePosEye.w * normalZ;\r
*/\r
\r
  // ray-trace sphere surface\r
  {\r
    vec3 p;\r
    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r
    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r
    pixelPosWorld = modelMatrix * v;\r
    pixelPosEye = modelViewMatrix * v;\r
    normal = normalize(normalMatrix * p);\r
    #ifdef NORMALS_TO_G_BUFFER\r
      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r
    #endif\r
\r
    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r
      #if NUM_DIR_LIGHTS > 0\r
        // see THREE.WebGLProgram.unrollLoops\r
        #pragma unroll_loop_start\r
          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r
            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r
            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r
          }\r
        #pragma unroll_loop_end\r
      #endif\r
    #endif\r
  }\r
#endif\r
\r
#ifdef CYLINDER_SPRITE\r
  vec3 normal;\r
  vec3 viewNormalSprites;\r
  float frontFaced = 1.0;\r
  float cylinderY = 0.0;\r
\r
  // ray-trace cylinder surface\r
  {\r
    vec3 p;\r
    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r
\r
    cylinderY = 0.5 * (p.y + 1.0);\r
\r
    vec4 v = vec4(p, 1.0);\r
    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r
    pixelPosWorld = modelMatrix * v;\r
    pixelPosEye = modelViewMatrix * v;\r
\r
    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r
    normal = vec3(\r
      dot(localNormal, matVec1.xyz),\r
      dot(localNormal, matVec2.xyz),\r
      dot(localNormal, matVec3.xyz));\r
    #ifdef NORMALS_TO_G_BUFFER\r
      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r
    #endif\r
\r
    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r
      #if NUM_DIR_LIGHTS > 0\r
        // see THREE.WebGLProgram.unrollLoops\r
        #pragma unroll_loop_start\r
          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r
            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r
            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r
          }\r
        #pragma unroll_loop_end\r
      #endif\r
    #endif\r
\r
    normal = normalize(normalMatrix * normal);\r
  }\r
#endif\r
\r
  #ifdef ATTR_COLOR\r
    vec3 vertexColor = vColor;\r
  #else\r
    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r
  #endif\r
\r
  #ifdef ATTR_COLOR2\r
    #ifdef CYLINDER_SPRITE\r
      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r
    #else\r
      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r
    #endif\r
      // choose either color or color2\r
    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r
  #endif\r
\r
  // negative red component is a special condition\r
  if (vertexColor.x < 0.0) discard;\r
\r
  #ifdef DASHED_LINE\r
    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r
  #endif\r
\r
  // transparency prepass writes only z, so we don't need to calc the color\r
  #ifdef PREPASS_TRANSP\r
    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r
    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r
      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r
    #endif\r
    return;\r
  #endif\r
\r
    float totalOpacity = opacity;\r
\r
  #ifdef ATTR_ALPHA_COLOR\r
    totalOpacity *= alphaCol;\r
  #endif\r
\r
  // discard fully transparent pixels\r
  if (totalOpacity == 0.0) discard;\r
\r
  #ifdef FAKE_OPACITY\r
    // discard pixels in checker pattern\r
    vec2 dm_coord = floor(gl_FragCoord.xy);\r
    dm_coord = fract(dm_coord * 0.5);\r
    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r
    vec4 diffuseColor = vec4(diffuse, 1.0);\r
  #else\r
    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r
  #endif\r
\r
  float flipNormal;\r
  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r
    flipNormal = 1.0;\r
    #ifdef DOUBLE_SIDED\r
      flipNormal = float( gl_FrontFacing );\r
    #endif\r
    vec3 normal = normalize( vNormal ) * flipNormal;\r
  #endif\r
\r
    diffuseColor.rgb *= vertexColor;\r
\r
  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r
    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r
  #endif\r
\r
  #ifdef NORMALS_TO_G_BUFFER\r
    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r
      vec3 viewNormaInColor = viewNormalSprites;\r
    #else\r
      vec3 viewNormaInColor = viewNormal;\r
      float frontFaced = float( gl_FrontFacing );\r
    #endif\r
    // [-1, 1] -> [0, 1]\r
    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r
    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r
  #endif\r
\r
  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r
    vec3 viewDir;\r
    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r
      viewDir = -pixelPosEye.xyz;\r
    #else\r
      viewDir = vViewPosition;\r
    #endif\r
    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r
    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r
    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r
  #else\r
    vec3 outgoingLight = diffuseColor.rgb;\r
  #endif\r
\r
  #ifdef COLOR_FROM_DEPTH\r
    float depth = 0.0;\r
    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r
      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r
      depth = gl_FragDepthEXT;\r
    #else\r
      depth = gl_FragCoord.z;\r
    #endif\r
    fragColor = packDepthToRGBA(depth);\r
    return;\r
  #endif\r
\r
  #ifdef COLOR_FROM_POS\r
    fragColor = world2colorMatrix * pixelPosWorld;\r
  #else\r
    #ifdef OVERRIDE_COLOR\r
      fragColor = vec4(fixedColor, diffuseColor.a);\r
    #else\r
      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r
    #endif\r
\r
    #ifdef USE_FOG\r
      float viewDistance;\r
      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r
        viewDistance = abs(pixelPosEye.z);\r
      #else\r
        viewDistance = vViewPosition.z;\r
      #endif\r
      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r
      #ifdef FOG_TRANSPARENT\r
        fragColor.a = fragColor.a * (1.0 - fogFactor);\r
      #else\r
        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r
      #endif\r
    #endif\r
\r
  #endif\r
}\r
`,ly={precision:"mediump",init(r){this.precision=r.capabilities.getMaxPrecision("highp")}},cy=4,hy=4,d3=new Uint8Array([24,52,0,255,254,145,0,255,122,0,0,255,7,170,0,255,34,214,0,255,173,8,0,255,86,249,0,255,160,4,0,255,226,46,0,255,224,211,0,255,3,157,0,255,174,247,0,255,12,182,0,255,220,216,0,255,1,109,0,255,253,154,0,255]),f3=x.RepeatWrapping,p3=x.RepeatWrapping,m3=x.NearestFilter,g3=x.NearestFilter,_3=x.UVMapping,uy=new x.DataTexture(d3,cy,hy,x.RGBAFormat,x.UnsignedByteType,_3,f3,p3,g3,m3,1);uy.needsUpdate=!0;const to={noiseWidth:cy,noiseHeight:hy,noiseTexture:uy},y3=[new x.Vector2(-.541978,.840393),new x.Vector2(.125533,-.992089),new x.Vector2(.374329,.927296),new x.Vector2(-.105475,.994422)],x3=x.UniformsUtils.merge([x.UniformsLib.fog,x.UniformsLib.lights,{diffuse:{value:new x.Color(15658734)},opacity:{value:1},specular:{type:"c",value:new x.Color(1118481)},shininess:{type:"f",value:30},fixedColor:{type:"c",value:new x.Color(16777215)},zOffset:{type:"f",value:0},zClipValue:{type:"f",value:0},clipPlaneValue:{type:"f",value:0},nearPlaneValue:{type:"f",value:-.5},invModelViewMatrix:{type:"4fv",value:new x.Matrix4},world2colorMatrix:{type:"4fv",value:new x.Matrix4},dashedLineSize:{type:"f",value:.1},dashedLinePeriod:{type:"f",value:.2},projMatrixInv:{type:"4fv",value:new x.Matrix4},viewport:{type:"v2",value:new x.Vector2},lineWidth:{type:"f",value:2},fogAlpha:{type:"f",value:1},samplesKernel:{type:"v2v",value:null},noiseTex:{type:"t",value:null},noiseTexelSize:{type:"v2",value:null},srcTexelSize:{type:"v2",value:null}}]),v3=["shininess","opacity","zOffset","diffuse","specular","fixedColor","zClipCoef","zClipValue","clipPlaneValue","world2colorMatrix","dashedLineSize","dashedLinePeriod","projMatrixInv","viewport","lineWidth","fogAlpha","samplesKernel","noiseTex","noiseTexelSize","srcTexelSize"],S3={diffuse:new x.Color(16777215),specular:new x.Color(1118481),shininess:30,opacity:1,fixedColor:new x.Color(16777215),zOffset:0,zClipCoef:2,zClipValue:0,clipPlaneValue:0,world2colorMatrix:new x.Matrix4,dashedLineSize:.1,dashedLinePeriod:.3,projMatrixInv:new x.Matrix4,viewport:new x.Vector2(800,600),lineWidth:2,fogAlpha:1,samplesKernel:y3,noiseTex:to.noiseTexture,noiseTexelSize:new x.Vector2(1/to.noiseWidth,1/to.noiseHeight),srcTexelSize:new x.Vector2(1/800,1/600),copy(r){this.diffuse.copy(r.diffuse),this.specular.copy(r.specular),this.shininess=r.shininess,this.opacity=r.opacity,this.fixedColor.copy(r.fixedColor),this.zOffset=r.zOffset,this.zClipCoef=r.zClipCoef,this.zClipValue=r.zClipValue,this.clipPlaneValue=r.clipPlaneValue,this.world2colorMatrix.copy(r.world2colorMatrix),this.dashedLineSize=r.dashedLineSize,this.dashedLinePeriod=r.dashedLinePeriod,this.projMatrixInv=r.projMatrixInv,this.viewport=r.viewport,this.lineWidth=r.lineWidth,this.toonShading=r.toonShading,this.fogAlpha=r.fogAlpha,this.samplesKernel=r.samplesKernel,this.noiseTex=r.noiseTex,this.noiseTexelSize=r.noiseTexelSize,this.srcTexelSize=r.srcTexelSize}};class ya extends x.RawShaderMaterial{constructor(e){super(e),this.fog=!0,this.instancedPos=!1,this.instancedMatrix=!1,this.attrColor=!1,this.attrColor2=!1,this.attrAlphaColor=!1,this.overrideColor=!1,this.sphereSprite=!1,this.cylinderSprite=!1,this.zClip=!1,this.clipPlane=!1,this.fakeOpacity=!1,this.prepassTransparancy=!1,this.colorFromPos=!1,this.shadowmap=!1,this.shadowmapType="random",this.colorFromDepth=!1,this.orthoCam=!1,this.dashedLine=!1,this.transparent=!0,this.thickLine=!1,this.fogTransparent=!1,this.normalsToGBuffer=!1,this.toonShading=!1,this.uberOptions=Object.create(ya.prototype.uberOptions),super.setValues({uniforms:x.UniformsUtils.clone(x3),vertexShader:this.precisionString()+h3,fragmentShader:this.precisionString()+u3,lights:!0,fog:!0,side:x.DoubleSide}),this.setValues(e)}precisionString(){const{precision:e}=ly;return`precision ${e} float;
precision ${e} int;

`}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=x.UniformsUtils.clone(e.uniforms),this.defines={...e.defines},this.extensions=e.extensions,this.fog=e.fog,this.instancedPos=e.instancedPos,this.instancedMatrix=e.instancedMatrix,this.attrColor=e.attrColor,this.attrColor2=e.attrColor2,this.attrAlphaColor=e.attrAlphaColor,this.overrideColor=e.overrideColor,this.sphereSprite=e.sphereSprite,this.cylinderSprite=e.cylinderSprite,this.zClip=e.zClip,this.clipPlane=e.clipPlane,this.fakeOpacity=e.fakeOpacity,this.colorFromPos=e.colorFromPos,this.shadowmap=e.shadowmap,this.shadowmapType=e.shadowmapType,this.colorFromDepth=e.colorFromDepth,this.orthoCam=e.orthoCam,this.prepassTransparancy=e.prepassTransparancy,this.dashedLine=e.dashedLine,this.thickLine=e.thickLine,this.fogTransparent=e.fogTransparent,this.normalsToGBuffer=e.normalsToGBuffer,this.toonShading=e.toonShading,this.uberOptions.copy(e.uberOptions),this}createInstance(){const e=new ya;return e.copy(this),e.uberOptions=Object.create(this.uberOptions),e}setValues(e){if(typeof e>"u")return;super.setValues(e);const t={},n={};this.fog&&(t.USE_FOG=1),this.instancedPos&&(t.INSTANCED_POS=1),this.instancedMatrix&&(t.INSTANCED_MATRIX=1),this.attrColor&&(t.ATTR_COLOR=1),this.attrColor2&&(t.ATTR_COLOR2=1),this.attrAlphaColor&&(t.ATTR_ALPHA_COLOR=1),this.overrideColor&&(t.OVERRIDE_COLOR=1),this.sphereSprite&&(t.SPHERE_SPRITE=1,n.fragDepth=!0),this.cylinderSprite&&(t.CYLINDER_SPRITE=1,n.fragDepth=!0),this.zClip&&(t.ZCLIP=1),this.clipPlane&&(t.CLIP_PLANE=1),this.fakeOpacity&&(t.FAKE_OPACITY=1),this.lights&&(t.USE_LIGHTS=1),this.colorFromPos&&(t.COLOR_FROM_POS=1),this.shadowmap&&(t.SHADOWMAP=1,this.shadowmapType==="pcf"?t.SHADOWMAP_PCF_SHARP=1:this.shadowmapType==="random"?t.SHADOWMAP_PCF_RAND=1:t.SHADOWMAP_BASIC=1),this.colorFromDepth&&(t.COLOR_FROM_DEPTH=1),this.orthoCam&&(t.ORTHOGRAPHIC_CAMERA=1),this.prepassTransparancy&&(t.PREPASS_TRANSP=1),this.dashedLine&&(t.DASHED_LINE=1),this.thickLine&&(t.THICK_LINE=1),this.fogTransparent&&(t.FOG_TRANSPARENT=1),this.normalsToGBuffer&&(n.drawBuffers=!0,t.NORMALS_TO_G_BUFFER=1),this.toonShading&&(t.TOON_SHADING=1),this.defines=t,this.extensions=n}setUberOptions(e){if(!(typeof e>"u"))for(const t in e)e.hasOwnProperty(t)&&(this.uberOptions[t]instanceof x.Color?this.uberOptions[t]=e[t].clone():this.uberOptions[t]=e[t])}clone(e){return e?this.createInstance():super.clone()}updateUniforms(){const e=this;v3.forEach(t=>{e.uniforms.hasOwnProperty(t)&&(e.uberOptions[t]instanceof x.Color||e.uberOptions[t]instanceof x.Matrix4?e.uniforms[t].value=e.uberOptions[t].clone():e.uniforms[t].value=e.uberOptions[t])})}}ya.prototype.uberOptions=S3;const xi=ya;function tr(r){class e extends r{constructor(){super(...arguments),this.onBeforeRender=e.prototype.onBeforeRender}onBeforeRender(n,i,s,o,a,l){this._onBeforeRender(n,i,s,o,a,l),this._update()}_onBeforeRender(){}_update(){const{material:n}=this;n&&n instanceof xi&&n.updateUniforms()}}return e}const Lg=tr(x.Mesh);class b3 extends Lg{constructor(){super(...arguments),this.castShadow=!0,this.receiveShadow=!0}_onBeforeRender(e,t,n,i,s,o){Lg.prototype._onBeforeRender.call(this,e,t,n);const{material:a}=this;a&&a.uniforms.invModelViewMatrix&&(this.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse,this.matrixWorld),a.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert(),a.uniforms.nearPlaneValue.value=n.near,a.uniformsNeedUpdate=!0)}}const dy=b3,Ng=tr(x.Mesh);class Zo extends Ng{constructor(e,t){super(e,t),this.castShadow=!0,this.receiveShadow=!0}static _mvLength=new x.Vector3;static _center=new x.Vector3;static _modelView=new x.Matrix4;_onBeforeRender(e,t,n){Ng.prototype._onBeforeRender.call(this,e,t,n);const i=this.geometry,{material:s}=this;if(!i.zClip||!s.uberOptions)return;const o=.5,a=Zo._modelView,l=Zo._mvLength,c=Zo._center;a.multiplyMatrices(this.matrixWorld,n.matrixWorldInverse);const h=l.setFromMatrixColumn(a,0).length();c.copy(i.boundingSphere.center),this.localToWorld(c),s.uberOptions.zClipValue=n.position.z-c.z-h*(o*i.boundingSphere.radius)}}const w3=Zo;class M3 extends x.Group{constructor(e,t){super(),this.geometry=e;const n=this;n.initialized=!1,this.geometry.addEventListener("update",()=>{n.update()})}init(){const{children:e}=this;for(let i=e.length-1;i>=0;--i)this.remove(e[i]);const{items:t,userData:n}=this.geometry;for(let i=0,s=t.length;i<s;++i){const o=t[i];if(!o)continue;const a=be.shallowCloneNode(o),l=new Ff(a);l.userData=de.default.clone(n);const c=l.getElement();c.style.visibility="visible",l.source=o,this.add(l)}this.initialized=!0}update(){if(!this.geometry.needsUpdate)return;const{children:t}=this;this.initialized||this.init();for(let n=0,i=t.length;n<i;++n){const s=t[n],o=s.source;s.position.copy(o.worldPos),s.userData.color=o.opts.color,s.userData.background=o.opts.background}}}const A3=M3,E3=tr(x.Mesh);class T3 extends E3{constructor(e,t){super(e,t),this.castShadow=!0,this.receiveShadow=!0}}const C3=T3,R3=tr(x.Mesh),Su=new x.Vector2;class P3 extends R3{_onBeforeRender(e,t,n,i,s,o){const{material:a}=this;a.uberOptions&&(a.uberOptions.projMatrixInv.copy(n.projectionMatrix).invert(),e.getSize(Su),a.uberOptions.viewport.set(Su.width,Su.height))}}const fy=P3,I3=tr(x.Mesh);class L3 extends I3{constructor(){super(...arguments),this.castShadow=!0,this.receiveShadow=!0}}const N3=L3,kn={ZClipped:w3,ZSprite:dy,Text:A3,Line:tr(x.Line),LineSegments:tr(x.LineSegments),Mesh:C3,ThickLineMesh:fy,Instanced:N3};function za(r,e){return function(t){t.setValues(r),t.setUberOptions(e)}}function Og(r,e){function t(n,i){return new ai.Instanced2CCylindersGeometry(n,i,r,e)}return{Geometry:t,Object:r?kn.ZSprite:kn.Instanced,initMaterial:za({instancedMatrix:!0,attrColor:!0,attrColor2:!0,attrAlphaColor:!0,cylinderSprite:r})}}function bu(r,e){const t=r.prototype instanceof ty,n=e.lineWidth||0;return{Geometry:r,Object:t?kn.ThickLineMesh:kn.LineSegments,initMaterial:za({lights:!1,attrColor:!0,attrAlphaColor:!0,thickLine:t},{lineWidth:n})}}function O3(r){return{Geometry:r,Object:kn.Mesh,initMaterial:za({attrColor:!0,attrAlphaColor:!0})}}function wu(r,e,t,n){const i={wireframe:!!n.wireframe,fakeOpacity:t.now.isoSurfaceFakeOpacity,zClip:n.zClip};return{Geometry:r,Object:kn.ZClipped,initMaterial:za({attrColor:!0,attrAlphaColor:!1,wireframe:i.wireframe,fakeOpacity:i.fakeOpacity,zClip:i.zClip})}}class D3{static createSpheres(e,t){const n=t.now.zSprites;function i(s,o){return new ai.InstancedSpheresGeometry(s,o,n)}return{Geometry:i,Object:n?kn.ZSprite:kn.Instanced,initMaterial:za({instancedPos:!0,attrColor:!0,attrAlphaColor:!0,sphereSprite:n})}}static create2CClosedCylinders(e,t){return Og(!1,!1)}static create2CCylinders(e,t){return Og(t.now.zSprites,!0)}static create2CLines(e,t,n){return bu(ai.TwoColorLinesGeometry,n)}static createCrosses(e,t,n){return bu(ai.CrossGeometry,n)}static createExtrudedChains(e,t){return O3(ai.ExtrudedObjectsGeometry)}static createChunkedLines(e,t,n){return bu(ai.ChunkedLinesGeometry,n)}static createQuickSurface(e,t,n){return wu(ai.QuickSurfGeometry,e,t,n)}static createContactSurface(e,t,n){return wu(ai.ContactSurfaceGeometry,e,t,n)}static createSASSES(e,t,n){return wu(ai.SSIsosurfaceGeometry,e,t,n)}static createLabels(e,t){return{Geometry:ai.LabelsGeometry,Object:kn.Text,initMaterial(){}}}}const fn=D3;class Mc extends x.Object3D{static _inverseMatrix=new x.Matrix4;static _ray=new x.Ray;constructor(e,t,n,i){super(),this._geometry=e,this._geoParams=t;const s=n.createInstance();t.initMaterial(s),this._material=s,this._transforms=i.length>0?i:[new x.Matrix4];const o=this._createMeshes(e);for(let a=0,l=o.length;a<l;++a)this.add(o[a])}raycast(e,t){const n=Mc._ray,i=Mc._inverseMatrix,{children:s}=this;n.copy(e.ray);for(let o=0,a=s.length;o<a;++o){const l=s[o];if(!Je.belongToSelectLayers(l))continue;l.updateMatrixWorld();const c=l.matrixWorld;i.copy(c).invert(),e.ray.copy(n).applyMatrix4(i);const h=[];this._geometry.raycast(e,h);for(let u=0,d=h.length;u<d;++u){const f=h[u];f.point&&(f.point.applyMatrix4(c),f.distance=n.origin.distanceTo(f.point)),f.object=l,t[t.length]=f}}e.ray.copy(n)}getSubset(e){const t=this._geometry.getSubset(e),n=[];let i=0;for(let s=0,o=t.length;s<o;++s){const a=this._createMeshes(t[s]);for(let l=0,c=a.length;l<c;++l)n[i++]=a[l]}return n}_createMeshes(e){const t=this._transforms,n=this._geoParams.Object,i=this._material,s=[];for(let o=0,a=t.length;o<a;++o){const l=new n(e,i);l.applyMatrix4(t[o]),s[o]=l}return s}}const U3=Mc;function F3(r,e){const t=[r].concat(e);return r.bind(...t)}class Wf extends or{constructor(e,t,n,i,s,o,a){if(super(),this.constructor===Wf)throw new Error("Can not instantiate abstract class!");this._selection=t,this._mode=i,this._colorer=n,this._chunksIdc=t.chunks,this._polyComplexity=o,this._geo=new(F3(e.Geometry,this._makeGeoArgs())),this._mesh=new U3(this._geo,e,a,s),this.add(this._mesh),this._build()}_makeGeoArgs(){throw new Error("ChemGroup subclass must override _makeGeoArgs() method")}getSubset(e,t){t=t!==void 0?t:!1;const n=this._calcChunksList(e,t);return n.length===0?[]:this._mesh.getSubset(n)}_changeSubsetOpacity(e,t,n){const i=this._calcChunksList(e,n);i.length!==0&&this._geo.setOpacity(i,t)}enableSubset(e,t){t=t!==void 0?t:!0,this._changeSubsetOpacity(e,1,t)}disableSubset(e,t){t=t!==void 0?t:!0,this._changeSubsetOpacity(e,0,t)}}const Qc=Wf;class z3 extends Qc{raycast(e,t){const{atoms:n}=this._selection,i=[];this._mesh.raycast(e,i);const s=this._chunksIdc;for(let o=0,a=i.length;o<a;++o){if(!i[o].hasOwnProperty("chunkIdx"))continue;const l=s[i[o].chunkIdx];l<n.length&&(i[o].atom=n[l],t.push(i[o]))}}_calcChunksList(e){const t=[],{atoms:n}=this._selection,i=this._chunksIdc;for(let s=0,o=i.length;s<o;++s)(n[i[s]].mask&e)!==0&&t.push(s);return t}}const Xf=z3;class V3 extends Xf{_makeGeoArgs(){return[this._selection.chunks.length,this._polyComplexity]}_build(){const e=this._selection.chunks,{atoms:t,parent:n}=this._selection,i=this._mode,s=this._colorer,o=this._geo;for(let a=0,l=e.length;a<l;++a){const c=t[e[a]];o.setItem(a,c.position,i.calcAtomRadius(c)),o.setColor(a,s.getAtomColor(c,n))}o.finalize()}updateToFrame(e){const t=this._selection.chunks,{atoms:n}=this._selection,i=this._mode,s=this._colorer,o=e.needsColorUpdate(s),a=this._geo;for(let l=0,c=t.length;l<c;++l){const h=n[t[l]];a.setItem(l,e.getAtomPos(t[l]),i.calcAtomRadius(h)),o&&a.setColor(l,e.getAtomColor(s,h))}a.finalize()}}const jf=V3;class B3 extends jf{_makeGeoArgs(){const e=[],{atoms:t,chunks:n}=this._selection,i=n.length;for(let o=0;o<i;++o)e[o]=t[n[o]];const s=this._mode.getSurfaceOpts();return s.atoms=e,[i,s]}}const k3=B3;class G3 extends jf{_makeGeoArgs(){const e=[],{atoms:t,chunks:n}=this._selection,i=n.length;for(let o=0;o<i;++o)e[o]=t[n[o]];const s=this._mode.getSurfaceOpts();return s.atoms=e,s.selection=this._selection,s.colorMode=this._colorer,[i,s]}}const H3=G3;function W3(r){let e=r>>16&255,t=r>>8&255,n=r&255;return .2126*e+.7152*t+.0722*n>127?(e=e*3/10,t=t*3/10,n=n*3/10):(e=255-(255-e)*3/10,t=255-(255-t)*3/10,n=255-(255-n)*3/10),e<<16|t<<8|n}function X3(r){const e=r>>16&255,t=r>>8&255,n=r&255;return 255-e<<16|255-t<<8|255-n}function Dg(r){return r.name.getNode()!==null?r.name.getNode():r.getVisualName()}const Ug={none(r){return r},adjust:W3,inverse:X3};function Ql(r,e){let t;if(Ug.hasOwnProperty(e))t=be.hexColor(Ug[e](r));else{const n=parseInt(e,16);!Number.isNaN(n)&&e.toLowerCase().startsWith("0x")?t=be.hexColor(n):t="#000000"}return t}const Fg={serial(r){return r.serial},name(r){return r.getVisualName()},elem(r){return r.element.name},residue(r){return r.residue.getType().getName()},sequence(r){return r.residue.getSequence()},chain(r){return r.residue.getChain().getName()},hetatm(r){return r.isHet()},water(r){return r.residue.getType().getName()==="HOH"||r.residue.getType().getName()==="WAT"}},zg=function(r,e){return e.replace(/\{\{(\s*\w+\s*)\}\}/g,t=>{let n=t.replace(/\s+/g,"");return n=n.substring(2,n.length-2).toLowerCase(),Fg.hasOwnProperty(n)?Fg[n](r):"null"})};class j3 extends Xf{_makeGeoArgs(){const e=this._mode.getLabelOpts();return[this._selection.chunks.length,e]}_build(){const e=this._mode.getLabelOpts(),t=this._selection.chunks,{atoms:n,parent:i}=this._selection,s=this._colorer,o=this._geo;for(let a=0,l=t.length;a<l;++a){const c=n[t[a]],h=e.template?zg(c,e.template):Dg(c);if(!h)continue;const u=s.getAtomColor(c,i),d=parseInt(Ql(u,e.fg).substring(1),16),f=e.showBg?parseInt(Ql(u,e.bg).substring(1),16):"transparent";o.setItem(a,c.position,h),o.setColor(a,d,f)}o.finalize()}updateToFrame(e){const t=this._mode.getLabelOpts(),n=this._selection.chunks,{atoms:i}=this._selection,s=this._colorer,o=this._geo,a=e.needsColorUpdate(s);for(let l=0,c=n.length;l<c;++l){const h=i[n[l]],u=t.template?zg(h,t.template):Dg(h);if(!u)continue;const d=e.getAtomColor(s,h),f=parseInt(Ql(d,t.fg).substring(1),16),p=t.showBg?parseInt(Ql(d,t.bg).substring(1),16):"transparent";o.setItem(l,e.getAtomPos(n[l]),u),a&&o.setColor(l,f,p)}o.finalize()}}const Y3=j3;function Vg(r,e,t,n){const i=Math.sin(r);return e.clone().multiplyScalar(Math.sin((1-n)*r)/i).addScaledVector(t,Math.sin(n*r)/i)}class q3 extends Xf{_buildInner(e,t){const n=this._selection.chunks,i=new x.Vector3,s=new x.Vector3,o=this._segmentsHeight,a=1/o,l=this._colorer,{cycles:c,parent:h}=this._selection;let u=0,d=n[u];for(let f=0,p=c.length;f<p;++f){const _=c[f],g=_.atoms,m=[],v=[],{center:y}=_,S=_.radius-e,b=g.length;let M=0;const E=g[b-1].position;let T=g[M].position;i.subVectors(E,y),s.subVectors(T,y);const w=s.clone().cross(i).normalize();for(;M<b;++M){const A=i.angleTo(s);v[M]=Vg(A,i,s,.5).normalize(),T=g[(M+1)%b].position,i.copy(s),s.subVectors(T,y)}for(M=0;M<b;++M){if(g[M].index!==d)continue;const A=v[M],D=v[(M+1)%b],k=l.getAtomColor(g[M],h),G=A.angleTo(D);for(let P=0;P<=o;++P)m[P]=Vg(G,A,D,P*a).multiplyScalar(S).add(y);t(u++,k,m,y,w),d=n[u]}}}}const py=q3;function $3(r,e){const t=[];for(let n=0;n<e;++n){const i=-2*n/e*Math.PI;t.push(new x.Vector3(Math.cos(i)*r,Math.sin(i)*r,0))}return t}const{calcChunkMatrix:Z3}=Je;class K3 extends py{_build(){const e=this._segmentsHeight,t=this._mode.getAromRadius(),n=new x.Vector2(t,t),i=this._mode.calcStickRadius()+2*t,s=new x.Vector3,o=[],a=this._geo;this._buildInner(i,(l,c,h,u,d)=>{for(let f=0;f<=e;++f){const p=h[f],_=p.clone().sub(u).cross(d);s.addVectors(p,_),o[f]=Z3(p,s,d,n)}a.setItem(l,o),a.setColor(l,c)}),a.finalize()}_makeGeoArgs(){return this._segmentsHeight=this._polyComplexity,[$3(1,this._polyComplexity),this._segmentsHeight+1,this._selection.chunks.length]}}const J3=K3;class Q3 extends py{_build(){const e=this._geo,t=this._mode.getAromaticOffset();this._buildInner(t,(n,i,s)=>{let o=s[0];for(let a=1;a<=this._segmentsHeight;++a){const l=s[a];e.setSegment(n,a-1,o,l),o=l}e.setColor(n,i)}),e.finalize()}_makeGeoArgs(){return this._segmentsHeight=this._mode.getAromaticArcChunks(),[this._selection.chunks.length,this._segmentsHeight,!0]}}const eR=Q3;class tR extends Qc{raycast(e,t){const{residues:n}=this._selection,i=[];this._mesh.raycast(e,i);const s=this._chunksIdc;for(let o=0,a=i.length;o<a;++o){if(!i[o].hasOwnProperty("chunkIdx"))continue;const l=s[i[o].chunkIdx];l<n.length&&(i[o].residue=n[l],t.push(i[o]))}}_calcChunksList(e){const t=[],{residues:n}=this._selection,i=this._chunksIdc;for(let s=0,o=i.length;s<o;++s)(n[i[s]]._mask&e)!==0&&t.push(s);return t}}const my=tR;class nR extends my{raycast(e,t){const{residues:n}=this._selection,i=[];this._mesh.raycast(e,i);const s=this._chunksIdc;for(let o=0,a=i.length;o<a;++o){if(!i[o].hasOwnProperty("chunkIdx"))continue;const l=s[Math.floor(i[o].chunkIdx/2)];l<n.length&&(i[o].residue=n[l],t.push(i[o]))}}_build(){const{residues:e,parent:t}=this._selection,n=this._colorer,i=this._geo,s=this._mode.calcStickRadius();let o=0;const a=this._selection.chunks;for(let l=0,c=a.length;l<c;++l){const h=e[a[l]],u=n.getResidueColor(h,t);this._processItem(o++,h._cylinders[0],h._cylinders[1],s,u)}i.finalize()}_calcChunksList(e){const t=[];let n=0;const{residues:i}=this._selection,s=this._chunksIdc;for(let o=0,a=s.length;o<a;++o)(i[s[o]]._mask&e)!==0&&(t[n++]=2*o,t[n++]=2*o+1);return t}updateToFrame(e){const t=e.getResidues(),{parent:n}=this._selection,i=this._colorer,s=this._geo,o=this._mode.calcStickRadius();let a=0;const l=this._selection.chunks;for(let c=0,h=l.length;c<h;++c){const u=t[l[c]],d=i.getResidueColor(u,n);this._processItem(a++,u._cylinders[0],u._cylinders[1],o,d)}s.finishUpdate()}}const gy=nR;class iR extends gy{_makeGeoArgs(){return[this._selection.chunks.length,this._polyComplexity]}_processItem(e,t,n,i,s){const o=this._geo;o.setItem(e,t,n,i),o.setColor(e,s,s)}}const sR=iR;class rR extends gy{_makeGeoArgs(){return[this._selection.chunks.length*2,this._polyComplexity]}_processItem(e,t,n,i,s){const o=this._geo;let a=e*2;o.setItem(a,t,i),o.setColor(a,s),a++,o.setItem(a,n,i),o.setColor(a,s)}}const oR=rR;var Mu=xn(690);const{ResidueType:aR}=Bt,lR=Je.calcChunkMatrix;function Bg(r,e){const t=(0,Mu.Smooth)(r,{method:Mu.Smooth.METHOD_CUBIC,clip:Mu.Smooth.CLIP_CLAMP,cubicTension:e,scaleTo:1});return function(n,i){let s=i;s===null&&(s=function(l){return(l*(r.length-1-2)+1)/(r.length-1)});const o=s(n),a=t(o);return new x.Vector3(a[0],a[1],a[2])}}function Fo(r,e,t,n){if(!n._isValid){r[t]=r[t-1],e[t]=e[t-1];return}const i=n._controlPoint;r[t]=[i.x,i.y,i.z];const s=i.clone().add(n._wingVector);e[t]=[s.x,s.y,s.z]}function cR(r,e,t,n){const i=(n._type.flags&aR.Flags.NUCLEIC)!==0,s=i?"C5'":"N",o=i?"C3'":"C";let a,l;if(n.forEachAtom(c=>{const h=c.getVisualName();!a&&h===s?a=c.position:!l&&h===o&&(l=c.position)}),a&&l||(a=n._firstAtom.position,l=n._lastAtom.position),a&&l){const c=l.clone().sub(a),h=n._wingVector,u=n._controlPoint,d=u.clone().add(h),f=u.clone().sub(c),p=f.clone().add(h);r[t]=[f.x,f.y,f.z],e[t]=[p.x,p.y,p.z],++t,r[t]=[f.x,f.y,f.z],e[t]=[p.x,p.y,p.z],++t,r[t]=[u.x,u.y,u.z],e[t]=[d.x,d.y,d.z],++t;const _=u.clone().add(c),g=_.clone().add(h);r[t]=[_.x,_.y,_.z],e[t]=[g.x,g.y,g.z],++t,r[t]=[_.x,_.y,_.z],e[t]=[g.x,g.y,g.z]}}function hR(r,e,t,n){const i=n.start,s=n.end;function o(p){return p>i&&r[p-1]._isValid?p-1:p}function a(p){return p<s&&r[p+1]._isValid?p+1:p}const l=[],c=[];let h=0;function u(p,_){const g=r[p]._controlPoint.clone().lerp(r[_]._controlPoint,-.25),m=g.clone().add(r[p]._wingVector);c[h]=[g.x,g.y,g.z],l[h++]=[m.x,m.y,m.z],c[h]=[g.x,g.y,g.z],l[h++]=[m.x,m.y,m.z]}const d=o(e),f=a(t);if(d===f)return cR(c,l,h,r[e]),{centerPoints:c,topPoints:l};e===d?u(e,a(e)):(Fo(c,l,h++,r[o(d)]),Fo(c,l,h++,r[d]));for(let p=e;p<=t;++p)Fo(c,l,h++,r[p]);return f===a(f)?u(t,o(t)):(Fo(c,l,h++,r[f]),Fo(c,l,h,r[a(f)])),{centerPoints:c,topPoints:l}}class uR{constructor(e,t,n,i,s,o){const a=hR(e,t,n,o);this._topInterp=Bg(a.topPoints,s),this._centerInterp=Bg(a.centerPoints,s),this._shift=.5/(n-t+2),this._valueStep=(1-2*this._shift)/(2*(n-t+1)*(i-1)),this._segmentsCount=i}prepareMatrices(e,t,n){const i=this._segmentsCount,s=new Array(i),o=new x.Vector2(0,0),a=this._topInterp,l=this._centerInterp;let c=this._shift+this._valueStep*(i-1)*e;for(let h=0;h<i;++h){const u=Math.min(1,h/(i-1));o.lerpVectors(t,n,u);const d=a(c,null),f=l(c,null);c+=this._valueStep;const p=l(c,null);s[h]=lR(f.clone(),p.clone(),d.clone().sub(f),o)}return s}}const dR=uR;function fR(r,e){const t=[];for(let n=0;n<e;++n){const i=Math.PI/2-2*Math.PI*n/e;t.push(new x.Vector3(Math.cos(i)*r,Math.sin(i)*r,0))}return t}function kg(r,e,t,n,i,s){for(let o=0,a=r.length;o<a;++o){const l=r[o].arr,{boundaries:c}=r[o];for(let h=0,u=l.length;h<u;++h){const d=[l[h].start,l[h].end],f=new dR(e,d[0],d[1],t,n,c);let p=null;const _=l[h].start*2,g=l[h].end*2+1;let m=i.getResidueRadius(e[0],0);for(let v=_;v<=g;++v){const y=v/2|0,S=e[y],b=i.getResidueRadius(S,v%2),M=i.getResidueRadius(S,1+v%2),E=f.prepareMatrices(v-d[0]*2,b,M);E.unshift(p===null?E[0]:p);const T=b.x!==M.x||b.y!==M.y,w=b.x!==m.x||b.y!==m.y;s(S,E,T,w),p=E[t],m=M}}}}class pR extends my{_makeGeoArgs(){const e=this._mode.getHeightSegmentsRatio();return this._segmentsHeight=this._polyComplexity*e|0,[fR(1,this._polyComplexity),this._segmentsHeight+1,this._selection.chunks.length*2]}_build(){const{residues:e,parent:t}=this._selection,n=this._mode,i=this._colorer,s=n.getTension(),o=this._geo;let a=0;const l=[];kg(this._selection.subdivs,e,this._segmentsHeight,s,n,function(c,h){let u=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1,d=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1;const f=i.getResidueColor(c,t);l[a]=c._index,o.setItem(a,h,u,d),o.setColor(a++,f)}),this._chunksIdc=l,o.finalize()}updateToFrame(e){const{parent:t}=this._selection,n=this._mode,i=this._colorer,s=n.getTension(),o=this._geo,a=e.getResidues();let l=0;const c=e.needsColorUpdate(i);kg(this._selection.subdivs,a,this._segmentsHeight,s,n,(h,u)=>{o.setItem(l,u),c&&o.setColor(l,i.getResidueColor(h,t)),l++}),o.finalize()}}const mR=pR;class gR extends Qc{_makeGeoArgs(){const e=this._selection.subdivs;let t=0;for(let n=0,i=e.length;n<i;++n){const s=e[n].arr;for(let o=0,a=s.length;o<a;++o)t+=s[o].end-s[o].start}return[t,this._polyComplexity]}_build(){const{residues:e,parent:t}=this._selection,n=this._mode,i=this._colorer,s=this._geo;let o=0;const a=[],l=this._selection.subdivs,c=n.calcStickRadius();for(let h=0,u=l.length;h<u;++h){const d=l[h].arr;for(let f=0,p=d.length;f<p;++f){const _=d[f].start,g=d[f].end;let m=e[_];for(let v=_+1;v<=g;++v){const y=e[v];a[o]={first:m._index,second:y._index},s.setItem(o,m._controlPoint,y._controlPoint,c),s.setColor(o,i.getResidueColor(m,t),i.getResidueColor(y,t)),o++,m=y}}}this._chunksIdc=a,s.finalize()}updateToFrame(e){const t=e.getResidues(),{parent:n}=this._selection,i=this._mode,s=this._colorer,o=this._geo;let a=0;const l=this._selection.subdivs,c=i.calcStickRadius(),h=e.needsColorUpdate(s);for(let u=0,d=l.length;u<d;++u){const f=l[u].arr;for(let p=0,_=f.length;p<_;++p){const g=f[p].start,m=f[p].end;let v=t[g];for(let y=g+1;y<=m;++y){const S=t[y];o.setItem(a,v._controlPoint,S._controlPoint,c),h&&o.setColor(a,s.getResidueColor(v,n),s.getResidueColor(S,n)),a++,v=S}}}o.finalize()}raycast(e,t){const n=[],{residues:i}=this._selection;this._mesh.raycast(e,n);const s=this._chunksIdc;for(let o=0,a=n.length;o<a;++o){if(!n[o].hasOwnProperty("chunkIdx"))continue;const{chunkIdx:l}=n[o],c=s[Math.floor(l/2)],h=l%2===0?c.first:c.second;h<i.length&&(n[o].residue=i[h],t.push(n[o]))}}_calcChunksList(e){const t=[],n=this._chunksIdc,{residues:i}=this._selection;for(let s=0,o=n.length;s<o;++s){const a=n[s];i[a.first]._mask&e&&t.push(s*2),i[a.second]._mask&e&&t.push(s*2+1)}return t}}const _R=gR;function yR(r){return r<2?1:r}class xR extends Qc{_makeGeoArgs(){const e=this._mode.drawMultiorderBonds(),t=this._mode.showAromaticLoops(),n=this._selection.chunks,{bonds:i}=this._selection;let s=0;for(let o=0,a=n.length;o<a;++o)s+=this.getBondOrder(i[n[o]],e,t);return[s,this._polyComplexity]}getBondOrder(e,t,n){let i=1;return t&&(!n||e._type!==Ua.BondType.AROMATIC)&&(i=yR(e._order)),i}raycast(e,t){const{bonds:n}=this._selection,i=[];this._mesh.raycast(e,i);const s=this._chunksIdc;for(let o=0,a=i.length;o<a;++o){if(!i[o].hasOwnProperty("chunkIdx"))continue;const{chunkIdx:l}=i[o],c=s[Math.floor(l/2)];if(c<n.length){const h=n[c];i[o].atom=l%2===0?h._left:h._right,t.push(i[o])}}}_calcChunksList(e,t){const n=[],{bonds:i}=this._selection,s=this._chunksIdc;for(let o=0,a=s.length;o<a;++o){const l=i[s[o]];l._left.mask&e&&(!t||l._right.mask&e)&&n.push(2*o),l._right.mask&e&&(!t||l._left.mask&e)&&n.push(2*o+1)}return n}}const _y=xR;class vR extends _y{_build(){const e=this._selection.chunks,{bonds:t,parent:n}=this._selection,i=this._mode,s=this._colorer,o=this._geo,a=i.drawMultiorderBonds(),l=i.showAromaticLoops(),c=i.calcStickRadius(),h=i.calcSpaceFraction();let u;const d=new x.Vector3,f=new x.Vector3;let p=0;const _=[];for(let g=0,m=e.length;g<m;++g){const v=t[e[g]],y=v._left,S=v._right,b=y.position,M=S.position;u=v.calcNormalDir();const E=this.getBondOrder(v,a,l),w=2*Math.min(i.calcAtomRadius(y),i.calcAtomRadius(S))/E,A=a?Math.min(c,w*.5*(1-h)):c;for(let D=0;D<E;++D){const k=w*(E%2===0?((D/2|0)+.5)*(1-2*(D%2)):((D+1)/2|0)*(-1+2*(D%2)));_[p]=v._index,d.copy(b),d.addScaledVector(u,k),f.copy(M),f.addScaledVector(u,k),o.setItem(p,d,f,A),o.setColor(p++,s.getAtomColor(y,n),s.getAtomColor(S,n))}}o.finalize(),this._chunksIdc=_}updateToFrame(e){const t=this._selection.chunks,{bonds:n}=this._selection,i=this._mode,s=this._colorer,o=this._geo,a=i.drawMultiorderBonds(),l=i.showAromaticLoops(),c=i.calcStickRadius(),h=i.calcSpaceFraction();let u;const d=new x.Vector3,f=new x.Vector3;let p=0;const _=e.needsColorUpdate(s);for(let g=0,m=t.length;g<m;++g){const v=n[t[g]],y=v._left,S=v._right,b=e.getAtomPos(y.index).clone(),M=e.getAtomPos(S.index);u=v.calcNormalDir();const E=this.getBondOrder(v,a,l),w=2*Math.min(i.calcAtomRadius(y),i.calcAtomRadius(S))/E,A=a?Math.min(c,w*.5*(1-h)):c;for(let D=0;D<E;++D){const k=w*(E%2===0?((D/2|0)+.5)*(1-2*(D%2)):((D+1)/2|0)*(-1+2*(D%2)));d.copy(b),d.addScaledVector(u,k),f.copy(M),f.addScaledVector(u,k),o.setItem(p,d,f,A),_&&o.setColor(p,e.getAtomColor(s,y),e.getAtomColor(s,S)),p++}}o.finalize()}}const SR=vR,kr=.15;class bR extends _y{_build(){const e=this._selection.chunks,{bonds:t,parent:n}=this._selection,i=this._mode,s=this._colorer,o=this._geo,a=i.drawMultiorderBonds(),l=i.showAromaticLoops(),c=new x.Vector3,h=new x.Vector3,u=new x.Vector3;let d=0;const f=[];for(let p=0,_=e.length;p<_;++p){const g=t[e[p]],m=g._left,v=g._right,y=m.position,S=v.position,b=m.bonds.length===1,M=v.bonds.length===1;c.subVectors(S,y);const E=c.length(),T=g.calcNormalDir(),w=this.getBondOrder(g,a,l);for(let A=0;A<w;++A){h.copy(y),u.copy(S);let D=w%2===0?((A/2|0)+.5)*(1-2*(A%2)):((A+1)/2|0)*(-1+2*(A%2));f[d]=g._index,w===2&&!b&&!M&&(D-=.5,D*=-1),!b&&!M&&w>1&&D!==0&&(h.lerpVectors(y,S,kr/E),u.lerpVectors(y,S,1-kr/E)),D*=kr,h.addScaledVector(T,D),u.addScaledVector(T,D),o.setItem(d,h,u),o.setColor(d++,s.getAtomColor(m,n),s.getAtomColor(v,n))}}o.finalize(),this._chunksIdc=f}updateToFrame(e){const t=this._selection.chunks,{bonds:n}=this._selection,i=this._mode,s=this._colorer,o=this._geo,a=i.drawMultiorderBonds(),l=i.showAromaticLoops(),c=new x.Vector3,h=new x.Vector3,u=new x.Vector3;let d=0;const f=e.needsColorUpdate(s);for(let p=0,_=t.length;p<_;++p){const g=n[t[p]],m=g._left,v=g._right,y=e.getAtomPos(m.index).clone(),S=e.getAtomPos(v.index),b=m.bonds.length===1,M=v.bonds.length===1;c.subVectors(S,y);const E=c.length(),T=g.calcNormalDir(),w=this.getBondOrder(g,a,l);for(let A=0;A<w;++A){h.copy(y),u.copy(S);let D=w%2===0?((A/2|0)+.5)*(1-2*(A%2)):((A+1)/2|0)*(-1+2*(A%2));w===2&&!b&&!M&&(D-=.5,D*=-1),!b&&!M&&w>1&&D!==0&&(h.lerpVectors(y,S,kr/E),u.lerpVectors(y,S,1-kr/E)),D*=kr,h.addScaledVector(T,D),u.addScaledVector(T,D),o.setItem(d,h,u),f&&o.setColor(d,e.getAtomColor(s,m),e.getAtomColor(s,v)),d++}}o.finalize()}}const wR=bR,pn={AtomsSphereGroup:jf,AtomsSurfaceGroup:k3,AtomsSASSESGroupStub:H3,AtomsTextGroup:Y3,AromaticTorusGroup:J3,AromaticLinesGroup:eR,NucleicCylindersGroup:sR,NucleicSpheresGroup:oR,ResiduesSubseqGroup:mR,ResiduesTraceGroup:_R,BondsCylinderGroup:SR,BondsLinesGroup:wR};class MR extends or{constructor(e,t,n,i,s,o,a,l){super();const c=this;this._complex=n,this._mode=s;const h=n.getAtoms(),u=n.getTransforms();n.forEachComponent(d=>{const f=[];let p=0;if(d.forEachAtom(g=>{c._checkAtom(g,a)&&(f[p++]=g.index)}),p===0)return;const _=new e(t,{atoms:h,chunks:f,parent:n},i,s,u,o,l);_._component=d,c.add(_)})}_checkAtom(e,t){return e.mask&t}getSubset(e,t){const n=[],{children:i}=this;let s=0;for(let o=0,a=i.length;o<a;++o)if(i[o].getSubset){const l=i[o].getSubset(e,t);for(let c=0,h=l.length;c<h;++c){const u=l[c];u._component=i[o]._component,n[s++]=u}}return n}}const yy=MR;class AR extends yy{_checkAtom(e,t){if(!(e.mask&t))return!1;const{bonds:n}=e;for(let i=0,s=n.length;i<s;++i)if(n[i]._left.mask&t&&n[i]._right.mask&t)return!1;return!0}}const ER=AR;class TR extends or{constructor(e,t,n,i,s,o,a,l){super();const c=this;this._complex=n;const h=n.getResidues(),u=n.getTransforms();n.forEachComponent(d=>{let f=0;const p=[];if(d.forEachResidue(g=>{c._checkResidue(g,a)&&(p[f++]=g._index)}),f===0)return;const _=new e(t,{residues:h,chunks:p,parent:n},i,s,u,o,l);_._component=d,c.add(_)})}checkResidue(e,t){return e._mask&t}getSubset(e,t){const n=[],{children:i}=this;let s=0;for(let o=0,a=i.length;o<a;++o)if(i[o].getSubset){const l=i[o].getSubset(e,t);for(let c=0,h=l.length;c<h;++c){const u=l[c];u._component=i[o]._component,n[s++]=u}}return n}}const CR=TR;class RR extends CR{_checkResidue(e,t){return t&e._mask&&e._cylinders!==null}}const PR=RR;class IR extends or{constructor(e,t,n,i,s,o,a,l){super();const c=this;this._complex=n;const h=n.getResidues(),u=n.getTransforms();n.forEachComponent(d=>{const f=d.getMaskedSubdivSequences(a);let p=0;const _=[];for(let m=0,v=f.length;m<v;++m){const y=f[m].arr;for(let S=0,b=y.length;S<b;++S)for(let M=y[S].start,E=y[S].end;M<=E;++M)_[p++]=h[M]._index}if(p===0)return;const g=new e(t,{residues:h,chunks:_,subdivs:f,parent:n},i,s,u,o,l);g._component=d,c.add(g)})}getSubset(e,t){const n=[],{children:i}=this;let s=0;for(let o=0,a=i.length;o<a;++o)if(i[o].getSubset){const l=i[o].getSubset(e,t);for(let c=0,h=l.length;c<h;++c){const u=l[c];u._component=i[o]._component,n[s++]=u}}return n}}const LR=IR;class NR extends or{constructor(e,t,n,i,s,o,a,l){super();const c=this;this._complex=n;const h=n.getBonds(),u=n.getTransforms();n.forEachComponent(d=>{const f=[];let p=0;if(d.forEachBond(g=>{const m=g._left,v=g._right;!(m.mask&a)||!(v.mask&a)||(f[p++]=g._index)}),p===0)return;const _=new e(t,{bonds:h,chunks:f,parent:n},i,s,u,o,l);_._component=d,c.add(_)})}getSubset(e,t){const n=[],{children:i}=this;let s=0;for(let o=0,a=i.length;o<a;++o)if(i[o].getSubset){const l=i[o].getSubset(e,t);for(let c=0,h=l.length;c<h;++c){const u=l[c];u._component=i[o]._component,n[s++]=u}}return n}}const OR=NR;class DR extends or{constructor(e,t,n,i,s,o,a,l){super();const c=this;this._complex=n;const h=n.getAtoms(),u=n.getTransforms();s.showAromaticLoops()&&n.forEachComponent(d=>{const f=[];let p=0;const _=[];let g=0;d.forEachCycle(v=>{const y=v.atoms;let S=0;for(let b=0,M=y.length;b<M;++b)(y[b].mask&a)!==0&&(++S,f[p++]=y[b].index);S>0&&(_[g++]=v)});const m=new e(t,{cycles:_,atoms:h,chunks:f,parent:n},i,s,u,o,l);m._component=d,c.add(m)})}getSubset(e,t){const n=[],{children:i}=this;let s=0;for(let o=0,a=i.length;o<a;++o)if(i[o].getSubset){const l=i[o].getSubset(e,t);for(let c=0,h=l.length;c<h;++c){const u=l[c];u._component=i[o]._component,n[s++]=u}}return n}}const UR=DR,mn={Atoms:yy,OrphanAtoms:ER,Nucleic:PR,Subseqs:LR,Bonds:OR,Aromatic:UR};function gn(r,e,t){return function(n,i,s,o,a,l){return new e(t,r,n,i,s,o,a,l)}}class FR{static AtomsSpheres(e,t){const n=fn.createSpheres(e,t);return gn(n,mn.Atoms,pn.AtomsSphereGroup)}static OrphanedAtomsCrosses(e,t,n){const i=fn.createCrosses(e,t,n);return gn(i,mn.OrphanAtoms,pn.AtomsSphereGroup)}static BondsCylinders(e,t){const n=fn.create2CCylinders(e,t);return gn(n,mn.Bonds,pn.BondsCylinderGroup)}static BondsLines(e,t,n){const i=fn.create2CLines(e,t,n);return gn(i,mn.Bonds,pn.BondsLinesGroup)}static CartoonChains(e,t){const n=fn.createExtrudedChains(e,t);return gn(n,mn.Subseqs,pn.ResiduesSubseqGroup)}static TraceChains(e,t){const n=fn.create2CClosedCylinders(e,t);return gn(n,mn.Subseqs,pn.ResiduesTraceGroup)}static NucleicSpheres(e,t){const n=fn.createSpheres(e,t);return gn(n,mn.Nucleic,pn.NucleicSpheresGroup)}static NucleicCylinders(e,t){const n=fn.create2CCylinders(e,t);return gn(n,mn.Nucleic,pn.NucleicCylindersGroup)}static ALoopsTorus(e,t){const n=fn.createExtrudedChains(e,t);return gn(n,mn.Aromatic,pn.AromaticTorusGroup)}static ALoopsLines(e,t,n){const i=fn.createChunkedLines(e,t,n);return gn(i,mn.Aromatic,pn.AromaticLinesGroup)}static QuickSurfGeo(e,t,n){const i=fn.createQuickSurface(e,t,n);return gn(i,mn.Atoms,pn.AtomsSurfaceGroup)}static ContactSurfaceGeo(e,t,n){const i=fn.createContactSurface(e,t,n);return gn(i,mn.Atoms,pn.AtomsSurfaceGroup)}static SASSESSurfaceGeo(e,t,n){const i=fn.createSASSES(e,t,n);return gn(i,mn.Atoms,pn.AtomsSASSESGroupStub)}static TextLabelsGeo(e,t){const n=fn.createLabels(e,t);return gn(n,mn.Atoms,pn.AtomsTextGroup)}}const zR=FR;class yo{constructor(e){if(this.constructor===yo)throw new Error("Can not instantiate abstract class!");this.opts=de.default.merge(be.deriveDeep(this.settings.now.modes[this.id],!0),e)}identify(){const e=be.objectsDiff(this.opts,this.settings.now.modes[this.id]);return de.default.isEmpty(e)?this.id:[this.id,e]}buildGeometry(e,t,n,i){const s=this.opts.polyComplexity?this.opts.polyComplexity[this.settings.now.resolution]:0,o=this.depGroups,a=o.length,l=new Je.RCGroup,c=this;for(let h=0;h<a;++h){let u=o[h],d={};de.default.isArray(u)&&(d=u[1].call(this),[u]=u);const f=zR[u](null,this.settings,d),p=new f(e,t,c,s,n,i);p.children.length>0&&l.add(p)}return l}}Fa(yo.prototype);yo.prototype.id="__";yo.prototype.depGroups=[];const ti=yo;function VR(){return{lineWidth:this.opts.lineWidth}}class Va extends ti{static id="LN";constructor(e){super(e),this.depGroups=this.depGroups.slice(0);const t=this.depGroups;for(let n=0,i=t.length;n<i;++n)t[n]=[t[n],VR]}drawMultiorderBonds(){return this.opts.multibond}calcAtomRadius(){return this.opts.atom}getAromaticOffset(){return this.opts.offsarom}getAromaticArcChunks(){return this.opts.chunkarom}showAromaticLoops(){return this.opts.showarom}}Va.prototype.id="LN";Va.prototype.name="Lines";Va.prototype.shortName="Lines";Va.prototype.depGroups=["ALoopsLines","BondsLines","OrphanedAtomsCrosses"];const BR=Va;class Ba extends ti{static id="LC";calcAtomRadius(e){return this.opts.bond}calcStickRadius(){return this.opts.bond}calcSpaceFraction(){return this.opts.space}getAromRadius(){return this.opts.aromrad}showAromaticLoops(){return this.opts.showarom}drawMultiorderBonds(){return this.opts.multibond}}Ba.prototype.id="LC";Ba.prototype.name="Licorice";Ba.prototype.shortName="Licorice";Ba.prototype.depGroups=["AtomsSpheres","BondsCylinders","ALoopsTorus"];const kR=Ba;class ka extends ti{static id="BS";calcAtomRadius(e){return e.element.radius*this.opts.atom}calcStickRadius(){return this.opts.bond}getAromRadius(){return this.opts.aromrad}showAromaticLoops(){return this.opts.showarom}calcSpaceFraction(){return this.opts.space}drawMultiorderBonds(){return this.opts.multibond}}ka.prototype.id="BS";ka.prototype.name="Balls and Sticks";ka.prototype.shortName="Balls";ka.prototype.depGroups=["AtomsSpheres","BondsCylinders","ALoopsTorus"];const GR=ka;class Ga extends ti{static id="VW";calcAtomRadius(e){return e.element.radius}}Ga.prototype.id="VW";Ga.prototype.name="Van der Waals";Ga.prototype.shortName="VDW";Ga.prototype.depGroups=["AtomsSpheres"];const HR=Ga;class Ha extends ti{static id="TR";calcStickRadius(){return this.opts.radius}}Ha.prototype.id="TR";Ha.prototype.name="Trace";Ha.prototype.shortName="Trace";Ha.prototype.depGroups=["TraceChains"];const WR=Ha;class Wa extends ti{static id="TU";getResidueRadius(e){return this.TUBE_RADIUS}getHeightSegmentsRatio(){return this.opts.heightSegmentsRatio}getTension(){return this.opts.tension}buildGeometry(e,t,n,i){const s=this.opts.radius;return this.TUBE_RADIUS=new x.Vector2(s,s),ti.prototype.buildGeometry.call(this,e,t,n,i)}}Wa.prototype.id="TU";Wa.prototype.name="Tube";Wa.prototype.shortName="Tube";Wa.prototype.depGroups=["CartoonChains"];const XR=Wa;class Xa extends ti{static id="CA";constructor(e){super(e),this.secCache={}}getResidueStartRadius(e){const t=e.getSecondary();if(!t||!t.generic)return this.TUBE_RADIUS;const n=this.secCache[t.generic];return n?t.term===e?n.start:n.center:this.TUBE_RADIUS}getResidueEndRadius(e){const t=e.getSecondary();if(t===null||!t.generic)return this.TUBE_RADIUS;const n=this.secCache[t.generic];return n?t.term===e?this.ARROW_END:n.center:this.TUBE_RADIUS}getResidueRadius(e,t){const n=this.getResidueStartRadius(e);if(t===0)return n;const i=this.getResidueEndRadius(e);return t===2?i:n.clone().lerp(i,t/2)}calcStickRadius(e){return this.opts.radius}getHeightSegmentsRatio(){return this.opts.heightSegmentsRatio}getTension(){return this.opts.tension}buildGeometry(e,t,n,i){const s=this.opts.radius,o=this.opts.depth;this.TUBE_RADIUS=new x.Vector2(s,s),this.ARROW_END=new x.Vector2(o,s);const a={},l=this.opts.ss;for(const c in l)a[c]={center:new x.Vector2(o,l[c].width),start:new x.Vector2(o,l[c].arrow)};return this.secCache=a,ti.prototype.buildGeometry.call(this,e,t,n,i)}}Xa.prototype.id="CA";Xa.prototype.name="Cartoon";Xa.prototype.shortName="Cartoon";Xa.prototype.depGroups=["CartoonChains","NucleicSpheres","NucleicCylinders"];const jR=Xa,{selectors:YR}=Bt;function qR(){return{wireframe:this.opts.wireframe,zClip:this.opts.zClip}}class Yf extends ti{constructor(e){super(e),this.depGroups=this.depGroups.slice(0);const t=this.surfaceNames,n=this.depGroups;for(let i=0,s=t.length;i<s;++i)n[n.length]=[t[i],qR]}calcAtomRadius(e){return e.element.radius}getVisibilitySelector(){let e=null;if(this.opts.subset!==""){const t=YR.parse(this.opts.subset);t.error||(e=t.selector)}return e}}Yf.prototype.isSurface=!0;Yf.prototype.surfaceNames=[];const qf=Yf;class ja extends qf{static id="QS";getSurfaceOpts(){return{useBeads:!1,isoValue:this.opts.isoValue,gaussLim:this.opts.gaussLim[this.settings.now.resolution],radScale:this.opts.scale,gridSpacing:this.opts.gridSpacing[this.settings.now.resolution],zClip:this.opts.zClip,visibilitySelector:this.getVisibilitySelector()}}}ja.prototype.id="QS";ja.prototype.name="Quick Surface";ja.prototype.shortName="Quick Surf";ja.prototype.surfaceNames=["QuickSurfGeo"];const $R=ja;class lr extends qf{constructor(e,t){super(t),this._excludeProbe=e}calcAtomRadius(e){return e.element.radius}getSurfaceOpts(){return{gridSpacing:this.opts.polyComplexity[this.settings.now.resolution],radScale:this._radScale,zClip:this.opts.zClip,visibilitySelector:this.getVisibilitySelector(),probeRadius:this.opts.probeRadius,excludeProbe:this._excludeProbe}}}lr.prototype.id="SU";lr.prototype.name="Surface";lr.prototype.shortName="Surface";lr.prototype.surfaceNames=["SASSESSurfaceGeo"];lr.prototype._radScale=1;lr.prototype._excludeProbe=!1;const xy=lr;class eh extends xy{static id="SA";constructor(e){super(!1,e)}}eh.prototype.id="SA";eh.prototype.name="Solvent Accessible Surface";eh.prototype.shortName="SAS";const ZR=eh;class th extends xy{static id="SE";constructor(e){super(!0,e)}}th.prototype.id="SE";th.prototype.name="Solvent Excluded Surface";th.prototype.shortName="SES";const KR=th;class xo extends qf{static id="CS";getSurfaceOpts(){return{probeRadius:this.opts.probeRadius,radScale:this.opts.polyComplexity[this.settings.now.resolution],scaleFactor:this.opts.polyComplexity[this.settings.now.resolution],gridSpacing:1/this.opts.polyComplexity[this.settings.now.resolution],isoValue:this.opts.isoValue,probePositions:this.opts.probePositions,zClip:this.opts.zClip,visibilitySelector:this.getVisibilitySelector()}}}xo.prototype.id="CS";xo.prototype.name="Contact Surface";xo.prototype.shortName="Contact Surf";xo.prototype.isSurface=!0;xo.prototype.surfaceNames=["ContactSurfaceGeo"];const JR=xo;class Ya extends ti{static id="TX";getTemplateOptions(){return this.opts.template}getLabelOpts(){return de.default.merge(this.opts,{colors:!0,adjustColor:!0,transparent:!0})}}Ya.prototype.id="TX";Ya.prototype.name="Text mode";Ya.prototype.shortName="Text";Ya.prototype.depGroups=["TextLabelsGeo"];const QR=Ya,eP=new ar([BR,kR,GR,HR,WR,XR,jR,$R,ZR,KR,JR,QR]),pc=eP;function Gg(r,e,t){return r<=t?r<0?0:r:t}function tP(r,e,t){const n=1-t,i=r>>16&255,s=r>>8&255,o=r&255,a=e>>16&255,l=e>>8&255,c=e&255,h=n*i+t*a,u=n*s+t*l,d=n*o+t*c;return h<<16|u<<8|d}class $f{constructor(e,t){this.name=e||"Custom",this.id=t||"CP"}getElementColor(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const n=this.elementColors[e];return n===void 0&&!t?this.defaultElementColor:n}getResidueColor(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const n=this.residueColors[e];return n===void 0&&!t?this.defaultResidueColor:n}getChainColor(e){let t=e.charCodeAt(0);return t=((t<0?0:t>=256?t-256:t)&31)%this.chainColors.length,this.chainColors[t]}getSecondaryColor(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const n=this.secondaryColors[e];return n===void 0&&!t?this.defaultSecondaryColor:n}getSequentialColor(e){const{colors:t}=this,n=t.length;return e<0?t[e%n+n]:t[e%n]}getGradientColor(e,t){const n=this.gradients[t];if(!n)return this.defaultNamedColor;const i=n.length,s=e*(i-1);let o=Math.floor(s);const a=Gg(o+1,0,i-1);return o=Gg(o,0,i-1),tP(n[o],n[a],s-o)}getNamedColor(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const n=this.namedColors[e];return n===void 0&&!t?this.defaultNamedColor:n}}de.default.assign($f.prototype,{colors:[16777215,16711680,65280,255,8421504],minRangeColor:0,midRangeColor:8355711,maxRangeColor:16777215,defaultElementColor:16777215,elementColors:{},defaultResidueColor:16777215,residueColors:{},chainColors:[16777215],defaultSecondaryColor:16777215,secondaryColors:{},defaultGradientColor:0,defaultNamedColor:16777215,namedColorsArray:[["indianred",13458524],["lightcoral",15761536],["salmon",16416882],["darksalmon",15308410],["lightsalmon",16752762],["crimson",14423100],["red",16711680],["firebrick",11674146],["darkred",9109504],["pink",16761035],["lightpink",16758465],["hotpink",16738740],["deeppink",16716947],["mediumvioletred",13047173],["palevioletred",14381203],["coral",16744272],["tomato",16737095],["orangered",16729344],["darkorange",16747520],["orange",16753920],["gold",16766720],["yellow",16776960],["lightyellow",16777184],["lemonchiffon",16775885],["lightgoldenrodyellow",16448210],["papayawhip",16773077],["moccasin",16770229],["peachpuff",16767673],["palegoldenrod",15657130],["khaki",15787660],["darkkhaki",12433259],["lavender",15132410],["thistle",14204888],["plum",14524637],["violet",15631086],["orchid",14315734],["fuchsia",16711935],["magenta",16711935],["mediumorchid",12211667],["mediumpurple",9662683],["rebeccapurple",6697881],["blueviolet",9055202],["darkviolet",9699539],["darkorchid",10040012],["darkmagenta",9109643],["purple",8388736],["indigo",4915330],["slateblue",6970061],["mediumslateblue",8087790],["darkslateblue",4734347],["greenyellow",11403055],["chartreuse",8388352],["lawngreen",8190976],["lime",65280],["limegreen",3329330],["palegreen",10025880],["lightgreen",9498256],["mediumspringgreen",64154],["springgreen",65407],["mediumseagreen",3978097],["seagreen",3050327],["forestgreen",2263842],["green",32768],["darkgreen",25600],["yellowgreen",10145074],["olivedrab",7048739],["olive",8421376],["darkolivegreen",5597999],["mediumaquamarine",6737322],["darkseagreen",9419919],["lightseagreen",2142890],["darkcyan",35723],["teal",32896],["aqua",65535],["cyan",65535],["lightcyan",14745599],["paleturquoise",11529966],["aquamarine",8388564],["turquoise",4251856],["mediumturquoise",4772300],["darkturquoise",52945],["cadetblue",6266528],["steelblue",4620980],["lightsteelblue",11584734],["powderblue",11591910],["lightblue",11393254],["skyblue",8900331],["lightskyblue",8900346],["deepskyblue",49151],["dodgerblue",2003199],["cornflowerblue",6591981],["royalblue",4286945],["blue",255],["mediumblue",205],["darkblue",139],["navy",128],["midnightblue",1644912],["cornsilk",16775388],["blanchedalmond",16772045],["bisque",16770244],["navajowhite",16768685],["wheat",16113331],["burlywood",14596231],["tan",13808780],["rosybrown",12357519],["sandybrown",16032864],["goldenrod",14329120],["darkgoldenrod",12092939],["peru",13468991],["chocolate",13789470],["saddlebrown",9127187],["sienna",10506797],["brown",10824234],["maroon",8388608],["white",16777215],["snow",16775930],["honeydew",15794160],["mintcream",16121850],["azure",15794175],["aliceblue",15792383],["ghostwhite",16316671],["whitesmoke",16119285],["seashell",16774638],["beige",16119260],["oldlace",16643558],["floralwhite",16775920],["ivory",16777200],["antiquewhite",16444375],["linen",16445670],["lavenderblush",16773365],["mistyrose",16770273],["gainsboro",14474460],["lightgray",13882323],["silver",12632256],["darkgray",11119017],["gray",8421504],["dimgray",6908265],["lightslategray",7833753],["slategray",7372944],["darkslategray",3100495],["black",0]],namedColors:{},gradients:{rainbow:[255,65535,65280,16776960,16711680],temp:[255,32767,16777215,16744192,16711680],hot:[16777215,16744192,16711680],cold:[16777215,32767,255],"blue-red":[255,16777215,16711680],reds:[16777215,16711680],blues:[16777215,255]}});const{namedColorsArray:Hg,namedColors:nP}=$f.prototype;for(let r=0,{length:e}=Hg;r<e;++r){const[t,n]=Hg[r];nP[t]=n}const Zf=$f,vy=new Zf("CPK","CP");vy.elementColors={H:16777215,C:2105376,N:2121983,O:15605776,F:65280,P:8397055,S:16776960,CL:47872,FE:13684944,CO:13684944,NI:13684944,CU:13684944,BR:34816,I:21760};const iP=vy,cr=new Zf("Jmol","JM");cr.colors=[255,22015,44031,65535,65451,65365,65280,5635840,11271936,16776960,16755456,16733440,16711680,16711765,16711851,16711935,11206911,5570815];cr.elementColors={H:16777215,D:16777152,T:16777120,HE:14286847,LI:13402367,BE:12779264,B:16758197,C:9474192,N:3166456,O:16715021,F:9494608,NE:11789301,NA:11230450,MG:9109248,AL:12560038,SI:1578e4,P:16744448,S:16777008,CL:2093087,AR:8442339,K:9388244,CA:4062976,SC:15132390,TI:12567239,V:10921643,CR:9083335,MN:10255047,FE:14706227,CO:15765664,NI:5296208,CU:13140019,ZN:8224944,GA:12750735,GE:6721423,AS:12419299,SE:16752896,BR:10889513,KR:6076625,RB:7351984,SR:65280,Y:9764863,ZR:9756896,NB:7586505,MO:5551541,TC:3907230,RU:2396047,RH:687500,PD:27013,AG:12632256,CD:16767375,IN:10909043,SN:6717568,SB:10380213,TE:13924864,I:9699476,XE:4366e3,CS:5707663,BA:51456,LA:7394559,CE:16777159,PR:14286791,ND:13107143,PM:10747847,SM:9437127,EU:6422471,GD:4587463,TB:3211207,DY:2097095,HO:65436,ER:58997,TM:54354,YB:48952,LU:43812,HF:5096191,TA:5089023,W:2200790,RE:2522539,OS:2516630,IR:1528967,PT:13684960,AU:16765219,HG:12105936,TL:10900557,PB:5724513,BI:10375093,PO:11230208,AT:7688005,RN:4358806,FR:4325478,RA:32e3,AC:7384058,TH:47871,PA:41471,U:36863,NP:33023,PU:27647,AM:5528818,CM:7888099,BK:9064419,CF:10565332,ES:11739092,FM:11739066,MD:11734438,NO:12389767,LR:13041766,RF:13369433,DB:13697103,SG:14221381,BH:14680120,HS:15073326,MT:15400998};cr.defaultResidueColor=12492910;cr.residueColors={ALA:13158600,ARG:1334015,ASN:56540,ASP:15075850,CYS:15132160,GLN:56540,GLU:15075850,GLY:15461355,HIS:8553170,ILE:1016335,LEU:1016335,LYS:1334015,MET:15132160,PHE:3289770,PRO:14456450,SER:16422400,THR:16422400,TRP:11819700,TYR:3289770,VAL:1016335,A:10526975,C:16747595,G:16740464,I:8454143,T:10551200,U:16744576,DA:10526975,DC:16747595,DG:16740464,DI:8454143,DT:10551200,DU:16744576,"+A":10526975,"+C":16747595,"+G":16740464,"+I":8454143,"+T":10551200,"+U":16744576};cr.chainColors=[4294967295,4290826495,4289789872,4294951112,4294967168,4294951167,4289786096,4294955120,4293951616,4294303411,4278239231,4291648604,4284927402,4288335154,4293821166,4278243025,4278255487,4282168177,4278190219,4290623339,4278215680,4286578688,4286611456,4286578816,4278222976,4290283019,4289864226];const zo=Ln.Type;cr.secondaryColors={[zo.HELIX_ALPHA]:16711808,[zo.HELIX_PI]:6291584,[zo.HELIX_310]:10485888,[zo.STRAND]:16762880,[zo.TURN]:6324479,dna:11403518,rna:16580962};const sP=cr,Vi=new Zf("VMD","VM");Vi.colors=[255,16711680,6316128,16744448,16776960,8421427,10066329,65280,16777215,16751001,4243648,10879142,8447590,15099571,8408320,8421568];Vi.defaultElementColor=8408320;Vi.elementColors={H:16777215,C:4243391,N:255,O:16711680,P:8421427,S:16776960};Vi.defaultResidueColor=4243648;Vi.residueColors={ALA:255,ARG:16777215,ASN:8421427,ASP:16711680,CYS:16776960,GLN:16744448,GLU:16751001,GLY:16777215,HIS:4243648,ILE:65280,LEU:16751001,LYS:4243648,MET:16776960,PHE:10879142,PRO:8408064,SER:16776960,THR:15099571,TRP:10066329,TYR:65280,VAL:8421427,A:255,C:16744448,G:16776960,T:10879142,U:65280,DA:255,DC:16744448,DG:16776960,DT:10879142,DU:65280,"+A":255,"+C":16744448,"+G":16776960,"+T":10879142,"+U":65280,WAT:4243648,H2O:4243648,HOH:4243648};Vi.chainColors=[16777215].concat(Vi.colors);const Gr=Ln.Type;Vi.secondaryColors={[Gr.HELIX_ALPHA]:10879142,[Gr.HELIX_310]:255,[Gr.HELIX_PI]:16711680,[Gr.STRAND]:16776960,[Gr.BRIDGE]:8421427,[Gr.TURN]:4243648};const rP=Vi,oP=new ar([iP,sP,rP]),lo=oP;class nh{constructor(e){if(this.constructor===nh)throw new Error("Can not instantiate abstract class!");this.opts=de.default.merge(be.deriveDeep(te.now.colorers[this.id],!0),e),this.palette=lo.first}identify(){const e=be.objectsDiff(this.opts,te.now.colorers[this.id]);return de.default.isEmpty(e)?this.id:[this.id,e]}}nh.prototype.id="__";const Un=nh;class ih extends Un{static id="EL";getAtomColor(e,t){const n=e.element.name;return n==="C"&&this.opts.carbon>=0?this.opts.carbon:this.palette.getElementColor(n)}getResidueColor(e,t){return this.palette.defaultResidueColor}}ih.prototype.id="EL";ih.prototype.name="Element";ih.prototype.shortName="Element";const aP=ih;class sh extends Un{static id="RT";getAtomColor(e,t){return this.getResidueColor(e.residue,t)}getResidueColor(e,t){return this.palette.getResidueColor(e._type._name)}}sh.prototype.id="RT";sh.prototype.name="Residue Type";sh.prototype.shortName="Residue";const lP=sh;class rh extends Un{static id="SQ";getAtomColor(e,t){return this.getResidueColor(e.residue,t)}getResidueColor(e,t){const n=e._chain;if(n.minSequence===Number.POSITIVE_INFINITY&&n.maxSequence===Number.NEGATIVE_INFINITY)return this.palette.defaultNamedColor;const i=n.minSequence,s=n.maxSequence>i?n.maxSequence:i+1;return this.palette.getGradientColor((e._sequence-i)/(s-i),this.opts.gradient)}}rh.prototype.id="SQ";rh.prototype.name="Sequence";rh.prototype.shortName="Sequence";const cP=rh;class oh extends Un{static id="CH";getAtomColor(e,t){return this.getResidueColor(e.residue,t)}getResidueColor(e,t){return this.palette.getChainColor(e.getChain()._name)}}oh.prototype.id="CH";oh.prototype.name="Chain";oh.prototype.shortName="Chain";const hP=oh;class ah extends Un{static id="SS";getAtomColor(e,t){return this.getResidueColor(e.residue,t)}getResidueColor(e,t){if(e._type.flags&gt.Flags.DNA)return this.palette.getSecondaryColor("dna");if(e._type.flags&gt.Flags.RNA)return this.palette.getSecondaryColor("rna");const n=e.getSecondary();if(n){let i=this.palette.getSecondaryColor(n.type,!0);return i===void 0&&(i=this.palette.getSecondaryColor(n.generic)),i}return this.palette.defaultSecondaryColor}}ah.prototype.id="SS";ah.prototype.name="Secondary Structure";ah.prototype.shortName="Structure";const Sy=ah;class lh extends Un{static id="UN";getAtomColor(e,t){return this.opts.color}getResidueColor(e,t){return this.opts.color}}lh.prototype.id="UN";lh.prototype.name="Uniform";lh.prototype.shortName="Uniform";const uP=lh;class ch extends Un{static id="CO";constructor(e){super(e);const t=er.parse(this.opts.subset);this._subsetCached=t.error?er.none():t.selector}getAtomColor(e,t){return this._subsetCached.includesAtom(e)?this.opts.color:this.opts.baseColor}getResidueColor(e,t){const n=this._subsetCached,i=e._atoms;for(let s=0,o=i.length;s<o;++s)if(!n.includesAtom(i[s]))return this.opts.baseColor;return this.opts.color}}ch.prototype.id="CO";ch.prototype.name="Conditional";ch.prototype.shortName="Conditional";const dP=ch;class hh extends Un{static id="CF";getAtomColor(e,t){return this.palette.getChainColor(String.fromCharCode(e.location))}getResidueColor(e,t){return this.palette.defaultResidueColor}}hh.prototype.id="CF";hh.prototype.name="Conformation";hh.prototype.shortName="Conformation";const fP=hh;class uh extends Un{static id="TM";getAtomColor(e,t){const{opts:n}=this;let i=1;return e.temperature&&n?(n.min===n.max?i=e.temperature>n.max?1:0:i=(e.temperature-n.min)/(n.max-n.min),this.palette.getGradientColor(i,n.gradient)):this.palette.defaultGradientColor}getResidueColor(e,t){const{opts:n}=this;if(!n)return this.palette.defaultGradientColor;if(e.temperature){let i=0;return n.min===n.max?i=e.temperature>n.max?1:0:i=(e.temperature-n.min)/(n.max-n.min),this.palette.getGradientColor(i,n.gradient)}return this.palette.defaultGradientColor}}uh.prototype.id="TM";uh.prototype.name="Temperature";uh.prototype.shortName="Temperature";const pP=uh;class dh extends Un{static id="OC";_getColorByOccupancy(e,t){if(e!==void 0){const n=1-e;return this.palette.getGradientColor(n,t.gradient)}return this.palette.defaultGradientColor}getAtomColor(e,t){const{opts:n}=this;return this._getColorByOccupancy(e.occupancy,n)}getResidueColor(e,t){const{opts:n}=this;return this._getColorByOccupancy(e.occupancy,n)}}dh.prototype.id="OC";dh.prototype.name="Occupancy";dh.prototype.shortName="Occupancy";const mP=dh;class fh extends Un{static id="HY";getAtomColor(e,t){return this.getResidueColor(e.residue,t)}getResidueColor(e,t){let n=this.palette.defaultResidueColor;return e._type.hydrophobicity!==void 0&&(n=this.palette.getGradientColor((e._type.hydrophobicity- -4.5)/(4.5- -4.5),this.opts.gradient)),n}}fh.prototype.id="HY";fh.prototype.name="Hydrophobicity";fh.prototype.shortName="Hydrophobicity";const gP=fh;class ph extends Un{static id="MO";getAtomColor(e,t){return this.getResidueColor(e.residue,t)}getResidueColor(e,t){const n=e._molecule,i=t.getMoleculeCount();return i>1?this.palette.getGradientColor((n.index-1)/(i-1),this.opts.gradient):this.palette.getGradientColor(0,this.opts.gradient)}}ph.prototype.id="MO";ph.prototype.name="Molecule";ph.prototype.shortName="Molecule";const _P=ph;function yP(r,e){const t=r>>16&255,n=r>>8&255,i=r&255,s=e*t,o=e*n,a=e*i;return s<<16|o<<8|a}class mh extends Un{static id="CB";getAtomColor(e,t){const n=this.opts.color,i=yP(n,this.opts.factor);return e.flags&mi.Flags.CARBON?n:i}getResidueColor(e,t){return this.opts.color}}mh.prototype.id="CB";mh.prototype.name="Carbon";mh.prototype.shortName="Carbon";const xP=mh,vP=new ar([aP,lP,cP,hP,Sy,uP,dP,fP,pP,mP,gP,_P,xP]),mc=vP;function Wt(r){return new x.Color(r,r,r)}const SP=[{id:"DF",name:"Diffuse",shortName:"Diffuse",uberOptions:{diffuse:Wt(1),specular:Wt(0),shininess:1,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"SF",name:"Soft Plastic",shortName:"Soft",uberOptions:{diffuse:Wt(1),specular:Wt(.1),shininess:30,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"PL",name:"Glossy Plastic",shortName:"Glossy",uberOptions:{diffuse:Wt(.56),specular:Wt(.28),shininess:100,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"ME",name:"Metal",shortName:"Metal",uberOptions:{diffuse:Wt(.56),specular:Wt(.55),shininess:30,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!1}},{id:"TR",name:"Transparent",shortName:"Transparent",uberOptions:{diffuse:Wt(1),specular:Wt(0),shininess:1,opacity:.5},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!0,toonShading:!1}},{id:"GL",name:"Glass",shortName:"Glass",uberOptions:{diffuse:Wt(.5),specular:Wt(.65),shininess:100,opacity:.5},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!0,toonShading:!1}},{id:"BA",name:"Backdrop",shortName:"Backdrop",uberOptions:{diffuse:Wt(1),specular:Wt(0),shininess:1,opacity:1},values:{lights:!1,fog:!1,depthWrite:!1,transparent:!1,toonShading:!1}},{id:"TN",name:"Toon",shortName:"Toon",uberOptions:{diffuse:Wt(1),specular:Wt(0),shininess:1,opacity:1},values:{lights:!0,fog:!0,depthWrite:!0,transparent:!1,toonShading:!0}},{id:"FL",name:"Flat",shortName:"Flat",uberOptions:{diffuse:Wt(1),specular:Wt(0),shininess:0,opacity:1},values:{lights:!1,fog:!0,depthWrite:!0,transparent:!1}}],bP=new ar(SP),no=bP;function wP(r,e){const t=[];return r.traverse(n=>{for(let i=0;i<e.length;i++)if(n instanceof e[i]){t[t.length]=n;break}}),t}function Kf(r,e,t){const n=r.material.createInstance();n.setValues(e);const i=new r.constructor(r.geometry,n);return i.material.needsUpdate=!0,i.applyMatrix4(r.matrix),i.layers.set(t),i}function qa(r,e,t){const n=wP(r,e);for(let i=0,s=n.length;i<s;++i){const o=n[i];o.parent&&t(o)}}function MP(r,e){const t=e.length;if(t<1)return;const n=[x.Mesh,x.LineSegments,x.Line];qa(r,n,i=>{i.applyMatrix4(e[0]);for(let s=1;s<t;++s){const o=new i.constructor(i.geometry,i.material);i.parent.add(o),o.applyMatrix4(e[s])}})}const AP=(function(){const r={prepassTransparancy:!0,fakeOpacity:!1,transparent:!1,colorFromDepth:!1,lights:!1,shadowmap:!1,fog:!1};return function(e,t){t instanceof xi&&qa(e,[x.Mesh,x.LineSegments],n=>{n.material.setValues({prepassTransparancy:!1,fakeOpacity:!1}),n.material.needsUpdate=!0,n.layers.set(Je.LAYERS.TRANSPARENT);const i=Kf(n,r,Je.LAYERS.PREPASS_TRANSPARENT);n.parent.add(i)})}})(),EP=(function(){const r={colorFromPos:!0,transparent:!1,colorFromDepth:!1,lights:!1,shadowmap:!1,fog:!1,overrideColor:!1,fogTransparent:!1,attrColor:!1,attrColor2:!1,attrAlphaColor:!1,fakeOpacity:!1};return function(e,t){t instanceof xi&&qa(e,[x.Mesh,x.LineSegments],n=>{const i=Kf(n,r,Je.LAYERS.COLOR_FROM_POSITION);n.parent.add(i)})}})(),TP=(function(){const r={colorFromDepth:!0,orthoCam:!0,lights:!1,shadowmap:!1,fog:!1};return function(e,t){t instanceof xi&&qa(e,[x.Mesh,x.LineSegments],n=>{if(!n.receiveShadow&&n.material.shadowmap&&n.material.setValues({shadowmap:!1}),!n.material.lights||!n.castShadow||!Je.belongToSelectLayers(n))return;const i=Kf(n,r,Je.LAYERS.SHADOWMAP);i.isShadowmapMesh=!0,n.parent.add(i)})}})();function CP(r,e){e instanceof xi&&qa(r,[x.Mesh,x.LineSegments],t=>{t.isShadowmapMesh&&t.parent.remove(t)})}function by(r,e){function t(n){n instanceof x.Mesh&&e(n);for(let i=0,s=n.children.length;i<s;i++)t(n.children[i])}t(r)}function RP(r){const e=r.geometry;if(e instanceof x.InstancedBufferGeometry){const t=e.attributes;for(const n in t)if(t.hasOwnProperty(n)&&t[n]instanceof x.InstancedBufferAttribute){const i=t[n];return(e.index?e.index.array.length/3:0)*i.array.length/i.itemSize}return 0}return e instanceof x.BufferGeometry?e.index?e.index.array.length/3:0:e.faces?e.faces.length:0}function PP(r){let e=0;return by(r,t=>{e+=RP(t)}),e}const io={applyTransformsToMeshes:MP,processTransparentMaterial:AP,processColFromPosMaterial:EP,createShadowmapMaterial:TP,removeShadowmapMaterial:CP,forEachMeshInGroup:by,countTriangles:PP},{selectors:IP}=Bt;class LP{constructor(e,t,n,i){const s={clipPlane:te.now.draft.clipPlane,fogTransparent:te.now.bg.transparent,shadowmap:te.now.shadow.on,shadowmapType:te.now.shadow.type};this.index=e,this.mode=t,this.colorer=n,this.selector=i,this.selectorString="",this.count=0,this.material=new xi,this.material.setValues(s),this.material.setUberOptions({fogAlpha:te.now.fogAlpha}),this.materialPreset=no.first,this.needsRebuild=!0,this.visible=!0,this.setMode(t)}markAtoms(e){return this.count=e.markAtoms(this.selector,1<<this.index),this.needsRebuild=!0,this.count}unmarkAtoms(e){e.clearAtomBits(1<<this.index),this.count=0}setMode(e){this.mode=e}setMaterialPreset(e){this.materialPreset=e,this.material.setUberOptions(e.uberOptions),this.material.setValues(e.values)}reset(){this.geo=null,this.selectionGeo=null}buildGeometry(e){return this.reset(),this.needsRebuild=!1,te.now.ao&&this.material.setValues({normalsToGBuffer:te.now.ao}),this.geo=this.mode.buildGeometry(e,this.colorer,1<<this.index,this.material),this.material.uberOptions.opacity<.99&&te.now.transparency==="prepass"&&io.processTransparentMaterial(this.geo,this.material),this.geo.visible=this.visible,Je.processObjRenderOrder(this.geo,this.materialPreset.id),io.processColFromPosMaterial(this.geo,this.material),te.now.shadow.on&&io.createShadowmapMaterial(this.geo,this.material),this.geo}buildSelectionGeometry(e){let t=null;if(this.geo&&"getSubset"in this.geo){const n=this.geo.getSubset(e);if(n&&n.length>0){t=new x.Group,t.matrixAutoUpdate=!1,t.matrix=this.geo.matrix;for(let i=0;i<n.length;i++){const s=n[i];t.add(s)}}}return t&&(t.visible=this.visible),this.selectionGeo=t,this.selectionGeo}compare(e){const t={},n=String(this.selector);(!e||n.valueOf()!==String(e.selector).valueOf())&&(t.selector=n);const i=this.mode.identify();(!e||Array.isArray(i)||i!==e.mode)&&(t.mode=i);const s=this.colorer.identify();return(!e||Array.isArray(s)||s!==e.colorer)&&(t.colorer=s),(!e||this.materialPreset.id!==e.material)&&(t.material=this.materialPreset.id),t}change(e,t,n,i){const s={};if(e.selector){const o=IP.parse(e.selector).selector,a=String(o);this.selectorString!==a&&(s.selector=a,this.selectorString=a,this.selector=o,this.markAtoms(t))}if(e.mode){const o=e.mode;de.default.isEqual(this.mode.identify(),o)||(s.mode=o,this.setMode(n))}if(e.colorer){const o=e.colorer;de.default.isEqual(this.colorer.identify(),o)||(s.colorer=o,this.colorer=i)}if(e.material){const o=e.material;de.default.isEqual(this.materialPreset.id,o)||(s.material=o,this.setMaterialPreset(no.get(e.material)))}return s}show(e){this.visible=e,this.geo&&(this.geo.visible=e),this.selectionGeo&&(this.selectionGeo.visible=e)}}const Rd=LP;function wy(r,e,t){const{children:n}=r;if(n)for(let i=0,s=n.length;i<s;++i){const o=n[i];o._component===e&&t(o),o instanceof Je.RCGroup&&wy(o,e,t)}}function My(){}class NP extends My{constructor(e){super(),this._complexVisual=e,this._inProgress=!1}begin(){const e=this._complexVisual.getComplex();this._componentTransforms=[];for(let t=0;t<e._components.length;++t){const n=e._components[t];this._componentTransforms[n._index]=new x.Object3D}return this._inProgress=!0,!0}apply(){if(!this._inProgress)return;const e=this._complexVisual.getComplex();for(let t=0;t<e._components.length;++t)this._bakeComponentTransform(e._components[t]);e.onAtomPositionChanged(),this._resetComponentTransform(),this._complexVisual.finalizeEdit()}discard(){this._inProgress&&(this._resetComponentTransform(),this._complexVisual.finalizeEdit())}getAltObj(){const e={objects:[],pivot:new x.Vector3(0,0,0)},t=this._complexVisual,n=t.getSelectedComponent();if(n===null)return e;const i=this._complexVisual.getSelectionGeo(),s=1<<t.getSelectionBit();let o,a,l,c;for(wy(t,n,d=>{e.objects.push(d)}),o=0;o<i.children.length;++o)for(l=i.children[o],a=0;a<l.children.length;++a)c=l.children[a],c.hasOwnProperty("_component")&&c._component===n&&e.objects.push(c);e.objects.push(this._componentTransforms[n._index]);const h=new x.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),u=new x.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);return n.forEachResidue(d=>{const f=d._atoms;for(a=0;a<f.length;++a)f[a].mask&s&&(h.min(f[a].position),u.max(f[a].position))}),e.pivot.lerpVectors(h,u,.5),e}_bakeComponentTransform(e){const t=this._componentTransforms[e._index];t&&(!(t.position.x===0&&t.position.y===0&&t.position.z===0)||!(t.quaternion.x===0&&t.quaternion.y===0&&t.quaternion.z===0&&t.quaternion.w===1))&&(t.updateMatrix(),e.forEachResidue(n=>{const i=n._atoms;for(let s=0;s<i.length;++s)i[s].position.applyMatrix4(t.matrix)}))}_resetComponentTransform(){const e=this._complexVisual,t=this._complexVisual.getSelectionGeo();let n,i,s,o;for(n=0;n<this._componentTransforms.length;++n)o=this._componentTransforms[n],o.position.set(0,0,0),o.quaternion.set(0,0,0,1);for(n=0;n<e.children.length;++n)for(s=e.children[n],i=0;i<s.children.length;++i)o=s.children[i],o.hasOwnProperty("_component")&&(o.position.set(0,0,0),o.quaternion.set(0,0,0,1));for(n=0;n<t.children.length;++n)for(s=t.children[n],i=0;i<s.children.length;++i)o=s.children[i],o.hasOwnProperty("_component")&&(o.position.set(0,0,0),o.quaternion.set(0,0,0,1))}}class OP extends My{constructor(e){super(),this._complexVisual=e,this._inProgress=!1}begin(){const e=this._complexVisual,t=this._complexVisual.getSelectionGeo(),n=this._getSelectionBorderAtoms();if(n.length<1||n.length>2)return Ut.error("Can only edit fragments with one or two bound atoms."),!1;this._fragmentBoundAtoms=n;const i=1<<e.getSelectionBit();e.disableSubset(i,!0);for(let a=0;a<t.children.length;++a)t.children[a].visible=!1;const s=n[0].position.clone();n.length===2&&s.lerp(n[1].position,.5),this._fragmentGeo=new x.Group,e.add(this._fragmentGeo),this._fragmentGeo.position.copy(s),this._fragmentSelectionGeo=new x.Group,t.add(this._fragmentSelectionGeo),this._fragmentSelectionGeo.position.copy(s);const o=s.clone();o.negate();for(let a=0;a<e.children.length;++a){const l=e.children[a];if(!("getSubset"in l))continue;const c=new x.Group;this._fragmentGeo.add(c);const h=new x.Group;this._fragmentSelectionGeo.add(h);const u=l.getSubset(i,!0);for(let f=0;f<u.length;f++){const p=u[f];c.add(p),p.position.copy(o)}const d=l.getSubset(i,!0);for(let f=0;f<d.length;f++){const p=d[f];h.add(p),p.position.copy(o)}}return Je.applySelectionMaterial(this._fragmentSelectionGeo),this._inProgress=!0,!0}apply(){if(!this._inProgress)return;const e=this._complexVisual,t=e.getSelectionBit(),n=this._fragmentGeo.position,i=this._fragmentGeo.matrix.clone();i.multiply(new x.Matrix4().makeTranslation(-n.x,-n.y,-n.z)),this._bakeAtomTransform(i,1<<t),e.enableSubset(1<<t,!0),e.getComplex().onAtomPositionChanged(),e.finalizeEdit()}discard(){if(!this._inProgress)return;const e=this._complexVisual,t=this._complexVisual.getSelectionGeo();this._fragmentGeo.parent.remove(this._fragmentGeo),e.enableSubset(1<<e.getSelectionBit(),!0);for(let n=0;n<t.children.length;++n){const i=t.children[n];i.visible?t.remove(i):i.visible=!0}e.finalizeEdit()}isFreeRotationAllowed(){return this._fragmentBoundAtoms.length<2}getAltObj(){const e={objects:[],pivot:new x.Vector3(0,0,0)};e.objects.push(this._fragmentGeo,this._fragmentSelectionGeo);const t=this._fragmentBoundAtoms;if(t.length===1){if(t[0].bonds.length===1){const n=t[0].bonds[0];e.axis=new x.Vector3().subVectors(n._right.position,n._left.position),e.axis.normalize(),e.axis.transformDirection(this._complexVisual.matrixWorld)}}else t.length===2&&(e.axis=new x.Vector3().subVectors(t[1].position,t[0].position),e.axis.normalize(),e.axis.transformDirection(this._complexVisual.matrixWorld));return e}_getSelectionBorderAtoms(){const e=this._complexVisual.getComplex(),t=1<<this._complexVisual.getSelectionBit(),n={};e.forEachBond(o=>{o._left.mask&t?(o._right.mask&t)===0&&(n[o._left.index]=1):o._right.mask&t&&(n[o._right.index]=1)});const i=[],s=Object.keys(n);for(let o=0,a=s.length;o<a;++o){const l=s[o];i.push(e._atoms[l])}return i}_bakeAtomTransform(e,t){this._complexVisual.getComplex().forEachAtom(n=>{n.mask&t&&n.position.applyMatrix4(e)})}}const Wg={ComponentEditor:NP,FragmentEditor:OP},{selectors:an}=Bt;function Hr(r,e){Array.isArray(e)||(e=[e]);const[t,n]=e,i=r.get(t)||r.first;return new i(n)}class xa extends _a{constructor(e,t){super(e,t),this._complex=t,this._reprList=[],this._repr=null,this._reprListChanged=!0,this._selectionBit=0,this._reprUsedBits=0,this._selectionCount=0,this._selectionGeometry=new x.Group}getBoundaries(){return this._complex.getBoundaries()}release(){this._selectionGeometry.parent&&this._selectionGeometry.remove(this._selectionGeometry),_a.prototype.release.call(this)}getComplex(){return this._complex}getSelectionCount(){return this._selectionCount}getSelectionGeo(){return this._selectionGeometry}getSelectionBit(){return this._selectionBit}getEditor(){return this._editor}resetReps(e){this._complex&&this._complex.clearAtomBits(-1),this._reprListChanged=!0,this._reprUsedBits=0,this._reprList.length=e.length;for(let t=0,n=e.length;t<n;++t){const i=e[t];let s,o;typeof i.selector=="string"?(o=i.selector,{selector:s}=an.parse(o)):typeof i.selector>"u"?(o=te.now.presets.default[0].selector,{selector:s}=an.parse(o)):({selector:s}=i,o=s.toString());const a=Hr(pc,i.mode),l=Hr(mc,i.colorer),c=no.get(i.material)||no.first;this._reprList[t]=new Rd(t,a,l,s),this._reprList[t].setMaterialPreset(c),this._reprList[t].selectorString=o,this._complex&&this._complex.markAtoms(s,1<<t),this._reprUsedBits|=1<<t}this._repr=e.length>0?this._reprList[0]:null,this._selectionBit=e.length,this._reprUsedBits|=1<<this._selectionBit,this._selectionCount=0,this._complex&&this._complex.update()}repCount(){return this._reprList.length}repCurrent(e){return e>=0&&e<this._reprList.length?this._repr=this._reprList[e]:e=this._reprList.indexOf(this._repr),e}rep(e,t){if(!t&&(e===void 0||e instanceof Object)&&(t=e,e=this.repCurrent()),e<0||e>this._reprList.length)return Ut.error(`Rep ${e} does not exist!`),null;if(e===this._reprList.length){const s=this.repAdd(t);return Ut.warn(`Rep ${e} does not exist! New representation was created.`),{desc:s.desc,index:e,status:"created"}}const n=this._reprList[e],i={selector:n.selectorString,mode:n.mode.identify(),colorer:n.colorer.identify(),material:n.materialPreset.id};if(t){const s=n.change(t,this._complex,Hr(pc,t.mode),Hr(mc,t.colorer));if(!de.default.isEmpty(s)){n.needsRebuild=!0;for(const o in s)s.hasOwnProperty(o)&&(i[o]=s[o],Ut.debug(`rep[${e}].${o} changed to ${s[o]}`));return s.mode&&n.mode.isSurface&&(te.now.resolution==="ultra"||te.now.resolution==="high")&&(Ut.report('Surface resolution was changed to "medium" to avoid hang-ups.'),te.set("resolution","medium")),{desc:i,index:e,status:"changed"}}}return{desc:i,index:e,status:""}}repGet(e){return(e===void 0||e instanceof Object)&&(e=this.repCurrent()),e<0||e>=this._reprList.length?null:this._reprList[e]}_getFreeReprIdx(){let e=this._reprUsedBits;for(let t=0;t<=xa.NUM_REPRESENTATION_BITS;++t,e>>=1)if((e&1)===0)return t;return-1}repAdd(e){if(this._reprList.length>=xa.NUM_REPRESENTATION_BITS)return null;const t=this._getFreeReprIdx();if(t<0)return null;const n=this.buildSelectorFromMask(1<<this._selectionBit),i=te.now.presets.default[0],s=de.default.merge({selector:i.selector,mode:i.mode,colorer:i.colorer,material:i.material},e),o=typeof s.selector=="string"?an.parse(s.selector).selector:s.selector,a=new Rd(this._selectionBit,Hr(pc,s.mode),Hr(mc,s.colorer),o);return a.selectorString=o.toString(),a.setMaterialPreset(no.get(s.material)),a.markAtoms(this._complex),this._reprList.push(a),this._selectionBit=t,this._reprUsedBits|=1<<this._selectionBit,this._complex.markAtoms(n,1<<this._selectionBit),{desc:s,index:this._reprList.length-1}}repRemove(e){e===void 0&&(e=this.repCurrent());let t=this._reprList.length;if(e<0||e>=t||t<=1)return;const n=this._reprList[e];n.unmarkAtoms(this._complex),this._reprUsedBits&=~(1<<n.index),this._reprList.splice(e,1),n===this._repr&&(--t,e=e<t?e:t-1,this._repr=this._reprList[e]),this._reprListChanged=!0}repHide(e,t){if(t===void 0&&(t=!0),e<0||e>=this._reprList.length)return;this._reprList[e].show(!t)}select(e,t){t?this._selectionCount+=this._complex.markAtomsAdditionally(e,1<<this._selectionBit):this._selectionCount=this._complex.markAtoms(e,1<<this._selectionBit),this._complex.updateStructuresMask(),this.rebuildSelectionGeometry()}resetSelectionMask(){this._selectionCount!==0&&(this._selectionCount=0,this._complex&&this._complex.clearAtomBits(1<<this._selectionBit))}updateSelectionMask(e){const t=this,{atom:n}=e;let{residue:i,chain:s,molecule:o}=e;const a=1<<this._selectionBit,l=~a;if(n)i=n.residue,s=i._chain,o=i._molecule,n.mask&a?(n.mask&=l,i._mask&=l,s._mask&=l,o&&(o.mask&=l),this._selectionCount--):(n.mask|=a,this._selectionCount++,i.collectMask(),s.collectMask(),o&&o.collectMask());else if(i)s=i._chain,o=i._molecule,i._mask&a?(i._mask&=l,s._mask&=l,i.forEachAtom(c=>{c.mask&a&&(c.mask&=l,t._selectionCount--)})):(i._mask|=a,i.forEachAtom(c=>{c.mask&a||(c.mask|=a,t._selectionCount++)}),s.collectMask(),o&&o.collectMask());else if(s||o){const c=s||o;c._mask&a?(c._mask&=l,c.forEachResidue(h=>{h._mask&a&&(h._mask&=l,h.forEachAtom(u=>{u.mask&a&&(u.mask&=l,t._selectionCount--)}),h._mask&=l)})):(c._mask|=a,c.forEachResidue(h=>{if(!(h._mask&a)){h._mask|=a,h.forEachAtom(d=>{d.mask&a||(d.mask|=a,t._selectionCount++)});const u=s?h.getMolecule():h.getChain();u&&u.collectMask()}}))}else this.resetSelectionMask()}expandSelection(){const e=this,t=1<<this._selectionBit,n=1<<31;this._complex.forEachBond(s=>{s._left.mask&t?(s._right.mask&t)===0&&(s._right.mask|=n):s._right.mask&t&&(s._left.mask|=n)});const i=~n;this._complex.forEachAtom(s=>{s.mask&n&&(s.mask=s.mask&i|t,++e._selectionCount)}),this._complex.updateStructuresMask()}shrinkSelection(){const e=this,t=1<<this._selectionBit,n=1<<31;this._complex.forEachBond(s=>{s._left.mask&t?(s._right.mask&t)===0&&(s._left.mask|=n):s._right.mask&t&&(s._right.mask|=n)}),this._complex.forEachAtom(s=>{s.mask&t&&s.bonds.length===1&&(s.mask|=n)});const i=~(t|n);this._complex.forEachAtom(s=>{s.mask&n&&(s.mask&=i,--e._selectionCount)}),this._complex.updateStructuresMask()}getSelectedComponent(){const e=1<<this._selectionBit;let t=null,n=!1;return this._complex.forEachAtom(i=>{i.mask&e&&(t===null?t=i.residue._component:t!==i.residue._component&&(n=!0))}),n?null:t}getSelectionCenter(e,t,n){e.set(0,0,0);let i=0;return this._complex.forEachAtom(s=>{t(s,n)&&(e.add(s.position),i++)}),i===0?!1:(e.divideScalar(i),e.applyMatrix4(this.matrix),!0)}needsRebuild(){if(this._reprListChanged)return!0;const e=this._reprList;for(let t=0,n=e.length;t<n;++t)if(e[t].needsRebuild)return!0;return!1}rebuild(){const e=this;return Je.clearTree(this),new Promise(t=>{const n=e._complex;if(!n){t();return}let i=!1;setTimeout(()=>{console.time("build");const s=e._reprList,o=lo.get(te.now.palette)||lo.first;let a=!1;for(let l=0,c=s.length;l<c;++l){const h=s[l];if(h.colorer.palette=o,h.needsRebuild){h.reset();try{h.buildGeometry(n)}catch(u){if(u instanceof be.OutOfMemoryError)h.needsRebuild=!1,h.reset(),Ut.error(`Not enough memory to build geometry for representation ${h.index+1}`),i=!0;else throw u}}a=i||a||Je.groupHasGeometryToRender(h.geo),h.geo&&e.add(h.geo)}e._reprListChanged=!1,console.timeEnd("build"),t()},10)})}setNeedsRebuild(){const e=this._reprList;for(let t=0,n=e.length;t<n;++t)e[t].needsRebuild=!0}rebuildSelectionGeometry(){const e=1<<this._selectionBit;Je.clearTree(this._selectionGeometry);for(let t=0,n=this._reprList.length;t<n;++t){const s=this._reprList[t].buildSelectionGeometry(e);if(s){this._selectionGeometry.add(s);for(let o=0;o<s.children.length;o++){const a=s.children[o];if(this._editor&&this._editor._componentTransforms){const l=this._editor._componentTransforms[a._component._index];l&&(a.position.copy(l.position),a.quaternion.copy(l.quaternion))}}Je.applySelectionMaterial(s)}}}_buildSelectorFromSortedLists(e,t,n){const i=this._complex;function s(a){const l=[];let c=0,h=NaN,u=NaN;for(let d=0,f=a.length;d<f;++d){const p=a[d];p===u+1?u=p:(Number.isNaN(h)||(l[c++]=new an.Range(h,u)),h=u=p)}return Number.isNaN(h)||(l[c]=new an.Range(h,u)),l}let o=null;if(n.length===i._chains.length)o=an.all();else{let a;if(n.length>0&&(a=an.chain(n),o=o?an.or(o,a):a),Object.keys(t).length>0)for(const l in t)t.hasOwnProperty(l)&&(a=an.and(an.chain(l),an.residx(s(t[l]))),o=o?an.or(o,a):a);e.length>0&&(a=an.serial(s(e)),o=o?an.or(o,a):a),o||(o=an.none())}return o}buildSelectorFromMask(e){const t=this._complex,n=[],i={},s=[];return t.forEachChain(o=>{o._mask&e&&n.push(o._name)}),t.forEachResidue(o=>{if(o._mask&e&&!(o._chain._mask&e)){const a=o._chain._name;a in i?i[a].push(o._index):i[a]=[o._index]}}),t.forEachAtom(o=>{o.mask&e&&!(o.residue._mask&e)&&s.push(o.serial)}),this._buildSelectorFromSortedLists(s,i,n)}forSelectedResidues(e){const t=1<<this._selectionBit;this._complex.forEachResidue(n=>{n._mask&t&&e(n)})}beginComponentEdit(){if(this._editor)return null;const e=new Wg.ComponentEditor(this);return e.begin()?(this._editor=e,e):null}beginFragmentEdit(){if(this._editor)return null;const e=new Wg.FragmentEditor(this);return e.begin()?(this._editor=e,e):null}finalizeEdit(){this._editor=null}setMaterialValues(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,n=arguments.length>2&&arguments[2]!==void 0?arguments[2]:void 0;for(let i=0,s=this._reprList.length;i<s;++i){const o=this._reprList[i];o.material.setValues(e),t&&o.geo.traverse(a=>{a instanceof x.Mesh&&(a.material.setValues(e),n!==void 0&&n(a),a.material.needsUpdate=!0)})}}setUberOptions(e){for(let t=0,n=this._reprList.length;t<n;++t)this._reprList[t].material.setUberOptions(e)}within(e,t){const n=this._complex.getVoxelWorld();if(n===null)return!1;const i=1<<this._selectionBit;return this._complex.markAtoms(e,i),n&&n.forEachAtomWithinDistFromMasked(this._complex,i,Number(t),s=>{s.mask|=i}),this._selectionCount=this._complex.countAtomsByMask(i),this._complex.updateStructuresMask(),this.buildSelectorFromMask(i)}}xa.NUM_REPRESENTATION_BITS=30;const Bi=xa,DP=`varying vec3 pos;\r
\r
void main() {\r
  // we're assuming local position is in [-0.5, 0.5]\r
  // we need to offset it to be represented in RGB\r
  pos = position.xyz + 0.5;\r
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r
}`,UP=`varying vec3 pos;\r
\r
void main() {\r
  gl_FragColor = vec4(pos, 0.5);\r
}`,FP=`varying vec4 screenSpacePos;\r
\r
void main() {\r
  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r
  gl_Position = screenSpacePos;\r
}`,zP=`uniform mat4 projectionMatrix;\r
\r
// 3D volume texture\r
uniform vec3 volumeDim;    // volume dimensions, pixels\r
uniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r
uniform vec2 tileTexSize;  // size of tiled texture, pixels\r
uniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r
\r
uniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r
uniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r
\r
uniform vec3 _isoLevel0;\r
uniform float _flipV;\r
uniform sampler2D _BFLeft;\r
uniform sampler2D _BFRight;\r
uniform sampler2D _FFLeft;\r
uniform sampler2D _FFRight;\r
uniform sampler2D _WFFLeft;\r
uniform sampler2D _WFFRight;\r
\r
varying vec4 screenSpacePos;\r
\r
#define NO_COLOR vec4(0., 0., 0., 0.)\r
\r
vec4 sample3DTexture(vec3 texCoord) {\r
  // a pair of Z slices is determined by nearest slice border\r
  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r
  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r
  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r
\r
  float rowTiles = floor(tileTexSize.x / tileStride.x);\r
\r
  // calculate coords in tile texture for both slices\r
  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r
  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r
  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r
  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r
\r
  // bilinear filtering\r
  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r
  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r
  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r
  return mix(colorSlice1, colorSlice2, weightSlice2);\r
}\r
\r
vec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r
  vec3 textCoord = boxCoord;\r
  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r
\r
  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r
  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r
    return NO_COLOR;\r
\r
  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r
\r
  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r
  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r
    return NO_COLOR;\r
\r
  return sample3DTexture(textCoord);\r
}\r
\r
float CalcColor(vec3 iter, vec3 dir) {\r
  float d = 1. / 128.;\r
  vec3 dx = vec3(d, 0.0, 0.0);\r
  vec3 dy = vec3(0.0, d, 0.0);\r
  vec3 dz = vec3(0.0, 0.0, d);\r
\r
  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r
  vec3 coordInc = mix(\r
    vec3(\r
      sample3DTextureInclined(iter + dx).x,\r
      sample3DTextureInclined(iter + dy).x,\r
      sample3DTextureInclined(iter + dz).x\r
    ),\r
    vec3(0. ,0. , 0.),\r
    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r
  );\r
\r
  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r
  vec3 coordDec = mix(\r
    vec3(0. ,0. , 0.),\r
    vec3(\r
      sample3DTextureInclined(iter - dx).x,\r
      sample3DTextureInclined(iter - dy).x,\r
      sample3DTextureInclined(iter - dz).x\r
    ),\r
    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r
  );\r
\r
  vec3 N = normalize(coordInc - coordDec);\r
  float dif = max(0.0, dot(N, dir));\r
  return dif;\r
}\r
\r
vec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r
  for (int i = 0; i < 5; i++) {\r
    vec3 iterator = 0.5 * (left + right);\r
    float vol = sample3DTextureInclined(iterator).r;\r
    if ((volLeft - threshold) * (vol - threshold) < 0.)\r
      right = iterator;\r
    else\r
      left = iterator;\r
  }\r
  return 0.5 * (left + right);\r
}\r
\r
vec3 CorrectIso(vec3 left, vec3 right, float tr) {\r
  for (int j = 0; j < 5; j++) {\r
    vec3 iterator = 0.5 * (left + right);\r
    float vol = sample3DTextureInclined(iterator).r;\r
    if (vol < tr)\r
      right = iterator;\r
    else\r
      left = iterator;\r
  }\r
  return 0.5 * (left + right);\r
}\r
\r
vec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r
  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r
  vec3 step = stepSize * dir, iterator = start, left, right;\r
  vec4 acc = NO_COLOR;\r
\r
  for (int i = 0; i < STEPS_COUNT; i++) {\r
    iterator = iterator + step;\r
    vol = sample3DTextureInclined(iterator).r;\r
    if (length(iterator - back) <= stepSize || (vol > tr))\r
      break;\r
  }\r
\r
  if (vol > tr)\r
    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r
\r
  return acc;\r
}\r
\r
float easeOut(float x0, float x1, float x) {\r
  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r
  return 1.0 - (1.0 - t) * (1.0 - t);\r
}\r
\r
float easeIn(float x0, float x1, float x) {\r
  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r
  return t * t;\r
}\r
\r
vec3 GetColSimple(float vol) {\r
  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r
  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r
  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r
}\r
\r
vec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r
  vec4 acc = NO_COLOR, iso;\r
  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r
  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r
  vec3 step, col, colOld, right;\r
  float tr0 = _isoLevel0.x;\r
  float dif, r, kd, finish;\r
  int count = 0, stopMol = 0;\r
\r
  for (int k = 0; k < 3; k++) {\r
    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r
    kd = 140. * tr0 * stepSize;\r
    r = 1. - kd;\r
    step = stepSize * dir;\r
    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r
    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r
      break;\r
    iterator = iso.xyz;\r
    dif = 1.;// CalcColor(iterator, dir);\r
    colOld = GetColSimple(tr0);\r
    curStepSize = stepSize;\r
    for (int i = 0; i < STEPS_COUNT; i++) {\r
      iterator = iterator + step;\r
      molD = length(iterator - start);\r
      vol = sample3DTextureInclined(iterator).r;\r
      finish = distance(iterator, back) - stepSize;\r
      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r
        break;\r
      alpha = (1. - r);\r
      col = GetColSimple(vol);\r
      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r
      vec3 colMid = GetColSimple(vol);\r
      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r
      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r
      colOld = col;\r
    } // for i\r
\r
    if (finish < 0.0 || sumAlpha > 0.97)\r
      break;\r
\r
    if (molD > molDist) {\r
      curStepSize = stepSize - (molD - molDist);\r
      right = iterator - (molD - molDist) * dir;\r
      vol = sample3DTextureInclined(right).r;\r
    } else {\r
      vec3 left = iterator - step;\r
      right = CorrectIso(left, iterator, tr0);\r
      curStepSize = distance(left, right);\r
      vol = tr0;\r
    }\r
\r
    alpha = (1. - r) * curStepSize / stepSize;\r
    dif = 1.;// CalcColor(right, dir);\r
    col = GetColSimple(vol);\r
    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r
    vec3 colMid = GetColSimple(vol);\r
    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r
    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r
\r
    if (molD > molDist)\r
      break;\r
  } // for k\r
  acc.rgb = 1. * sumColor / sumAlpha;\r
  acc.a = sumAlpha;\r
  return acc;\r
}\r
\r
vec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r
  float stepSize = 1.0 / float(STEPS_COUNT);\r
  float len = length(back - start);\r
  vec3 step = stepSize * dir;\r
  vec3 iterator = start;\r
  float acc = 0.0;\r
\r
  for (int i = 0; i < STEPS_COUNT; i++) {\r
    if (float(i) * stepSize > len)\r
      break;\r
    iterator = iterator + step;\r
    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r
      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r
  }\r
\r
  return vec4(1.,1.,1., acc);\r
}\r
\r
vec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r
  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r
  vec4 col = NO_COLOR;\r
\r
  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r
    float dif =  CalcColor(tst.xyz, dir);\r
    dif = 0.9 * dif * dif;\r
    col = vec4(dif, dif, dif, 1);\r
  }\r
  return col;\r
}\r
\r
vec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r
  return sample3DTexture(start);\r
}\r
\r
void main() {\r
  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r
\r
  if (_flipV > 0.0) {\r
    tc.y = 1.0 - tc.y;\r
  }\r
\r
  vec3 start;\r
  vec3 back;\r
  vec3 molBack;\r
  if (projectionMatrix[0][2] < 0.0) {\r
    start = texture2D(_FFLeft, tc.xy).xyz;\r
    back = texture2D(_BFLeft, tc.xy).xyz;\r
    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r
  } else {\r
    start = texture2D(_FFRight, tc.xy).xyz;\r
    back = texture2D(_BFRight, tc.xy).xyz;\r
    molBack = texture2D(_WFFRight, tc.xy).xyz;\r
  }\r
\r
  vec3 dir = normalize(back - start);\r
\r
  float molDist = 2.0;\r
  if (length(molBack) > 0.001) {\r
    molDist = distance(start, molBack);\r
  }\r
\r
  #ifdef ISO_MODE\r
    gl_FragColor = IsoRender(start, back, molDist, dir);\r
  #else\r
    gl_FragColor = VolRender(start, back, molDist, dir);\r
  #endif\r
}\r
`,VP=`varying vec4 volPos;\r
uniform float aspectRatio;\r
uniform float farZ;\r
uniform float tanHalfFOV;\r
uniform mat4  matWorld2Volume;\r
\r
void main() {\r
  // rescale plane to fill in the whole far plane area seen from camera\r
  vec3 pos = position.xyz;\r
  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r
  pos.y = pos.y * tanHalfFOV * farZ;\r
  // common transformation\r
  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r
  // calc pos in volume CS\r
  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r
  // we're assuming local position is in [-0.5, 0.5]\r
  // we need to offset it to be represented in RGB\r
  volPos = volPos + 0.5;\r
  volPos.w = 0.5;\r
}\r
`,BP=`varying vec4 volPos;\r
\r
void main() {\r
  gl_FragColor = volPos;\r
}`,kP=x.UniformsUtils.merge([{volumeDim:{type:"v3",value:new x.Vector3(512,512,512)},tileTex:{type:"t",value:null},tileTexSize:{type:"v2",value:new x.Vector2(512,512)},tileStride:{type:"v2",value:new x.Vector2(512,512)},boxAngles:{type:"v3",value:new x.Vector3(1,1,1)},delta:{type:"v3",value:new x.Vector3(0,0,0)},_isoLevel0:{type:"v2",value:new x.Vector3(.5,.75,1)},_flipV:{type:"f",value:0},_BFLeft:{type:"t",value:null},_BFRight:{type:"t",value:null},_FFLeft:{type:"t",value:null},_FFRight:{type:"t",value:null},_WFFLeft:{type:"t",value:null},_WFFRight:{type:"t",value:null}}]);function Ay(r,e){const t=x.UniformsUtils.clone(e);for(const n in r)t.hasOwnProperty(n)&&(t[n].value=r[n]);return t}function Ey(r,e){return{uniforms:Ay(r,{}),vertexShader:DP,fragmentShader:UP,transparent:!1,depthTest:!1,depthWrite:!1,side:e}}class GP extends x.ShaderMaterial{constructor(e){const t=Ey(e,x.BackSide);super(t)}}class Ty{constructor(e,t,n,i){this.uniforms=Ay(e,t),this.vertexShader=n,this.fragmentShader=i,this.transparent=!1,this.depthTest=!1,this.depthWrite=!1,this.side=x.FrontSide}}class HP extends x.ShaderMaterial{constructor(e){const t=x.UniformsUtils.merge([{aspectRatio:{type:"f",value:0},farZ:{type:"f",value:0},tanHalfFOV:{type:"f",value:0},matWorld2Volume:{type:"4fv",value:new x.Matrix4}}]),n=new Ty(e,t,VP,BP);super(n)}}class WP extends x.ShaderMaterial{constructor(e){const t=Ey(e,x.FrontSide);super(t)}}class XP extends x.ShaderMaterial{constructor(e){const t=new Ty(e,kP,FP,zP);t.transparent=!0,t.depthTest=!0,super(t),this.updateDefines()}updateDefines(){this.defines={ISO_MODE:te.now.modes.VD.isoMode,STEPS_COUNT:te.now.modes.VD.polyComplexity[te.now.resolution]*100},this.needsUpdate=!0}}const Ac={BackFacePosMaterial:GP,BackFacePosMaterialFarPlane:HP,FrontFacePosMaterial:WP,VolumeMaterial:XP};class Zn extends x.Mesh{volumeInfo={};constructor(){const e=new x.BufferGeometry;super(e),this.clipPlane=new x.Plane;const t=new x.Vector3(.5,.5,.5);this.size=t,this.cullFlag=[!0,!0,!0,!0,!0,!0,!0,!0,!1,!1,!1,!1,!1,!1],this.faces=[{indices:[],norm:new x.Vector3(0,0,-1)},{indices:[],norm:new x.Vector3(0,0,1)},{indices:[],norm:new x.Vector3(0,-1,0)},{indices:[],norm:new x.Vector3(0,1,0)},{indices:[],norm:new x.Vector3(-1,0,0)},{indices:[],norm:new x.Vector3(1,0,0)},{indices:[],norm:new x.Vector3(0,0,0)}],this.vertices=[new x.Vector3(-t.x,-t.y,-t.z),new x.Vector3(-t.x,t.y,-t.z),new x.Vector3(t.x,-t.y,-t.z),new x.Vector3(t.x,t.y,-t.z),new x.Vector3(-t.x,-t.y,t.z),new x.Vector3(-t.x,t.y,t.z),new x.Vector3(t.x,-t.y,t.z),new x.Vector3(t.x,t.y,t.z),new x.Vector3(0,0,0),new x.Vector3(0,0,0),new x.Vector3(0,0,0),new x.Vector3(0,0,0),new x.Vector3(0,0,0),new x.Vector3(0,0,0)],e.setAttribute("position",new x.BufferAttribute(new Float32Array(this.vertices.length*3),3)),this.name="VolumeMesh"}static _corners=[[-1,-1,-1,0,4,8],[1,-1,-1,0,5,9],[1,1,-1,1,5,10],[-1,1,-1,1,4,11],[-1,-1,1,2,6,8],[1,-1,1,2,7,9],[1,1,1,3,7,10],[-1,1,1,3,6,11]];static _edges=[[0,1,0,-1,-1],[2,3,0,1,-1],[4,5,0,-1,1],[6,7,0,1,1],[0,3,-1,0,-1],[1,2,1,0,-1],[4,7,-1,0,1],[5,6,1,0,1],[0,4,-1,-1,0],[1,5,1,-1,0],[2,6,-1,1,0],[3,7,1,1,0]];static _edgeIntersections=(function(){const e=[];for(let t=0;t<12;++t)e.push(new x.Vector3);return e})();_updateVertices(){const e=Zn._corners,t=Zn._edges,n=Zn._edgeIntersections;let i;const s=this.clipPlane.normal,o=this.clipPlane.constant,a=this.vertices,{size:l}=this,c=[0,0,0,0,0,0,0,0],h=[1,1,1,1,1,1,1,1,1,1,1,1],u=new x.Vector3;let d=null;function f(){if(s.x===0)return 0;const M=-(s.dot(u)+o)/s.x;return-l.x<=M&&M<=l.x?(d.set(M,u.y,u.z),M===l.x?2:M===-l.x?-2:1):0}function p(){if(s.y===0)return 0;const M=-(s.dot(u)+o)/s.y;return-l.y<=M&&M<=l.y?(d.set(u.x,M,u.z),M===l.y?2:M===-l.y?-2:1):0}function _(){if(s.z===0)return 0;const M=-(s.dot(u)+o)/s.z;return-l.z<=M&&M<=l.z?(d.set(u.x,u.y,M),M===l.z?2:M===-l.z?-2:1):0}for(let M=0;M<12;++M){const E=t[M];d=n[M],u.set(E[2],E[3],E[4]),u.multiply(l);let T=0;E[2]===0&&(T=f()),E[3]===0&&(T=p()),E[4]===0&&(T=_()),T===-2?c[E[0]]=1:T===2?c[E[1]]=1:T===0&&(h[M]=0)}const g={indices:[],norm:s.clone().negate()};let m=8;for(i=0;i<8;++i)c[i]===1&&(a[m].set(e[i][0],e[i][1],e[i][2]).multiply(l),g.indices.push(m++),h[e[i][3]]=0,h[e[i][4]]=0,h[e[i][5]]=0);for(i=0;i<12;++i)h[i]===1&&(a[m].copy(n[i]),g.indices.push(m++));this.faces[6]=g;const v=new x.Vector3,y=new x.Vector3;for(this.clipPlane.coplanarPoint(y),i=0;i<a.length;++i)this.cullFlag[i]=!1,i<8?(v.subVectors(a[i],y),this.cullFlag[i]=s.dot(v)>=0):i<8+g.indices.length&&(this.cullFlag[i]=!0);const S=this.geometry.getAttribute("position");let b=0;for(i=0;i<a.length;++i)S.array[b++]=a[i].x,S.array[b++]=a[i].y,S.array[b++]=a[i].z;S.needsUpdate=!0}_collectVertices(e,t){let n;const i=this.vertices;for(e.indices=[],n=0;n<i.length;++n)this.cullFlag[n]&&t(i[n])&&e.indices.push(n)}_sortIndices(e,t){let n,i;const s=this.vertices,o=[],a=new x.Vector3;for(n=1;n<e.indices.length;++n)a.subVectors(s[e.indices[n]],s[e.indices[0]]),a.normalize(),a.cross(t),a.negate(),o[n]=e.norm.dot(a);for(n=1;n<e.indices.length-1;++n)for(i=n+1;i<e.indices.length;++i)if(o[i]<o[n]){let l=o[n];o[n]=o[i],o[i]=l,l=e.indices[n],e.indices[n]=e.indices[i],e.indices[i]=l}}_updateIndices(){let e,t,n;const i=this.vertices,{size:s}=this;this._collectVertices(this.faces[0],d=>d.z===-s.z),this._collectVertices(this.faces[1],d=>d.z===s.z),this._collectVertices(this.faces[2],d=>d.y===-s.y),this._collectVertices(this.faces[3],d=>d.y===s.y),this._collectVertices(this.faces[4],d=>d.x===-s.x),this._collectVertices(this.faces[5],d=>d.x===s.x);const o=new x.Vector3,a=new x.Vector3,l=new x.Vector3;for(t=0;t<this.faces.length;++t){if(n=this.faces[t],n.indices.length===0)continue;for(o.set(0,0,0),e=0;e<n.indices.length;++e)o.add(i[n.indices[e]]);o.multiplyScalar(1/n.indices.length),a.subVectors(i[n.indices[0]],o),a.normalize();const d=[];for(e=0;e<n.indices.length;++e)l.subVectors(i[n.indices[e]],o),d[e]=l.dot(a);for(e=1;e<n.indices.length;++e)if(d[e]<d[0]){let f=d[0];d[0]=d[e],d[e]=f,[f]=n.indices,n.indices[0]=n.indices[e],n.indices[e]=f}this._sortIndices(n,a)}let c=0;for(t=0;t<this.faces.length;++t)n=this.faces[t],n.indices.length>=3&&(c+=3*(n.indices.length-2));let h=0;const u=new Uint16Array(c);for(t=0;t<this.faces.length;++t)for(n=this.faces[t],e=0;e<n.indices.length-2;++e)u[h]=n.indices[0],u[h+1]=n.indices[e+1],u[h+2]=n.indices[e+2],h+=3;this.geometry.setIndex(new x.BufferAttribute(u,1))}setDataSource(e){const t=new Ac.VolumeMaterial,n=e.getDimensions(),i=e.getTiledTextureStride(),s=e.buildTiledTexture(),o=e.getBox();t.uniforms.volumeDim.value.set(n[0],n[1],n[2]),t.uniforms.tileTex.value=s,t.uniforms.tileTexSize.value.set(s.image.width,s.image.height),t.uniforms.tileStride.value.set(i[0],i[1]),Object.assign(this.volumeInfo,e.getVolumeInfo());const a=this.volumeInfo;t.uniforms.delta.value.copy(a.delta),t.uniforms.boxAngles.value.set(a.obtuseAngle[0],a.obtuseAngle[1],a.obtuseAngle[2]),this.material=t,o.getSize(this.scale),o.getCenter(this.position)}_updateIsoLevel(){const{kSigma:e,kSigmaMed:t,kSigmaMax:n}=te.now.modes.VD,i=this.volumeInfo,s=i.dmean-i.dmin,o=i.dmax-i.dmin,a=l=>(s+l*i.sd)/o;this.material.uniforms._isoLevel0.value.set(a(e),a(t),a(n))}static _nearClipPlaneOffset=.2;static _pos=new x.Vector3;static _norm=new x.Vector3;static _norm4D=new x.Vector4;static _matrixWorldToLocal=new x.Matrix4;static _clipPlane=new x.Plane;rebuild(e){const t=Zn._nearClipPlaneOffset,n=Zn._pos,i=Zn._norm,s=Zn._norm4D,o=Zn._matrixWorldToLocal,a=Zn._clipPlane;this._updateIsoLevel(),e.getWorldDirection(i),e.getWorldPosition(n),n.addScaledVector(i,e.near+t),o.copy(this.matrixWorld).invert(),n.applyMatrix4(o),s.set(i.x,i.y,i.z,0),s.applyMatrix4(o),i.copy(s),i.normalize(),a.setFromNormalAndCoplanarPoint(i,n),this.clipPlane.equals(a)||(this.clipPlane=a.clone(),this._updateVertices(),this._updateIndices())}}const jP=Zn;function YP(r){const e=r.length,t=new Float32Array(e*3);for(let n=0;n<e;++n){const i=3*n,s=r[n];t[i]=s.x,t[i+1]=s.y,t[i+2]=s.z}return t}class Jf{static _projectionTable={XY:["x",2],XZ:["y",1],YZ:["z",0]};constructor(e,t){const{delta:n}=t,{obtuseAngle:i}=t,s=new x.Vector3;e.getSize(s),s.multiplyScalar(.5);const o=this._getBaseVertices(n,i),a=new x.BufferGeometry,l=[];for(let d=0;d<4;d++)l.push(o[d].clone().multiply(s)),l.push(o[(d+1)%4].clone().multiply(s));const c=new x.Vector3(2*s.x*(1-n.x-n.y),0,0);for(let d=0;d<8;d++)l.push(l[d].clone().add(c));for(let d=0;d<4;d++)l.push(l[d*2].clone()),l.push(l[d*2+8].clone());const h=new x.Vector3;e.getCenter(h),l.forEach(d=>d.add(h));const u=YP(l);a.setAttribute("position",new x.BufferAttribute(u,3)),this._lines=new x.LineSegments(a,new x.LineBasicMaterial({color:16777215})),this._lines.layers.set(Je.LAYERS.VOLUME)}_getBaseVertices(e,t){const n=Jf._projectionTable,i=(o,a)=>{const l=e[n[o][0]];return(-.5*(a-1)+a*t[n[o][1]])*l};return[new x.Vector3(-1+2*(i("XZ",1)+i("XY",1)),-1+2*i("YZ",1),-1),new x.Vector3(-1+2*(i("XZ",-1)+i("XY",1)),-1+2*i("YZ",-1),1),new x.Vector3(-1+2*(i("XZ",-1)+i("XY",-1)),1-2*i("YZ",1),1),new x.Vector3(-1+2*(i("XZ",1)+i("XY",-1)),1-2*i("YZ",-1),-1)]}getMesh(){return this._lines}}const qP=Jf;class $P{constructor(e,t,n){const i=this._initPlaneGeo(t,n),s=new Ac.BackFacePosMaterialFarPlane;this._plane=new kn.Mesh(i,s),this._plane.frustumCulled=!1,this._plane.doubleSided=!0;const o=new x.Matrix4;this._plane._onBeforeRender=function(a,l,c,h,u,d){const{material:f}=this;if(!e||!f)return;const p=new x.Vector4(0,0,-(c.far-.1),1);p.applyMatrix4(c.matrixWorld),this.matrix.identity(),this.matrix.makeTranslation(p.x,p.y,p.z),this.matrixWorld.copy(this.matrix),this.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,this.matrixWorld),this.normalMatrix.getNormalMatrix(this.modelViewMatrix);const _=e.matrixWorld;o.copy(_).invert(),f.uniforms.aspectRatio.value=c.aspect,f.uniforms.farZ.value=c.far,f.uniforms.tanHalfFOV.value=Math.tan(x.MathUtils.DEG2RAD*.5*c.fov),f.uniforms.matWorld2Volume.value=o},this._plane.layers.set(Je.LAYERS.VOLUME_BFPLANE)}_initPlaneGeo(e,t){const n=new x.BufferGeometry;e=e||1,t=t||1;const i=new Float32Array([-.5*e,.5*t,0,.5*e,.5*t,0,-.5*e,-.5*t,0,.5*e,-.5*t,0]);return n.setAttribute("position",new x.BufferAttribute(i,3)),n.setIndex([0,2,1,2,3,1]),n}getMesh(){return this._plane}}const ZP=$P;class KP extends _a{constructor(e,t){super(e,t),this._mesh=new jP,this._mesh.setDataSource(t),this.add(this._mesh),this._frame=new qP(this.getBoundaries().boundingBox,this._mesh.volumeInfo),this.add(this._frame.getMesh()),this.showFrame(te.now.modes.VD.frame),this._farPlane=new ZP(this._mesh,2,2),this.add(this._farPlane.getMesh())}getBoundaries(){const e=this._dataSource.getBox(),t=new x.Sphere;return e.getBoundingSphere(t),{boundingBox:e,boundingSphere:t}}getMesh(){return this._mesh}showFrame(e){this._frame.getMesh().material.visible=e}}const Qf=KP;class JP extends ar{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];super(e,["types"])}find(e){let t=[];if(e.type)t=this._dict.types[e.type.toLowerCase()]||[];else if(e.source)return this._list.filter(n=>n.canProbablyLoad&&n.canProbablyLoad(e.source));return[...t]}}const QP=JP;class gh extends Dn{constructor(e,t){super(),this._source=e,this._options=t||{},this._abort=!1,this._agent=null}load(){return Promise.reject(new Error("Loading from this source is not implemented"))}abort(){this._abort=!0,this._agent&&this._agent.abort()}static extractName(e){}}Fa(gh.prototype);class Cy extends gh{constructor(e,t){super(e,t),t=this._options,this._binary=t.binary===!0}load(){return new Promise((e,t)=>{if(this._abort)throw new Error("Loading aborted");const n=this._source,i=this._agent=new FileReader;i.addEventListener("load",()=>{e(i.result)}),i.addEventListener("error",()=>{t(i.error)}),i.addEventListener("abort",()=>{t(new Error("Loading aborted"))}),i.addEventListener("progress",s=>{this.dispatchEvent(s)}),this._binary?i.readAsArrayBuffer(n):i.readAsText(n)})}static canProbablyLoad(e){return File&&e instanceof File||Blob&&e instanceof Blob}static extractName(e){return e&&e.name}}Cy.types=["file","blob"];const eI=/^(https?|ftp):\/\//i;class Ry extends gh{constructor(e,t){super(e,t),t=this._options,this._binary=t.binary===!0}load(){return new Promise((e,t)=>{if(this._abort)throw new Error("Loading aborted");const n=this._source,i=this._agent=new XMLHttpRequest;i.addEventListener("load",()=>{i.status===200?e(i.response):t(new Error(`HTTP ${i.status} while fetching ${n}`))}),i.addEventListener("error",()=>{t(new Error("HTTP request failed"))}),i.addEventListener("abort",()=>{t(new Error("Loading aborted"))}),i.addEventListener("progress",s=>{this.dispatchEvent(s)}),i.open("GET",n),this._binary?i.responseType="arraybuffer":i.responseType="text",i.send()})}static canProbablyLoad(e){return de.default.isString(e)&&eI.test(e)}static extractName(e){if(e){const t=(e.indexOf("?")+1||e.lastIndexOf("#")+1||e.length+1)-1;return e.slice(e.lastIndexOf("/",t)+1,t)}}}Ry.types=["url"];class Py extends gh{load(){return new Promise(e=>{if(this._abort)throw new Error("Loading aborted");e(this._source)})}static canProbablyLoad(e){return!1}}Py.types=["immediate"];const tI=new QP([Cy,Ry,Py]);class nI extends ar{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];super(e,["formats","extensions"])}find(e){let t=[];return e.format?t=this._dict.formats[e.format.toLowerCase()]||[]:e.ext&&(t=this._dict.extensions[e.ext.toLowerCase()]||[]),t.length===0&&!e.format&&e.data?this._list.filter(n=>n.canProbablyParse&&n.canProbablyParse(e.data)):[...t]}}const iI=nI;class Nn{constructor(e,t){this._data=e,this._options=t||{},this._abort=!1}parseSync(){throw new Error("Parsing this type of data is not implemented")}parse(){return new Promise((e,t)=>{setTimeout(()=>{try{return this._abort?t(new Error("Parsing aborted")):e(this.parseSync())}catch(n){return t(n)}})})}getModel(){return this.model._parseHeader(this._data),this.model}abort(){this._abort=!0}}Fa(Nn.prototype);class Iy{constructor(){this.matrices=[],this._matrix=null,this._matrixIndex=-1}parse(e){let t=this._matrix;if(e.readString(12,18)==="  SMTRY"){const n=e.readCharCode(19)-49,i=e.readString(20,80).trim().split(/\s+/),s=parseInt(i[0],10);(this._matrix===null||s!==this._matrixIndex)&&(this._matrixIndex=s,this._matrix=t=new x.Matrix4,this.matrices[this.matrices.length]=t);const{elements:o}=t;o[n]=parseFloat(i[1]),o[n+4]=parseFloat(i[2]),o[n+8]=parseFloat(i[3]),o[n+12]=parseFloat(i[4])}}}Iy.prototype.id=290;const sI=Iy,{Assembly:rI}=Bt;class Ly{constructor(e){this._complex=e,this.assemblies=[],this._assembly=null,this._matrix=null,this._matrixIndex=-1}parse(e){let t=this._assembly,n=this._matrix;if(t&&e.readString(12,18)==="  BIOMT"){const i=e.readCharCode(19)-49,s=e.readString(20,80).trim().split(/\s+/),o=parseInt(s[0],10);(this._matrix===null||o!==this._matrixIndex)&&(this._matrixIndex=o,this._matrix=n=new x.Matrix4,t.addMatrix(n));const{elements:a}=n;a[i]=parseFloat(s[1]),a[i+4]=parseFloat(s[2]),a[i+8]=parseFloat(s[3]),a[i+12]=parseFloat(s[4])}else if(t&&e.readString(35,41)==="CHAINS:"){const i=e.readString(42,80).split(",");for(let s=0,o=i.length;s<o;++s){const a=i[s].trim();a.length>0&&t.addChain(a)}}else e.readString(12,23)==="BIOMOLECULE:"&&(this._matrix=null,this._matrixIndex=-1,this._assembly=t=new rI(this._complex),this.assemblies.push(t))}}Ly.prototype.id=350;const oI=Ly;class aI{constructor(e){this._data=e,this._start=0,this._nextCR=-1,this._nextLF=-1,this._next=-1,this._end=e.length,this.next()}readLine(){return this._data.slice(this._start,this._next)}readChar(e){return e=this._start+e-1,e<this._next?this._data[e]:" "}readCharCode(e){return e=this._start+e-1,e<this._next?this._data.charCodeAt(e):32}readString(e,t){const n=this._start+e-1,i=this._start+t;return this._data.slice(n,i<this._next?i:this._next)}readInt(e,t){return parseInt(this.readString(e,t),10)}readFloat(e,t){return parseFloat(this.readString(e,t))}end(){return this._start>=this._end}next(){const e=this._next+1;this._start=e<this._end?e:this._end,this._start>this._nextCR&&(this._nextCR=(this._data.indexOf("\r",this._start)+1||this._end+1)-1),this._start>this._nextLF&&(this._nextLF=(this._data.indexOf(`
`,this._start)+1||this._end+1)-1),this._next=this._nextCR+1<this._nextLF?this._nextCR:this._nextLF}}const Ny=aI,{Complex:lI,Element:Xg,Helix:cI,Sheet:hI,Strand:uI,Bond:ec,Molecule:dI}=Bt,fI=6;function pI(r){const e=r.trim().length===4;return r.slice(0,e?1:2).trim()}const mI=/^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i,gI={290:sI,350:oI};class Mt extends Nn{constructor(e,t){super(e,t),this._complex=null,this._chain=null,this._residue=null,this._sheet=null,this._serialAtomMap=null,this._modelId=1,this._compaundFound=!1,this._biomoleculeFound=!1,this._allowedChainsIDs=null,this._lastMolId=-1,this._remarks={},this._remark=null,this._molecules=[],this._molecule=null,this._compndCurrToken="",this._options.fileType="pdb"}static canProbablyParse(e){return de.default.isString(e)&&mI.test(e)}_finalize(){this._fixBondsArray(),this._fixChains();const e=this._remarks[290];this._complex.symmetry=de.default.isUndefined(e)?[]:e.matrices;const t=this._remarks[350];this._complex.units=this._complex.units.concat(de.default.isUndefined(t)?[]:t.assemblies),this._finalizeMolecules(),this._complex.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap})}_finalizeMolecules(){const e={};let t;const n=this._complex._chains;for(t=0;t<n.length;++t){const i=n[t],s=i._name;e[s]=i}for(t=0;t<this._molecules.length;t++){const i=this._molecules[t];let s=[];for(let a=0;a<i._chains.length;a++){const l=i._chains[a],c=e[l];s=s.concat(c._residues.slice())}const o=new dI(this._complex,i._name,t+1);o.residues=s,this._complex._molecules[t]=o}}_fixChains(){const e={},t=this._complex;for(let n=0;n<t._chains.length;n++){const i=t._chains[n];e[i._name.charCodeAt(0)]=i}}_fixBondsArray(){const e=this._serialAtomMap={},t=this._complex,n=t._atoms;for(let o=0,a=n.length;o<a;++o){const l=n[o];e[l.serial]=l}const i=t._bonds,{logger:s}=this;for(let o=0,a=i.length;o<a;++o){const l=i[o];l._right<l._left&&s.debug("_fixBondsArray: Logic error."),l._left=e[l._left]||null,l._right=e[l._right]||null}}_parseATOM(e){if(this._modelId!==1)return;const t=e.readCharCode(1)===72,n=t?e.readInt(7,11):e.readInt(6,11);let i=e.readString(13,16);const s=e.readChar(17),o=e.readString(18,20).trim(),a=e.readChar(22),l=e.readInt(23,26),c=e.readChar(27),h=e.readFloat(31,38),u=e.readFloat(39,46),d=e.readFloat(47,54),f=e.readFloat(55,60),p=e.readFloat(61,66),_=e.readString(77,78).trim()||pI(i),g=e.readInt(79,80)||0;if(this.settings.now.nowater&&(o==="HOH"||o==="WAT"))return;i=i.trim();const m=Xg.getByName(_),v=Xg.Role[i];let y=this._chain;(!y||y.getName()!==a)&&(this._chain=y=this._complex.getChain(a)||this._complex.addChain(a),this._residue=null);let S=this._residue;(!S||S.getSequence()!==l||S.getICode()!==c)&&(this._residue=S=y.addResidue(o,l,c));const b=new x.Vector3(h,u,d);S.addAtom(i,m,b,v,t,n,s,f,p,g)}_parseENDMDL(){this._modelId+=1}_parseCONECT(e){const t=e.readInt(7,11),n=e.readInt(12,16),i=e.readInt(17,21),s=e.readInt(22,26),o=e.readInt(27,31),a=this._complex;n&&n>t&&a.addBond(t,n,0,ec.BondType.UNKNOWN,!0),i&&i>t&&a.addBond(t,i,0,ec.BondType.UNKNOWN,!0),s&&s>t&&a.addBond(t,s,0,ec.BondType.UNKNOWN,!0),o&&o>t&&a.addBond(t,o,0,ec.BondType.UNKNOWN,!0)}_parseCOMPND(e){const t=e.readString(11,80),n=t.indexOf(":");if(this._compndCurrToken=n>0?t.substring(0,n).trim():this._compndCurrToken,this._compndCurrToken==="MOL_ID")this._molecule={_index:"",_chains:[]},this._molecule._index=parseInt(t.substring(n+1,t.indexOf(";")),10),this._molecules.push(this._molecule);else if(this._compndCurrToken==="MOLECULE"&&this._molecule!=null)this._molecule._name=t.substring(n+1,t.indexOf(";")).trim();else if(this._compndCurrToken==="CHAIN"&&this._molecule!=null){let i=t.substring(n+1,80).trim();const s=i[i.length-1];(s===";"||s===",")&&(i=i.slice(0,-1)),i=i.replace(/\s+/g,"");const o=i.split(",");this._molecule._chains=this._molecule._chains.concat(o)}}_parseREMARK(e){const t=e.readInt(8,10);let n=this._remarks[t];if(de.default.isUndefined(n)){const i=gI[t];de.default.isFunction(i)&&(this._remarks[t]=n=new i(this._complex))}de.default.isUndefined(n)||n.parse(e)}_parseHELIX(e){const t=[20,22,32,34];this._parseSTRUCTURE(e,t,n=>{this._complex.addHelix(n),this._complex.structures.push(n)})}_parseSHEET(e){const t=[22,23,33,34];this._parseSTRUCTURE(e,t,n=>{this._complex.addSheet(n)})}_parseSTRUCTURE(e,t,n){const c=e.readInt(8,10),h=e.readString(12,14).trim(),u=e.readString(41,70).trim(),d=e.readInt(72,76),f=e.readInt(39,40),p=e.readInt(15,16),_=e.readInt(42,45),g=e.readInt(57,60),m=e.readString(t[0],t[2]+1).charCodeAt(0),v=e.readString(t[2],t[2]+1).charCodeAt(0),y=e.readInt(t[1],t[1]+3);let S=e.readString(t[1]+4,t[1]+4),b=0;S.length>0&&(b=S.charCodeAt(0));const M=e.readInt(t[3],t[3]+3);S=e.readString(t[3]+4,t[3]+4);let E=0;S.length>0&&(E=S.charCodeAt(0));let T,w=this._sheet;if(e.readCharCode(1)===83){w!==null&&w.getName()!==h&&(w=null,this._sheet=null),w===null?(this._sheet=T=new hI(h,p),n(T)):T=w;const A=new uI(T,this._complex.getUnifiedSerial(m,y,b),this._complex.getUnifiedSerial(v,M,E),f,_,g);T.addStrand(A),this._complex.structures.push(A)}else T=new cI(f,this._complex.getUnifiedSerial(m,y,b),this._complex.getUnifiedSerial(v,M,E),c,h,u,d),n(T)}_parseHEADER(e){const{metadata:t}=this._complex;t.classification=e.readString(11,50).trim(),t.date=e.readString(51,59).trim();const n=e.readString(63,66).trim();t.id=n,n&&(this._complex.name=n),t.format="pdb"}_parseTITLE(e){const{metadata:t}=this._complex;t.title=t.title||[];const n=e.readInt(9,10)||1;t.title[n-1]=e.readString(11,80).trim()}static tagParsers={HEADER:Mt.prototype._parseHEADER,"TITLE ":Mt.prototype._parseTITLE,"ATOM  ":Mt.prototype._parseATOM,HETATM:Mt.prototype._parseATOM,ENDMDL:Mt.prototype._parseENDMDL,CONECT:Mt.prototype._parseCONECT,COMPND:Mt.prototype._parseCOMPND,REMARK:Mt.prototype._parseREMARK,"HELIX ":Mt.prototype._parseHELIX,"SHEET ":Mt.prototype._parseSHEET,"ATOM 1":Mt.prototype._parseATOM,"ATOM 2":Mt.prototype._parseATOM,"ATOM 3":Mt.prototype._parseATOM,"ATOM 4":Mt.prototype._parseATOM,"ATOM 5":Mt.prototype._parseATOM,"ATOM 6":Mt.prototype._parseATOM,"ATOM 7":Mt.prototype._parseATOM,"ATOM 8":Mt.prototype._parseATOM,"ATOM 9":Mt.prototype._parseATOM};parseSync(){const e=new Ny(this._data),t=this._complex=new lI;for(;!e.end();){const n=e.readString(1,fI),i=Mt.tagParsers[n];de.default.isFunction(i)&&i.call(this,e),e.next()}if(this._finalize(),this._serialAtomMap=null,this._sheet=null,this._residue=null,this._chain=null,this._complex=null,t.getAtomCount()===0)throw new Error("The data does not contain valid atoms");return t}}Mt.formats=["pdb"];Mt.extensions=[".pdb",".ent"];const _I=Mt,{Complex:Au,Element:Wr,SGroup:yI,Bond:jg}=Bt,xI={A:0,S:1,D:2,T:3},vI=/\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;class ep extends Nn{constructor(e,t){super(e,t),this._complex=null,this._residue=null,this._serialAtomMap=null,this._modelId=1,this._lastMolId=-1,this._readOnlyOneMolecule=!1,this._options.fileType="cml"}static canProbablyParse(e){return de.default.isString(e)&&vI.test(e)}_rebuidBondIndexes(e,t){const n=e.length;for(let i=0;i<n;i++){const s=e[i].id,o=t.length;for(let a=0;a<o;a++){const l=t[a].atomRefs2.split(" ");l[0]===s&&(t[a].start=i),l[1]===s&&(t[a].end=i)}}}_createSGroup(e,t){const n=new yI(e.id,e.fieldData,new x.Vector3(parseFloat(e.x),parseFloat(e.y),0),e.atomRefs,e);e.placement==="Relative"&&(n._center=new x.Vector3(0,0,0)),e.fieldName==="MDLBG_FRAGMENT_CHARGE"&&(n._charge=parseInt(e.fieldData,10)||0),e.fieldName==="MDLBG_FRAGMENT_COEFFICIENT"&&(n._repeat=parseInt(e.fieldData,10)||1),t.push(n)}_extractSGroup(e,t){if(Array.isArray(t)||(t=[]),e)if(Array.isArray(e)){const n=e.length;for(let i=0;i<n;i++)e[i].molecule&&(t=t.concat(this._extractSGroup(e[i].molecule))),this._createSGroup(e[i],t)}else e.molecule&&e.molecule&&(t=t.concat(this._extractSGroup(e.molecule))),this._createSGroup(e,t);return t}_extractSGroups(e,t){const n=this._extractSGroup(e),i=t.length;let s,o;for(s=0;s<i;s++){const _=t[s].id;for(o=0;o<n.length;o++)n[o]._atoms.split(" ")[0]===_&&(t[s].sgroupRef||(t[s].sgroupRef=[]),t[s].sgroupRef.push(n[o]))}let a={},l=null;const c=1e8,h=new x.Vector3(c,c,c),u=new x.Vector3(-c,-c,-c);function d(_){l=a[_],l&&n[o]._atoms.push(l.a)}function f(_){l=a[_],l&&(h.set(Math.min(h.x,l.x),Math.min(h.y,l.y),Math.min(h.z,l.z)),u.set(Math.max(u.x,l.x),Math.max(u.y,l.y),Math.max(u.z,l.z)),d(_))}for(s=0;s<t.length;s++)a[t[s].id]={},a[t[s].id].x=t[s].x2,t[s].x3&&(a[t[s].id].x=t[s].x3),a[t[s].id].x=parseFloat(a[t[s].id].x),a[t[s].id].y=t[s].y2,t[s].y3&&(a[t[s].id].y=t[s].y3),a[t[s].id].y=parseFloat(a[t[s].id].y),a[t[s].id].z="0.0",t[s].z3&&(a[t[s].id].z=t[s].z3),a[t[s].id].z=parseFloat(a[t[s].id].z),a[t[s].id].a=t[s];let p;for(o=0;o<n.length;o++)n[o]._center!==null?(h.set(c,c,c),u.set(-c,-c,-c),p=n[o]._atoms.split(" "),n[o]._atoms=[],p.forEach(f),n[o]._center.addVectors(h,u),n[o]._center.multiplyScalar(.5)):(p=n[o]._atoms.split(" "),n[o]._atoms=[],p.forEach(d));a=null}_traverseData(e){function t(s){return Object.prototype.toString.apply(s)==="[object Array]"}function n(s,o){if(s.nodeName==="#text"&&s.nodeValue.trim()==="")return;const a={};a.xmlNode=s;const l=o[s.nodeName];l?t(l)?o[s.nodeName].push(a):o[s.nodeName]=[l,a]:o[s.nodeName]=a;let c,h;if(s.attributes)for({length:c}=s.attributes,h=0;h<c;h++){const u=s.attributes[h];a[u.nodeName]=u.nodeValue}for({length:c}=s.childNodes,h=0;h<c;h++)n(s.childNodes[h],a)}const i={};return e.childNodes.length&&n(e.childNodes[0],i),i}_findSuitableMolecule(e,t){for(const n in e)if(n!=="xmlNode")if(n==="molecule"){if(e.molecule&&(e.molecule.atomArray&&e.molecule.atomArray.atom&&t.push(e),Array.isArray(e.molecule)))for(let i=0;i<e.molecule.length;i++)e.molecule[i].atomArray&&e.molecule[i].atomArray.atom&&t.push({molecule:e.molecule[i]})}else e[n]&&e[n]!==null&&typeof e[n]=="object"&&this._findSuitableMolecule(e[n],t)}_selectComponents(e){const n=new DOMParser().parseFromString(e,"application/xml"),i=this._traverseData(n);let s;const o=this;function a(h){let u=[];if(h.molecule&&h.molecule.atomArray&&h.molecule.atomArray.atom)Array.isArray(h.molecule.atomArray.atom)?u=h.molecule.atomArray.atom:u.push(h.molecule.atomArray.atom);else if(!h.molecule){const y={};return y.atomLabels=null,y.labelsCount=1,y}h.molecule.molecule&&o._extractSGroups(h.molecule.molecule,u);let d,f=u.length;for(let y=0;y<f;y++)d=u[y],d.edges=[];let p=[];h.molecule.bondArray&&h.molecule.bondArray.bond&&(Array.isArray(h.molecule.bondArray.bond)?p=h.molecule.bondArray.bond:p.push(h.molecule.bondArray.bond));let _;f=p.length,o._rebuidBondIndexes(u,p);function g(y){return _=p[y],d=u[_.start],!d||(d.edges.push(_.end),d=u[_.end],!d)?!1:(d.edges.push(_.start),!0)}for(let y=0;y<f;y++){if(!g(y))continue;const S=_.xmlNode.getAttribute("order"),b=parseInt(S,10);if(p[y].order=0,p[y].type=jg.BondType.UNKNOWN,b>1)p[y].order=b;else{const M=xI[S];M!==void 0&&(p[y].order=M,S==="A"&&(p[y].type=jg.BondType.AROMATIC))}}f=u.length;for(let y=0;y<f;y++)d=u[y],d.edges.sort();const m=o._breadWidthSearch(u,0),v={};return v.atoms=u,v.bonds=p,v.labels=m.atomLabels,v.count=Math.min(1,m.labelsCount),v.curr=-1,v.originalCML=n,v}i.cml?s=i.cml:s=i;const l=[],c=[];return this._findSuitableMolecule(s,c),this._readOnlyOneMolecule&&c.length>1&&c.splice(1,c.length-1),c.forEach(h=>{const u=a(h);u.atoms.length>0&&l.push(u)}),l}_packLabel(e,t){return(t<<16)+e}_unpackLabel(e){return{molId:e>>>16,compId:e&65535}}_breadWidthSearch(e,t){const n=new Array(e.length);let i;for(i=0;i<n.length;i++)n[i]=this._packLabel(0,t);const s=[];let o=0,a=e.length;for(;a>0;){o++;let c=-1;for(i=0;i<n.length;i++)if(this._unpackLabel(n[i]).compId===0){c=i;break}if(c<0)break;for(s.push(e[c]),n[c]=this._packLabel(o,t),a--;s.length>0;){const h=s.shift();if(h)for(let u=0;u<h.edges.length;u++)n[h.edges[u]]!==o&&(s.push(e[h.edges[u]]),n[h.edges[u]]=o,a--)}}const l={};return l.atomLabels=n,l.labelsCount=o,l}_parseBond(e,t,n,i){if(e>=0){const s=[Math.min(e,t),Math.max(e,t)];this._complex.addBond(s[0],s[1],n,i,!0)}}_fixBondsArray(){const e=this._serialAtomMap={},t=this._complex,n=t._atoms;for(let o=0,a=n.length;o<a;++o){const l=n[o];e[l.serial]=l}const i=t._bonds,{logger:s}=this;for(let o=0,a=i.length;o<a;++o){const l=i[o];l._right<l._left&&s.debug("_fixBondsArray: Logic error."),l._left=e[l._left]||null,l._right=e[l._right]||null}}_parseSet(e){const t=this._complex=new Au,n=e,i=n.curr,{atoms:s,labels:o}=n;let a=null,l,c;const h=s.length;function u(p){p.xmlNodeRef=a,a.x2&&(a.x3=a.x2,delete a.x2),a.y2&&(a.y3=a.y2,delete a.y2),a.z3||(a.z3="0.0"),a.complexAtom=p}let d={};const f=[];for(l=0;l<h;l++)f.push(l);for(f.sort((p,_)=>o[p]-o[_]),l=0;l<h;l++){const _=o[f[l]];if(this._unpackLabel(_).molId===this._unpackLabel(i).molId){a=s[f[l]];const g=a.elementType;if(a.sgroupRef){const m=a.sgroupRef.length;for(let v=0;v<m;++v)t._sgroups.push(a.sgroupRef[v])}if(a.x3||a.x2){const m=this._unpackLabel(_).compId,v=" ",y=m,S=" ";let b=m.toString();b.length===1&&(b=`0${b}`);const M=`N${b}`;let E=d[v];(!E||E.getName()!==v)&&(d[v]=E=this._complex.getChain(v)||this._complex.addChain(v),this._residue=null);let T=this._residue;(!T||T.getSequence()!==y||T.getICode()!==S)&&(this._residue=T=E.addResidue(M,y,S));let w=null;a.x3?w=new x.Vector3(parseFloat(a.x3),parseFloat(a.y3),parseFloat(a.z3)):a.x2&&(w=new x.Vector3(parseFloat(a.x2),parseFloat(a.y2),0));let A=Wr.ByName[a.elementType.toUpperCase()];A||(A=JSON.parse(JSON.stringify(Wr.ByName[Object.keys(Wr.ByName)[Object.keys(Wr.ByName).length-1]])),A.number+=1,A.name=a.elementType.toUpperCase(),A.fullName="Unknown",Wr.ByName[a.elementType.toUpperCase()]=A);const D=parseInt(a.id.replace(/[^0-9]/,""),10),k=T.addAtom(g,A,w,Wr.Role.SG,!0,D," ",1,0,0);a.hydrogenCount&&(k.hydrogenCount=parseInt(a.hydrogenCount,10)),a.mrvValence&&(k.valence=parseInt(a.mrvValence,10)),u(k)}}}for(d=null,l=0;l<n.bonds.length;l++){const p=n.bonds[l];if(this._unpackLabel(o[p.start]).molId===this._unpackLabel(i).molId&&this._unpackLabel(o[p.end]).molId===this._unpackLabel(i).molId){if(a=s[p.start],!a||!s[p.end])continue;this._parseBond(parseInt(a.id.replace(/[^0-9]/,""),10),parseInt(s[p.end].id.replace(/[^0-9]/,""),10),p.order,p.type)}}for(l=0;l<this._complex.getSGroupCount();l++){const p=this._complex.getSGroups()[l];for(c=0;c<p._atoms.length;c++)p._atoms[c]=p._atoms[c].complexAtom}for(l=0;l<h;l++)this._unpackLabel(o[l]).molId===this._unpackLabel(i).molId&&(a=s[l],a.complexAtom=null,delete a.complexAtom);return this._complex.originalCML=n.originalCML,this._fixBondsArray(),t.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap}),this._serialAtomMap=null,this._complex=null,t}parseSync(){const e=[],t=this;this._selectComponents(this._data).forEach(s=>{s.curr=2,s.count===0&&(s.count=1);for(let o=0;o<s.count;o++)s.curr=o+1,e.push(t._parseSet(s,!1))});let i=0;if(e.forEach(s=>{i+=s.getAtomCount()}),i<=0)throw new Error("The data does not contain valid atoms");if(e.length>1){const s=new Au;return s.joinComplexes(e),s.originalCML=e[0].originalCML,s}return e.length===1?e[0]:new Au}}ep.formats=["cml"];ep.extensions=[".cml"];const SI=ep;var bI=xn(660),Yg=xn.n(bI);const{Complex:wI,Chain:MI,Atom:AI,Element:qg,Helix:EI,Sheet:TI,Strand:CI,Bond:RI,Assembly:PI,Molecule:II}=Bt;class Pd{constructor(e){this._original=Array.from(e),this._original.sort(),this._sum=0;for(let t=0;t<this._original.length;++t)this._sum+=this._original[t]}compare(e){const t=e.length;if(t!==this._original.length)return!1;let n=0,i;for(i=0;i<t;++i)n+=e[i];if(n!==this._sum)return!1;const s=Array.from(e);for(s.sort(),i=0;i<t;++i)if(s[i]!==this._original[i])return!1;return!0}}Pd.prototype.constructor=Pd;const is=Ln.Type,LI=[is.HELIX_PI,is.BEND,is.HELIX_ALPHA,is.STRAND,is.HELIX_310,is.BRIDGE,is.TURN,is.COIL];function NI(r){return new Uint8Array(r,0,1)[0]}class _h extends Nn{constructor(e,t){super(e,t),this._options.fileType="mmtf"}static canProbablyParse(e){return de.default.isArrayBuffer(e)&&(NI(e)|1)===223}_onModel(e){}_onChain(e){if(e.modelIndex!==0)return;const t=new MI(this._complex,e.chainName);this._complex._chains[e.chainIndex]=t,t._index=e.chainIndex}_onGroup(e){if(e.modelIndex!==0||this.settings.now.nowater&&(e.groupName==="HOH"||e.groupName==="WAT"))return;const t=this._complex._chains[e.chainIndex],n=e.insCode.charCodeAt(0)?e.insCode:"",i=t.addResidue(e.groupName,e.groupId,n);i._index=e.groupIndex,this._updateSecStructure(this._complex,i,e)}_onAtom(e){if(e.modelIndex!==0)return;const t=e.altLoc.charCodeAt(0)?e.altLoc:"",n=new AI(e.groupIndex,e.atomName,qg.getByName(e.element.toUpperCase()),new x.Vector3(e.xCoord,e.yCoord,e.zCoord),qg.Role[e.atomName],!1,e.atomId,t,e.occupancy,e.bFactor,e.formalCharge);this._complex._atoms[e.atomIndex]=n,n.index=e.atomIndex,this._serialAtomMap[e.atomId]=n}_onBond(e){const t=Math.max(e.atomIndex1,e.atomIndex2);if(t>=this._complex._atoms.length)return;const n=Math.min(e.atomIndex1,e.atomIndex2);this._complex.addBond(this._complex._atoms[n],this._complex._atoms[t],e.bondOrder,RI.BondType.UNKNOWN,!0)}_updateSecStructure(e,t,n){const i=[3,-1,1,-1,5];if(!de.default.isUndefined(n)&&n.secStruct===this._ssType){t._secondary=this._ssStruct,this._ssStruct&&(this._ssStruct.term=t);return}if(!de.default.isUndefined(n)){const s=LI[n.secStruct];this._ssType=n.secStruct,this._ssStart=t;let o=null;switch(this._ssType){case-1:case 7:break;case 0:case 2:case 4:o=new EI(i[this._ssType],t,t,0,"","",0),e._helices.push(o);break;case 3:{const a=new TI("",0);e._sheets.push(a),o=new CI(a,t,t,0,null,null);break}default:s!==void 0&&(o=new Ln(s,t,t));break}this._ssStruct=o,t._secondary=o,o&&e.structures.push(o)}}_updateMolecules(e){const t=e.entityList;if(!t)return;const n=e.chainsPerModel[0];for(let i=0;i<t.length;i++){const s=t[i],o=s.chainIndexList;let a=[];for(let c=0;c<o.length;c++){const h=o[c];if(h>=n)continue;const u=this._complex._chains[h];a=a.concat(u._residues.slice())}const l=new II(this._complex,s.description,i+1);l.residues=a,this._complex._molecules[i]=l}}_traverse(e){const t=this,{metadata:n}=this._complex;n.id=e.structureId,n.title=[],n.title[0]=e.title,n.date=e.releaseDate,n.format="mmtf";const i={onModel(s){t._onModel(s)},onChain(s){t._onChain(s)},onGroup(s){t._onGroup(s)},onAtom(s){t._onAtom(s)},onBond(s){t._onBond(s)}};this._ssType=-1,this._ssStruct=null,this._ssStart=null,Yg().traverse(e,i),this._updateSecStructure(this._complex),this._updateMolecules(e)}_linkAtomsToResidues(){for(let e=0;e<this._complex._atoms.length;++e){const t=this._complex._atoms[e],n=this._complex._residues[t.residue];t.residue=n,n._atoms.push(t)}}_findSynonymousChains(){const e={};for(let t=0;t<this._complex._chains.length;++t){const n=this._complex._chains[t],i=n.getName();e.hasOwnProperty(i)||(e[i]=[]),e[i].push(n._index)}return e}_parseAssemblyInfo(e){let t,n,i;const s=[],{logger:o}=this;for(t=0;t<e.bioAssemblyList.length;++t){const a=e.bioAssemblyList[t];if(a.transformList.length===0)continue;const l=a.transformList[0].chainIndexList,c=new Pd(l),h={};for(n=0;n<l.length;++n)h[this._complex._chains[l[n]].getName()]=1;const u=[];let d;for(d in h)h.hasOwnProperty(d)&&Array.prototype.push.apply(u,this._chainsByName[d]);c.compare(u)||o.debug("MMTF: Assembly is missing some of the synonymous chains. Skipping...");const f=new PI(this._complex);for(d in h)h.hasOwnProperty(d)&&f.addChain(d);for(f.addMatrix(new x.Matrix4().fromArray(a.transformList[0].matrix).transpose()),n=1;n<a.transformList.length;++n){const p=a.transformList[n];if(!c.compare(p.chainIndexList)){o.debug("MMTF: Chain lists differ for different transforms in one assembly. Skipping...");continue}const _=new x.Matrix4().fromArray(p.matrix).transpose();for(i=0;i<f.matrices.length&&!f.matrices[i].equals(_);++i);i===f.matrices.length&&f.addMatrix(_)}f.finalize(),s.push(f)}return s}_markHeteroAtoms(e){const t=e.chainsPerModel[0];for(let n=0;n<e.entityList.length;++n){const i=e.entityList[n];if(i.type!=="polymer")for(let s=0;s<i.chainIndexList.length;++s){const o=i.chainIndexList[s];if(o>=t)continue;const a=this._complex._chains[o];for(let l=0;l<a._residues.length;++l){const c=a._residues[l];for(let h=0;h<c._atoms.length;++h)c._atoms[h].het=!0}}}}_joinSynonymousChains(){let e,t;const n=[],i={};for(e=0;e<this._complex._chains.length;++e){const s=this._complex._chains[e],o=s.getName();if(!i.hasOwnProperty(o)){i[o]=s,s._index=n.length,n.push(s);continue}const a=i[o];for(t=0;t<s._residues.length;++t){const l=s._residues[t];a._residues.push(l),l._chain=a}}this._complex._chains=n}parseSync(){const e=Yg().decode(this._data);return this._complex=new wI,this._serialAtomMap={},this._traverse(e),this._linkAtomsToResidues(),this._markHeteroAtoms(e),this._chainsByName=this._findSynonymousChains(),Array.prototype.push.apply(this._complex.units,this._parseAssemblyInfo(e)),this._joinSynonymousChains(),this._complex.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap}),this._complex}}_h.formats=["mmtf"];_h.extensions=[".mmtf"];_h.binary=!0;const OI=_h;class tp extends Error{constructor(e,t,n){super(`data:${t}:${n}: ${e}`),Error.captureStackTrace&&Error.captureStackTrace(this,tp),this.name="ParsingError",this.parseLine=t,this.parseColumn=n}}const qn=tp;function Ds(r){return r===32||r===10||r===13||r===9}function Eu(r,e,t){const n=e.length;let i=-1;for(;t<n&&(i=e.charCodeAt(t),!(i===r||i===10));)++t;return i===r?t:-1}function DI(r){let e=0,t=0;const n=r.length;let i=NaN,s=!0,o=1,a=1,l,c=0;const h={};let u={},d=[],f=0,p="",_=[],g=0,m;function v(){let b;if((i===46||i===63)&&(e+1>=n||Ds(r.charCodeAt(e+1)))){++a,++e;return}if(s&&i===59){t=e;let E=0;do{if(t=Eu(10,r,t+1),t===-1)throw new qn("Unterminated text block found",o,a);++E}while(t+1<n&&r.charCodeAt(t+1)!==i||t+1>=n);return b=r.substring(e+1,t).replace(/\r/g,""),e=t+2,o+=E,a=1,s=!1,b}if(i===39||i===34){t=e;do if(t=Eu(i,r,t+1),t===-1)throw new qn("Unterminated quoted string found",o,a);while(t+1<n&&!Ds(r.charCodeAt(t+1)));return b=r.substring(e+1,t),a+=t-e+1,e=t+1,b}for(t=e;t<n&&!Ds(r.charCodeAt(t));)++t;b=r.substring(e,t),a+=t-e,e=t;const M=Number(b);return Number.isNaN(M)?b:M}function y(b){d[f++]=b}function S(b){const M=g%f;return _[M].push(b),++g,b}for(;e<=n;){if(i=r.charCodeAt(e),i!==13)if(i===10)s=!0,++o,a=1;else{if(!(i===32||i===9))if(i===35){if(e=Eu(10,r,e+1),e===-1)break;continue}else if(c===0)if((i===68||i===100)&&r.substr(e+1,4).toLowerCase()==="ata_"){for(t=e+5,l=t;t<n&&!Ds(r.charCodeAt(t));)++t;if(a+=t-e,e=t,l<e){h[r.substring(l,e)]=u={},c=1;continue}else throw new qn("Data block name missing",o,a)}else{if(Number.isNaN(i))break;throw new qn(`Unexpected character in state ${c}`,o,a)}else if(c===1)if((i===68||i===100)&&r.substr(e+1,4).toLowerCase()==="ata_"){c=0;continue}else if(i===95){for(t=e+1,l=t;t<n&&!Ds(r.charCodeAt(t));)++t;if(a+=t-e,e=t,l<e){p=r.substring(l,e),c=2;continue}else throw new qn("Tag name missing",o,a)}else if((i===76||i===108)&&r.substr(e+1,4).toLowerCase()==="oop_"){if(e+=5,a+=5,e<n&&!Ds(r.charCodeAt(e)))throw new qn(`Unexpected character in state ${c}`,o,a);d=[],f=0,_=[],g=0,c=3;continue}else{if(Number.isNaN(i))break;throw new qn(`Unexpected character in state ${c}`,o,a)}else if(c===2){if(Number.isNaN(i))break;m=v(),de.default.set(u,p,m),c=1;continue}else if(c===3)if(i===95){for(t=e+1,l=t;t<n&&!Ds(r.charCodeAt(t));)++t;if(a+=t-e,e=t,l<e){y(r.substring(l,e));continue}else throw new qn("Tag name missing",o,a)}else{if(f>0){for(let b=0;b<f;++b)m=[],_[b]=m,de.default.set(u,d[b],m);c=4;continue}throw new qn("Data tags are missing inside a loop",o,a)}else if(c===4){(i===68||i===100)&&r.substr(e+1,4).toLowerCase()==="ata_"?c=0:i===95||(i===76||i===108)&&r.substr(e+1,4).toLowerCase()==="oop_"?c=1:Number.isNaN(i)?c=0:S(v());continue}else throw new qn(`Unexpected internal state ${c}`,o,a);s=!1,++a}++e}if(c===2)throw new qn(`Unexpected end of file in state ${c}`,o,a);return h}const{Complex:UI,Element:$g,Helix:FI,Sheet:zI,Strand:VI,Assembly:BI,Molecule:kI}=Bt,Tu=["auth_seq_id","Cartn_x","Cartn_y","Cartn_z","label_atom_id"],GI={helx:"helix",turn:"turn",strn:"strand"};function HI(r){const e=/[A-Za-z]+/.exec(r);return e?GI[e[0].toLowerCase()]:null}function nt(r){return r==null||de.default.isArray(r)?r:[r]}function WI(r){const e=r.trim().length===4;return r.slice(0,e?1:2).trim()}class Zg extends Error{constructor(e){super(),this.name="AtomDataError",this.message=e}}function XI(r){if(!r)return null;const e=nt(r.id),{matrix:t,vector:n}=r;if(!e||!t||!n)return null;const i=[];for(let s=0,o=e.length;s<o;++s){const a=new x.Matrix4,{elements:l}=a;for(let c=0;c<3;++c){const h=t[c+1];l[c]=nt(h[1])[s],l[c+4]=nt(h[2])[s],l[c+8]=nt(h[3])[s],l[c+12]=nt(n[c+1])[s]}i[e[s]]=a}return i}function jI(r,e){r=de.default.isString(r)?r:`${r}`;const n=r.replace(/\)\s*\(/g,"!").replace(/[()']/g,"").split("!"),i=[];for(let l=0,c=n.length;l<c;++l){const h=n[l].split(","),u=[];let d=0;for(let f=0,p=h.length;f<p;++f){const _=h[f];if(_.includes("-")){const g=_.split("-");let m=parseInt(g[0],10);const v=parseInt(g[1],10);for(;m<=v;++m)u[d++]=e[m]}else u[d++]=e[_]}i.push(u)}const s=[];let o=0;function a(l,c){for(let h=0,u=i[l].length;h<u;++h){const d=c?c.clone():new x.Matrix4;d.multiplyMatrices(i[l][h],d),l===0?s[o++]=d:a(l-1,d)}}return a(i.length-1),s}class np extends Nn{constructor(e,t){super(e,t),this.asymDict={},this.molecules=[],this._options.fileType="cif"}static canProbablyParse(e){return de.default.isString(e)&&/^\s*data_/i.test(e)}parseSync(){this.logger.info("Parsing CIF file..");const e=DI(this._data);return this._toComplex(e)}_toComplex(e){const t=new UI,n=e[Object.keys(e)[0]];return this._extractAtoms(t,n),this._extractSecondary(t,n),this._extractAssemblies(t,n),this._extractMolecules(t,n),this._extractMetadata(t,n),t.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing}),t}_extractMetadata(e,t){const{metadata:n}=e;n.id=t.entry.id,n.classification=t.struct_keywords.pdbx_keywords;const i=t.database_PDB_rev;n.date=i&&i.date_original?i.date_original:"",n.format="cif",n.title=[],n.title[0]=t.struct.title}_extractMolecules(e,t){const n=t.entity,i=nt(n.pdbx_description),s=i.length;let o;for(o=0;o<s;o++)this.molecules[o]?this.molecules[o].name=i[o]:this.molecules[o]={name:i[o],residues:[]};const a=e.getMolecules();for(o=0;o<s;o++){const l=this.molecules[o];a[o]=new kI(e,l.name,o+1),a[o].residues=l.residues}}_extractAtoms(e,t){const n=t.atom_site;if(!n)throw new Zg("CIF parsing error: atom_site is not specified!");for(let A=0,D=Tu.length;A<D;++A)if(!n[Tu[A]])throw new Zg(`CIF parsing error: requires field ${Tu[A]} not found!`);const{asymDict:i}=this,s=nt(n.auth_seq_id),o=nt(n.Cartn_x),a=nt(n.Cartn_y),l=nt(n.Cartn_z),c=nt(n.label_atom_id),h=c.length,u=nt(n.group_PDB)||[],d=nt(n.auth_asym_id)||[],f=nt(n.label_asym_id)||[],p=nt(n.id)||[],_=nt(n.pdbx_PDB_ins_code)||[],g=nt(n.label_comp_id)||[],m=nt(n.type_symbol)||[],v=nt(n.B_iso_or_equiv)||[],y=nt(n.occupancy)||[],S=nt(n.pdbx_formal_charge)||[],b=nt(n.label_alt_id)||[],M=nt(n.pdbx_PDB_model_num)||[],E=nt(n.label_entity_id)||[];let T=null,w=null;for(let A=0;A<h;++A){if((M[A]||1)!==1)continue;const k=String(d[A]||" ");(!T||T.getName()!==k)&&(T=e.getChain(k)||e.addChain(k)),i[String(f[A]||" ")]=k;const G=s[A],P=String(_[A]||" "),N=String(g[A]||"");if(!w||w.getSequence()!==G||w.getICode()!==P){w=T.addResidue(N,G,P);const Ee=E[A]-1;let Ne=this.molecules[Ee];Ne||(this.molecules[Ee]={name:"",residues:[]},Ne=this.molecules[Ee]),Ne.residues.push(w)}const B=c[A],H=m[A]||WI(B),W=$g.getByName(H),$=$g.Role[B.trim()],oe=new x.Vector3(o[A],a[A],l[A]),Se=u[A]==="HETATM"||!1,K=p[A]||A,ce=v[A]||0,Z=y[A]||0,_e=String(b[A]||""),xe=S[A]||0;w.addAtom(B,W,oe,$,Se,K,_e,Z,ce,xe)}}_extractSecondary(e,t){t.struct_conf&&this._extractConfs(e,t.struct_conf),t.struct_sheet_range&&this._extractSheets(e,t.struct_sheet_range)}_extractSheets(e,t){const{asymDict:n}=this;if(!t.sheet_id||!t.id||!t.beg_label_seq_id||!t.end_label_seq_id||!t.beg_label_asym_id)return;const i=e._sheets;function s(f){const p=i.length;for(let _=0;_<p;++_)if(i[_]._name===f)return i[_];return i[p]=new zI(f,0),i[p]}const o=nt(t.sheet_id),a=nt(t.id),l=nt(t.beg_auth_seq_id),c=nt(t.end_auth_seq_id),h=nt(t.beg_label_asym_id),u=nt(t.pdbx_beg_PDB_ins_code)||[],d=nt(t.pdbx_end_PDB_ins_code)||[];for(let f=0,p=a.length;f<p;++f){const _=e.getChain(n[h[f]]),g=s(o[f]),m=l[f],v=c[f],y=u[f]||" ",S=d[f]||" ",b=_.findResidue(m,y),M=_.findResidue(v,S);if(!b||!M)continue;const E=new VI(g,b[0],M[0],0,null,null),T=_.getResidues();for(let w=b[1];w<=M[1];++w)T[w]._secondary=E;g.addStrand(E),e.structures.push(E)}}_extractConfs(e,t){const{asymDict:n}=this;if(!t.conf_type_id||!t.beg_label_seq_id||!t.end_label_seq_id||!t.beg_label_asym_id)return;const i=nt(t.conf_type_id),s=nt(t.beg_auth_seq_id),o=nt(t.pdbx_beg_PDB_ins_code)||[],a=nt(t.end_auth_seq_id),l=nt(t.pdbx_end_PDB_ins_code)||[],c=nt(t.details)||[],h=nt(t.pdbx_PDB_helix_length)||[],u=nt(t.pdbx_PDB_helix_class)||[],d=nt(t.id)||[],f=nt(t.beg_label_asym_id);for(let p=0,_=i.length;p<_;++p){const g=HI(i[p]);if(!g)continue;const m=d[p]||i[p],v=e.getChain(n[f[p]]),y=s[p],S=a[p],b=o[p]||" ",M=l[p]||" ",E=v.findResidue(y,b),T=v.findResidue(S,M);if(!E||!T)continue;const w=c[p]||"",A=h[p]||0,D=u[p]||" ";let k;if(g==="helix"){const P=e._helices.length;k=new FI(D,E[0],T[0],P,m,w,A),e.addHelix(k),e.structures.push(k)}else g==="turn"?(k=new Ln(Ln.Type.TURN,E[0],T[0]),e.structures.push(k)):k=null;if(!k)continue;const G=v.getResidues();for(let P=E[1];P<=T[1];++P)G[P]._secondary=k}}_extractAssemblies(e,t){const{asymDict:n}=this,i=t.pdbx_struct_assembly_gen;if(!i)return;const s=nt(i.assembly_id),o=nt(i.oper_expression),a=nt(i.asym_id_list);if(!s||!o||!a)return;const l=XI(t.pdbx_struct_oper_list);if(l)for(let c=0,h=s.length;c<h;++c){const u=new BI(e),d=jI(o[c],l),f=a[c].split(",");for(let p=0,_=f.length;p<_;++p){const g=f[p].trim();g.length>0&&u.addChain(n[g])}u.matrices=d,e.units.push(u)}}}np.formats=["cif","mmcif"];np.extensions=[".cif",".mmcif"];const YI=np,pt={singular:0,vector:1,array:2,buffer:3};class qI{_xyz2crs=[];_origin=new x.Vector3(0,0,0);constructor(){this._header={},this._boxSize=new x.Vector3,this._boxStart=new x.Vector3,this._header.delta={},this._header.extent=[],this._header.nstart=[],this._header.grid=[],this._header.crs2xyz=[],this._header.cellDims=new x.Vector3,this._header.angles=[],this._header.origin=new x.Vector3(0,0,0),this._header.dmin=0,this._header.dmean=0,this._header.dmax=0}_typedCheck(){if(de.default.isTypedArray(this._buff))this._buff=this._buff.buffer;else if(!de.default.isArrayBuffer(this._buff))throw new TypeError("Expected ArrayBuffer or TypedArray")}_fillHeader(e,t){for(const n in e)if(e.hasOwnProperty(n))switch(e[n][0]){case pt.singular:this._header[n]=t[e[n][1]][e[n][2]];break;case pt.array:this._parseArray(this._header[n],t[e[n][1]],e[n][2]);break;case pt.vector:this._parseVector(this._header[n],t[e[n][1]],e[n][2]);break;case pt.buffer:this._header[n]=new Uint8Array(t[e[n][1]],[e[n][2]]*4,[e[n][3]]*4);break}}_parseVector(e,t,n){[e.x,e.y,e.z]=[t[n],t[n+1],t[n+2]]}_parseArray(e,t,n){e[0]=t[n],e[1]=t[n+1],e[2]=t[n+2]}_parseHeader(e){}_setAxisIndices(){}_setOrigins(){}_getAxis(){const e=this._header,t=e.cellDims.x/e.grid[0],n=e.cellDims.y/e.grid[1],i=e.cellDims.z/e.grid[2],[s,o,a]=e.angles,l=Math.cos(o),c=(Math.cos(s)-Math.cos(o)*Math.cos(a))/Math.sin(a),h=Math.sqrt(1-l*l-c*c),u=new x.Vector3(t,0,0),d=new x.Vector3(Math.cos(a)*n,Math.sin(a)*n,0),f=new x.Vector3(l*i,c*i,h*i);return[u,d,f]}_getXYZdim(){return[this._header.extent[this._xyz2crs[0]],this._header.extent[this._xyz2crs[1]],this._header.extent[this._xyz2crs[2]]]}_getVolumeInfo(){const e=de.default.pick(this._header,["dmean","dmin","dmax","sd","delta"]);return e.obtuseAngle=this._header.angles.map(t=>+(t>=Math.PI/2)),e}_setBoxParams(e,t,n){let i=0,s=0;const[o,a,l]=this._header.angles;l>=Math.PI/2&&(i+=Math.abs(t.x)),a>=Math.PI/2&&(i+=Math.abs(n.x)),o>=Math.PI/2&&(s+=Math.abs(n.y)),this._boxStart=new x.Vector3(this._origin.x-i,this._origin.y-s,this._origin.z),this._boxSize=new x.Vector3(Math.abs(e.x)+Math.abs(t.x)+Math.abs(n.x),Math.abs(t.y)+Math.abs(n.y),Math.abs(n.z));const c=(h,u)=>Math.abs(h[u])/this._boxSize[u];this._header.delta.x=c(t,"x"),this._header.delta.y=c(n,"x"),this._header.delta.z=c(n,"y")}_getXYZbox(){return new x.Box3(this._boxStart.clone(),this._boxStart.clone().add(this._boxSize))}_toXYZData(){}parse(e){return this._parseHeader(e),this._setOrigins(),new q0(Float32Array,this._getXYZdim(),this._getXYZbox(),1,this._toXYZData(),this._getVolumeInfo())}}const Oy=qI,$I={extent:[pt.array,"u32",0],type:[pt.singular,"u32",3],nstart:[pt.array,"i32",4],grid:[pt.array,"u32",7],cellDims:[pt.vector,"f32",10],angles:[pt.array,"f32",13],crs2xyz:[pt.array,"i32",16],dmin:[pt.singular,"f32",19],dmax:[pt.singular,"f32",20],dmean:[pt.singular,"f32",21],ispg:[pt.singular,"u32",22],nsymbt:[pt.singular,"u32",23],lksflg:[pt.singular,"u32",24],customData:[pt.buffer,"buffer",25,9],origin:[pt.vector,"f32",34],map:[pt.buffer,"buffer",52,1],machine:[pt.singular,"u32",53],sd:[pt.singular,"f32",54],nlabel:[pt.singular,"f32",55],label:[pt.buffer,"buffer",56,200]};class ZI extends Oy{_parseHeader(e){this._buff=e,this._typedCheck();const t={};t.u32=new Uint32Array(this._buff,0,56),t.i32=new Int32Array(this._buff,0,56),t.f32=new Float32Array(this._buff,0,56),t.buffer=this._buff;const n=this._header;this._fillHeader($I,t),n.angles.forEach((i,s,o)=>{o[s]*=Math.PI/180})}_setAxisIndices(){const e=this._header;e.cellDims.x===0&&e.cellDims.y===0&&e.cellDims.z===0&&e.cellDims.set(1,1,1);const{crs2xyz:t}=this._header;t[0]===0&&t[1]===0&&t[2]===0&&(t[0]=1,t[1]=2,t[2]=3);const n=this._xyz2crs;n[t[0]-1]=0,n[t[1]-1]=1,n[t[2]-1]=2}_setOrigins(){const[e,t,n]=this._getAxis();this._setAxisIndices();const i=this._header,s=this._xyz2crs;if(i.origin.x===0&&i.origin.y===0&&i.origin.z===0?(this._origin.addScaledVector(e,i.nstart[s[0]]),this._origin.addScaledVector(t,i.nstart[s[1]]),this._origin.addScaledVector(n,i.nstart[s[2]])):this._origin=i.origin,e.multiplyScalar(i.extent[s[0]]-1),t.multiplyScalar(i.extent[s[1]]-1),n.multiplyScalar(i.extent[s[2]]-1),i.type===2)this._data=new Float32Array(this._buff,1024+i.nsymbt,i.extent[0]*i.extent[1]*i.extent[2]);else throw new Error(`CCP4: Unsupported format ${i.type}`);this._setBoxParams(e,t,n)}_toXYZData(){const e=this._header,t=this._data,n=this._xyz2crs,i=new Float32Array(t.length),s=this._getXYZdim(),o=s[0],a=s[1];let l=0;const c=[];let h,u,d;for(c[2]=0;c[2]<e.extent[2];c[2]++)for(c[1]=0;c[1]<e.extent[1];c[1]++)for(c[0]=0;c[0]<e.extent[0];c[0]++,l++)h=c[n[0]],u=c[n[1]],d=c[n[2]],i[h+o*(u+a*d)]=t[l];return i}}class yh extends Nn{constructor(e,t){super(e,t),this._options.fileType="ccp4",this.model=new ZI}static canProbablyParse(e){return!1}parseSync(){return this.model.parse(this._data)}}yh.formats=["ccp4"];yh.extensions=[".ccp4",".map",".mrc"];yh.binary=!0;const KI=yh,{Complex:JI,Element:QI,Molecule:eL}=Bt;class tL extends Nn{constructor(e,t){super(e,t),this._complex=null,this._atomsInf=null,this._options.fileType="xyz",this._fileName=t.name}static canProbablyParse(e){return de.default.isString(e)&&/^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(e)}_parseToAtomsInf(e){const t=e.indexOf(`
`),n=parseInt(e.substring(0,t),10),i=e.indexOf(`
`,t+1);let s=e.slice(t+1,i).trim();s.length===0&&(s=this._fileName);const o=i+e.substring(i).search(/\S/);if(this._atomsInf=e.substring(o).split(/[\s,]*\n[\s,]*/),!Number.isNaN(n)&&this._atomsInf.length-1!==n){this._complex.error={message:"wrong number of atoms"};return}this._complex.metadata.format="xyz",this._complex.name=s}_parseAtomsInf(){const a=this._complex.addChain("A").addResidue("UNK",1," ");for(let c=0;c<this._atomsInf.length-1;c++){const h=this._atomsInf[c].split(/[\s,]+/);if(h.length!==4){this._complex.error={message:"missed parameters"};break}const u=c+1,d=h[0],f=new x.Vector3(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3])),p=QI.getByName(d);a.addAtom(d,p,f,void 0,!0,u," ",1,1,0)}const l=new eL(this._complex,this._complex.name,1);l.residues=a,this._complex._molecules[0]=l}parseSync(){const e=this._complex=new JI;if(this._parseToAtomsInf(this._data),this._parseAtomsInf(),this._complex.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap}),this._complex=null,this._atomsInf=null,e.error)throw new Error(e.error.message);return e}static formats=["xyz"];static extensions=[".xyz"]}const nL=tL,{Complex:iL,Element:sL}=Bt;class ip extends Nn{constructor(e,t){super(e,t),this._options.fileType="pubchem+json"}static canProbablyParse(e){return de.default.isString(e)&&e[0]==="{"}parseSync(){return this.logger.info("Parsing PubChem JSON file..."),this._toComplex(JSON.parse(this._data))}_toComplex(e){const t=new iL,n=e.PC_Compounds&&e.PC_Compounds[0];return n&&(this._extractAtoms(t,n),t.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing})),t}_extractAtoms(e,t){let n=t.atoms&&t.atoms.aid,i=n&&t.atoms.element;if(!i||n.length!==i.length)throw new Error("Unable to parse atom elements");i=de.default.fromPairs(de.default.zip(n,i));const s={},o=t.coords&&t.coords[0],a=o&&o.conformers&&o.conformers[0],l=a&&a.x,c=a&&a.y,h=a&&a.z||[];if(n=o&&o.aid,!n||!l||!c)throw new Error("Coordinates are not found in the file");const d=e.addChain(" ").addResidue("UNK",1," ");for(let g=0,m=n.length;g<m;++g){const v=n[g],y=sL.ByAtomicNumber[i[v]],S=new x.Vector3(l[g],c[g],h[g]||0);s[v]=d.addAtom(y.name,y,S,void 0,!0,v," ",1,0,0)}const f=t.bonds&&t.bonds.aid1,p=t.bonds&&t.bonds.aid2,_=t.bonds&&t.bonds.order||[];if(!(!f||!p||f.length!==p.length))for(let g=0,m=f.length;g<m;++g)e.addBond(s[f[g]],s[p[g]],_[g]||1,0,!0)}}ip.formats=["pubchem","pubchem+json","pc"];ip.extensions=[".json"];const rL=ip;class oL{constructor(e){this._strings=e.split(/\r?\n|\r/),this._currentStart=0,this._currentStringIndx=0}setStart(e){e>=this._strings.length?(this._currentStart=this._strings.length-1,this._currentStringIndx=this._strings.length-1):(this._currentStart=e,this._currentStringIndx=e)}getNextString(){return this._strings[++this._currentStringIndx]}getCurrentString(){return this._strings[this._currentStringIndx]}getStringFromStart(e){return this._currentStringIndx=this._currentStart+e,this._strings[this._currentStart+e]}findNextDataItem(){let e=this.getNextString(),t=!1;for(;!de.default.isUndefined(e)&&e.trim()!=="$$$$";){if(e.match(/>\s+<(.*)>/)){t=!0;break}e=this.getNextString()}return t}findNextCompoundStart(){let e=this.getCurrentString();for(;!de.default.isUndefined(e)&&e.trim()!=="$$$$";)e=this.getNextString();return this.setStart(++this._currentStringIndx),this.probablyHaveDataToParse()}probablyHaveDataToParse(){return this._currentStringIndx<this._strings.length-2}}const{Complex:aL,Element:lL,Bond:Pi,Molecule:cL}=Bt,hL=[0,3,2,1,0,-1,-2,-3],uL=[0,1,2,3,1,1,1,2],dL=[Pi.BondType.UNKNOWN,Pi.BondType.COVALENT,Pi.BondType.COVALENT,Pi.BondType.COVALENT,Pi.BondType.AROMATIC,Pi.BondType.UNKNOWN,Pi.BondType.AROMATIC,Pi.BondType.AROMATIC],fL=/.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/,pL=/.*($$$$).*|.*>\s+<(.+)>.*/,Cu={SDF:"sdf",MOL:"mol"},mL=["PUBCHEM_IUPAC_TRADITIONAL_NAME",/PUBCHEM_(.+)_NAME/,/(.+)name/,/(.+)NAME/],gL=["PUBCHEM_COMPOUND_CID","id","ID",/.*CID/,/.*ID/,/.*id/],_L=["msg","MSG","message","title","description","desc"],Ru=["name","id","title"],yL={name:mL,id:gL,title:_L};function xL(r){if(!r)return"A";const e=[];for(;r;)e.push(65+r%26),r=Math.trunc(r/26);return e.length>1&&(e.reverse(),e[0]-=1),String.fromCharCode(...e)}class sp extends Nn{constructor(e,t){super(e,t),this._format="sdf",this._complex=null,this._chain=null,this._residue=null,this._molecules=null,this._metadata={},this._metadata.molecules=[],this._currentMolProps={},this._compoundIndx=-1,this._assemblies=[],this._atomsParsed=0,this._atomsIndexes=[]}canProbablyParse(e){return de.default.isString(e)&&fL.test(e)}_parseHeader(e){const t={};t.name=e.getStringFromStart(0);const n=parseInt(e.getStringFromStart(1).substr(10,6).trim(),10);t.date=n.toString()||"",t.title=e.getStringFromStart(2),this._metadata.molecules.push(t)}_parseAtoms(e,t){let n,i=this._atomsParsed;const s=xL(this._compoundIndx),o="UNK",a=1;this._chain=this._complex.getChain(s)||this._complex.addChain(s),this._residue=this._chain.addResidue(o,a," ");for(let l=0;l<t;l++){n=e.getNextString(),i++;const c=parseFloat(n.substr(0,10)),h=parseFloat(n.substr(10,10)),u=parseFloat(n.substr(20,10)),d=hL[parseInt(n.substr(36,3),10)],f=new x.Vector3(c,h,u);let p=n.substr(31,3).trim().toUpperCase();const _=lL.getByName(p);this._atomsIndexes[p]||(this._atomsIndexes[p]=0),this._atomsIndexes[p]+=1,p+=this._atomsIndexes[p],this._residue.addAtom(p,_,f,void 0,!0,i," ",1,0,d)}}_parseBonds(e,t){let n;for(let i=0;i<t;i++){n=e.getNextString();let s=parseInt(n.substr(0,3),10)+this._atomsParsed,o=parseInt(n.substr(3,3),10)+this._atomsParsed;const a=parseInt(n.substr(6,3),10);s>o&&([s,o]=[o,s]),this._complex.addBond(s,o,uL[a]||1,dL[a]||Pi.BondType.UNKNOWN,!0)}}_parseMOL(e){this._compoundIndx++,this._parseHeader(e);const t=e.getStringFromStart(3),n=parseInt(t.substr(0,3),10),i=parseInt(t.substr(3,3),10);this._parseAtoms(e,n),this._parseBonds(e,i),this._atomsParsed+=n,this._metadata.molecules[this._compoundIndx]._residues=[],this._metadata.molecules[this._compoundIndx]._residues.push(this._residue)}_parseDataItem(e){const t=e.getCurrentString();let n=[],i=e.getNextString();for(;i.trim()!=="";)n.push(i),i=e.getNextString();n.length===1&&([n]=n),this._currentMolProps[t.replace(/[<>]/g,"").trim()]=n}_parseCompound(e){if(this._parseMOL(e),this._format===Cu.SDF){for(this._currentMolProps={};e.findNextDataItem();)this._parseDataItem(e);if(Object.keys(this._currentMolProps).length!==0){const t=this._metadata.molecules[this._compoundIndx];t.props=this._currentMolProps,this._tryToUpdateMoleculeData(t)}}}_fixBondsArray(){const e=this._serialAtomMap,n=this._complex._bonds;for(let i=0;i<n.length;i++){const s=n[i];s._right<s._left&&console.log("_fixBondsArray: Logic error."),s._left=e[s._left]||null,s._right=e[s._right]||null}}_buildAssemblies(){const e=this._complex._chains;if(e.length===1)return this._assemblies;for(let t=0;t<e.length;t++){const n=new If(this._complex),i=new x.Matrix4;n.addMatrix(i),n.addChain(e[t]._name),this._assemblies.push(n)}return this._assemblies}_buildMolecules(){this._complex._molecules=[];const{molecules:e}=this._metadata;for(let t=0;t<e.length;t++){const n=new cL(this._complex,e[t].name,t+1);n.residues=e[t]._residues,this._complex._molecules[t]=n}return this._complex._molecules}_searchTag(e,t){for(let n=0;n<t.length;n++)if(e instanceof RegExp&&e.test(t[n].tag)||e===t[n].tag)return t[n].data}_tryToFind(e,t){for(let n=0;n<e.length;n++){const i=this._searchTag(e[n],t);if(i)return i}}_tryToUpdateMoleculeData(e){let t=!1;for(let n=0;n<Ru.length;n++){const i=yL[Ru[n]],s=this._tryToFind(i,e.props);s&&(e[Ru[n]]=s,t=!0)}return e.name=e.name||e.id,e.name.match(/^\d+$/)&&(e.name=`CID: ${e.name}`),t}_finalizeMetadata(){const{molecules:e}=this._metadata,{metadata:t}=this._complex,n=this._complex;if(e.length===1)n.name=e[0].name,t.title=e[0].title,t.date=e[0].date,t.properties=e[0].props;else if(e.length>1){t.molecules=[];for(let i=0;i<e.length;i++)t.molecules.push({name:e[i].name,date:e[i].date,title:e[i].title,properties:e[i].props})}}_finalize(){const e=this._serialAtomMap={},t=this._complex._atoms;for(let n=0;n<t.length;n++){const i=t[n];e[i.serial]=i}this._complex._finalizeBonds(),this._fixBondsArray(),this._finalizeMetadata(),this._buildAssemblies(),this._complex.units=this._complex.units.concat(this._assemblies),this._buildMolecules(),this._complex.finalize({needAutoBonding:!1,detectAromaticLoops:!1,enableEditing:!1,serialAtomMap:this._serialAtomMap})}defineFormat(e){let t;return pL.test(e)?t=Cu.SDF:t=Cu.MOL,t}parseSync(){const e=this._complex=new aL,t=new oL(this._data);this._format=this.defineFormat(this._data),e.metadata.format=this._format;do this._parseCompound(t);while(t.findNextCompoundStart());return this._finalize(),e}}sp.formats=["mol","sdf"];sp.extensions=[".mol",".sdf"];const vL={nstart:[pt.array,"i16",0],extent:[pt.array,"i16",3],grid:[pt.array,"i16",6],cellDims:[pt.vector,"i16",9],angles:[pt.array,"i16",12],div:[pt.singular,"i16",15],adder:[pt.singular,"i16",16],scaleFactor:[pt.singular,"i16",17]};class SL extends Oy{_parseHeader(e){this._buff=e,this._typedCheck();const t={};if(t.i16=new Int16Array(this._buff),t.i16[18]!==100)for(let i=0,s=t.i16.length;i<s;++i){const o=t.i16[i];t.i16[i]=(o&255)<<8|o>>8&255}if(t.i16[18]!==100)throw new Error("DSN6: Incorrect format ");const n=this._header;this._fillHeader(vL,t),n.cellDims.multiplyScalar(1/n.scaleFactor),n.angles.forEach((i,s,o)=>{o[s]*=Math.PI/180/n.scaleFactor}),n.div/=100}_setAxisIndices(){this._xyz2crs[0]=0,this._xyz2crs[1]=1,this._xyz2crs[2]=2}_setOrigins(){const e=this._header,[t,n,i]=this._getAxis();this._setAxisIndices(),this._origin.addScaledVector(t,e.nstart[0]),this._origin.addScaledVector(n,e.nstart[1]),this._origin.addScaledVector(i,e.nstart[2]),t.multiplyScalar(e.extent[0]),n.multiplyScalar(e.extent[1]),i.multiplyScalar(e.extent[2]),this._setBoxParams(t,n,i)}_pointCalculate(e,t,n,i,s,o,a){const l=this._header;if(s<l.extent[0]&&i<l.extent[1]&&n<l.extent[2]){const c=s+l.extent[0]*(i+l.extent[1]*n);e[c]=(t[o.counter]-l.adder)/l.div,++o.counter}else return o.counter+=8-a,!1;return!0}_blockCalculate(e,t,n,i,s,o){for(let a=0;a<8;++a){const l=8*n+a;for(let c=0;c<8;++c){const h=8*i+c;let u=!0,d=0;for(;u&&d<8;){const f=8*s+d;u=this._pointCalculate(e,t,l,h,f,o,d),d++}}}}_toXYZData(){const e=this._header,t=new Uint8Array(this._buff),n=new Float32Array(e.extent[0]*e.extent[1]*e.extent[2]),i=new x.Vector3(e.extent[0]/8,e.extent[1]/8,e.extent[2]/8),s={};s.counter=512;for(let o=0;o<i.z;++o)for(let a=0;a<i.y;++a)for(let l=0;l<i.x;++l)this._blockCalculate(n,t,o,a,l,s);return this._calculateInfoParams(n),n}_calculateInfoParams(e){this._header.dmean/=e.length;let t=0,n=e[0],i=e[0];for(let s=0;s<e.length;s++)t+=(this._header.dmean-e[s])**2,e[s]<n&&(n=e[s]),e[s]>i&&(i=e[s]);this._header.sd=Math.sqrt(t/e.length),this._header.dmax=i,this._header.dmin=n}}class xh extends Nn{constructor(e,t){super(e,t),this._options.fileType="dsn6",this.model=new SL}static canParse(e,t){return e?e instanceof ArrayBuffer&&Nn.checkDataTypeOptions(t,"dsn6"):!1}static canProbablyParse(e){return!1}parseSync(){return this.model.parse(this._data)}}xh.formats=["dsn6"];xh.extensions=[".dsn6",".omap"];xh.binary=!0;const bL=xh;class wL extends Ny{constructor(e){super(e),this._next=-1,this.next()}getNext(){return this._next}}const ML=wL,{Complex:AL,Element:Kg,Molecule:EL}=Bt;class rp extends Nn{constructor(e,t){super(e,t),this._time=null,this._numAtoms=null,this._residueNumber=null,this._residueName="",this._atomName="",this._atomNumber=null,this._atomPosition=[],this._atomVelocity=[],this._complex=null,this._molecules=[],this._molecule=null,this._options.filetype="gro"}canProbablyParse(e){return de.default.isString(this._data)&&/^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(e)}_parseTitle(e){const{metadata:t}=this._complex;t.id=e.readLine().trim(),t.name=t.id.slice(t.id.lastIndexOf("\\")+1,t.id.lastIndexOf(".")),t.format="gro"}_parseNumberOfAtoms(e){if(this._numAtoms=e.readInt(0,e.getNext()),Number.isNaN(this._numAtoms))throw new Error("Line 2 is not representing atom number. Consider checking input file")}_parseAtom(e){this._residueNumber=e.readInt(1,5),this._residueName=e.readString(6,10).trim(),this._atomName=e.readString(11,15).trim(),this._atomNumber=e.readInt(16,20);const t=e.readFloat(21,28)*10,n=e.readFloat(29,36)*10,i=e.readFloat(37,45)*10;if(Number.isNaN(t)||Number.isNaN(n)||Number.isNaN(i)){this._complex.error={message:`Atom position is invalid in "${e.readLine()}"`};return}const s=Kg.getByName(this._atomName[0]);if(s.fullName==="Unknown"){this._complex.error={message:`${this._atomName[0]} hasn't been recognised as an atom name.`};return}const o=Kg.Role[this._atomName];let a=this._chain;a||(this._chain=a=this._complex.addChain("A"));let l=this._residue;(!l||l.getSequence()!==this._residueNumber)&&(this._residue=l=a.addResidue(this._residueName,this._residueNumber," ")),this._atomPosition=new x.Vector3(t,n,i),l.addAtom(this._atomName,s,this._atomPosition,o,!0,this._atomNumber," ",1,1,0)}_finalize(){const e=new EL(this._complex,this._complex.metadata.name,1);e.residues=this._chain._residues,e._chains=this._chain,this._complex._molecules[0]=e,this._molecules.push(e),this._complex.finalize({needAutoBonding:!0,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap})}parseSync(){const e=this._complex=new AL,t=new ML(this._data);let n=0;for(this._parseTitle(t),t.next(),this._parseNumberOfAtoms(t),t.next(),n=0;n<this._numAtoms&&!t.end();++n)this._parseAtom(t),t.next();if(n<this._numAtoms&&(this._complex.error={message:"File ended unexpectedly."}),e.error)throw new Error(e.error.message);return this._finalize(),this._atomPosition=null,this._complex=null,this._molecules=null,this._molecule=null,e}}rp.formats=["gro"];rp.extensions=[".gro"];const TL=rp,{Complex:CL,Element:Jg,Bond:Ii,Molecule:RL}=Bt,PL={un:0,1:1,2:2,3:3,ar:1,am:1,nc:0,du:1},IL={un:Ii.BondType.UNKNOWN,1:Ii.BondType.COVALENT,2:Ii.BondType.COVALENT,3:Ii.BondType.COVALENT,ar:Ii.BondType.AROMATIC,am:Ii.BondType.COVALENT,nc:Ii.BondType.UNKNOWN,du:Ii.BondType.COVALENT},LL=/\d+$/,Dy=/\s+/;function Qg(r){return r.trim().split(Dy)}class op extends Nn{constructor(e,t){super(e,t),this._complex=null,this._chain=null,this._residue=null,this._compoundIndx=-1,this._molecules=[],this._molecule=null,this._currPosIdx=0,this._currStartIdx=0,this._serialAtomMap={},this._options.fileType="mol2"}_parseRawStrings(e){return e.split(/\r?\n|\r/)}_toStringFromStart(e,t){const n=this._currStartIdx+e;this._currPosIdx=n<t.length?n:this._currStartIdx}_toHeaderString(e,t){for(this._toStringFromStart(0,t);this._currPosIdx<t.length;){if(t[this._currPosIdx].match(`@<TRIPOS>${e}`))return;this._currPosIdx++}this._toStringFromStart(0,t)}_toStringFromHeader(e,t,n){this._toHeaderString(e,n);const i=this._currPosIdx+t;n[this._currPosIdx].match(`@<TRIPOS>${e}`)&&i<n.length&&(this._currPosIdx=i)}_setStart(e,t){e>=t.length?this._currStartIdx=this._currPosIdx=t.length-1:this._currStartIdx=this._currPosIdx=e}_probablyHaveDataToParse(e){return this._currPosIdx<e.length-2}_findNextCompoundStart(e){for(;this._currPosIdx<e.length&&e[this._currPosIdx].trim()!=="@<TRIPOS>MOLECULE>";)this._currPosIdx++;return this._setStart(++this._currPosIdx,e),this._probablyHaveDataToParse(e)}_parseMolecule(e){this._toHeaderString("MOLECULE",e);const{metadata:t}=this._complex;t.name=e[++this._currPosIdx],t.format="mol2",this._molecule={_index:"",_chains:[]},this._molecule._index=this._compoundIndx+1,this._molecules.push(this._molecule)}_parseAtoms(e,t){this._toHeaderString("ATOM",t);for(let n=0;n<e;n++){const i=Qg(t[++this._currPosIdx]);if(i.length<6)throw new Error("MOL2 parsing error: Not enough information to create atom!");const s=parseInt(i[0],10),o=i[1],a=parseFloat(i[2]),l=parseFloat(i[3]),c=parseFloat(i[4]),h=i[5].split(".")[0].toUpperCase();let u=0;i.length>=9&&(u=parseFloat(i[8])||0);let d=this._chain;if(d||(this._chain=d=this._complex.getChain("A")||this._complex.addChain("A"),this._residue=null),!this._setResidue(i))continue;const f=!1,p=" ",_=1,g=0,m=Jg.getByName(h),v=Jg.Role[o],y=new x.Vector3(a,l,c);this._residue.addAtom(o,m,y,v,f,s,p,_,g,u)}}_setResidue(e){let t=1,n="UNK";if(e.length>=7&&(t=parseInt(e[6],10)),e.length>=8&&e[7]!=="<0>"&&(n=e[7].replace(LL,"")),this.settings.now.nowater&&(n==="HOH"||n==="WAT"))return!1;const i=this._residue,s=this._chain;return(!i||i.getSequence()!==t)&&(this._residue=s.addResidue(n,t,"A")),!0}_parseBonds(e,t){this._toHeaderString("BOND",t);for(let n=0;n<e;n++){const i=Qg(t[++this._currPosIdx]);if(i.length<3)throw new Error("MOL2 parsing error: Missing information about bonds!");let s=parseInt(i[1],10),o=parseInt(i[2],10);const a=i[3];s>o&&([s,o]=[o,s]),this._complex.addBond(s,o,PL[a]||0,IL[a]||Ii.BondType.UNKNOWN,!0)}}_fixSerialAtoms(){const e=this._complex._atoms;for(let t=0;t<e.length;t++){const n=e[t];this._serialAtomMap[n.serial]=n}}_fixBondsArray(){const e=this._serialAtomMap,t=this._complex;if(Object.keys(e).length===0)throw new Error("MOL2 parsing error: Missing atom information!");const n=t._bonds;for(let i=0;i<n.length;i++){const s=n[i];s._left=e[s._left]||null,s._right=e[s._right]||null}}_finalizeMolecules(){const e=this._complex._chains[0];this._complex._molecules=[];for(let t=0;t<this._molecules.length;t++){const n=this._molecules[t],i=e._residues,s=new RL(this._complex,n._name,t+1);s.residues=i,this._complex._molecules[t]=s}}_finalize(){this._complex._finalizeBonds(),this._fixSerialAtoms(),this._fixBondsArray(),this._finalizeMolecules(),this._complex.finalize({needAutoBonding:!1,detectAromaticLoops:this.settings.now.aromatic,enableEditing:this.settings.now.editing,serialAtomMap:this._serialAtomMap})}_parseCompound(e){this._compoundIndx++,this._parseMolecule(e),this._toStringFromHeader("MOLECULE",2,e);const t=e[this._currPosIdx].trim().split(Dy),n=t[0],i=t[1];this._parseAtoms(n,e),this._parseBonds(i,e)}parseSync(){const e=this._complex=new CL,t=this._parseRawStrings(this._data);do this._parseCompound(t);while(this._findNextCompoundStart(t));return this._finalize(),e}}op.formats=["mol2"];op.extensions=[".mol2",".ml2",".sy2"];const NL=op,OL=new iI([_I,YI,OI,nL,SI,rL,sp,KI,bL,TL,NL]);class DL extends ar{constructor(){let e=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[];super(e,["formats"])}find(e){let t=[];return e.format&&(t=this._dict.formats[e.format.toLowerCase()]||[]),[...t]}}const UL=DL;class ap{constructor(e,t){this._source=e,this._options=t||{},this._abort=!1}exportSync(){throw new Error("Exporting to this source is not implemented")}export(){return new Promise((e,t)=>{setTimeout(()=>{try{return this._abort?t(new Error("Export aborted")):e(this.exportSync())}catch(n){return t(n)}})})}abort(){this._abort=!0}}Fa(ap.prototype);class FL{constructor(){this._resultArray=[],this._currentStr=-1,this._tag=null,this._fixedNumeration=!1,this._numeration=!1,this._tagStrNum=0}getResult(){return this.writeString(`
`,81,81),this._resultArray.join("")}_currentStrLength(){const e=this._resultArray[this._currentStr];return e?e.length:0}newTag(e,t){e?this._tag=e:this._tag=null,de.default.isUndefined(t)?(this._numeration=!1,this._fixedNumeration=!1,this._tagStrNum=0):de.default.isNumber(t)?(this._tagStrNum=t,this._numeration=!0,this._fixedNumeration=!0):de.default.isBoolean(t)&&(this._tagStrNum=0,this._numeration=t,this._fixedNumeration=!1)}newString(e){this.writeString(`
`,81,81),this._currentStr++,this._resultArray.push(""),e?this.writeString(e,1,6):this._tag&&this.writeString(this._tag,1,6),this._numeration&&(this._fixedNumeration||this._tagStrNum++,this._tagStrNum!==1&&this.writeString(this._tagStrNum.toString(),10,8))}writeEntireString(e,t,n){t||(t=81);for(let i=0;i<e.length;i++)this._currentStrLength()===t&&i!==e.length-1&&(this.newString(),n&&this.writeString(n.tag,n.begin,n.end)),e[i]===`
`?this.newString():this.writeString(e[i])}writeString(e,t,n){let i=this._resultArray[this._currentStr],s;const o=i?i.length:0;if(de.default.isUndefined(e))return;de.default.isNumber(t)||(t=o+1),de.default.isNumber(n)||(n=o+e.length),de.default.isString(e)?s=e:s=e.toString();const a=t<n?n:t,l=t<n?t:n;if(s.length>Math.abs(t-n)+1&&(s=s.substr(0,Math.abs(t-n+1))),l>o+1)this._resultArray[this._currentStr]+=" ".repeat(l-o-1);else if(l<=o){const c=this._resultArray[this._currentStr];this._resultArray[this._currentStr]=c.slice(0,l-1)}if(n<t){const c=t-n+1;s=" ".repeat(c-s.length)+s}l===11&&this._numeration&&this._tagStrNum!==1&&(s=` ${s}`),this._resultArray[this._currentStr]+=s,i=this._resultArray[this._currentStr],a>i.length&&(this._resultArray[this._currentStr]+=" ".repeat(a-i.length))}writeBondsArray(e,t){const n=this._getSubArrays(e,4);for(let i=0;i<n.length;i++){this.newString(),this.writeString(t.serial,11,7);for(let s=0;s<n[i].length;s++){const o=n[i][s]._left.serial===t.serial?n[i][s]._right.serial:n[i][s]._left.serial;this.writeString(o,16+5*s,12+5*s)}}}_getSubArrays(e,t){const n=[];for(let i=0;i<e.length;i+=t)n.push(e.slice(i,i+t));return n}writeMatrix(e,t,n){for(let i=0;i<3;i++){this.newString(),this.writeString(n,14,18),this.writeString((i+1).toString(),19,19),this.writeString(t.toString(),23,20);for(let o=0;o<3;o++){const a=parseFloat(e.elements[i*4+o]).toFixed(6);this.writeString(a.toString(),33+o*10,24+o*10)}const s=parseFloat(e.elements[i*4+3]).toFixed(5);this.writeString(s.toString(),68,55)}}writeMatrices(e,t){if(!e)return;const n=new x.Matrix4;for(let i=0;i<e.length;i++)n.copy(e[i]).transpose(),this.writeMatrix(n,i+1,t)}}class lp extends ap{constructor(e,t){super(e,t),this._tags=["HEADER","TITLE","COMPND","REMARK","HELIX","SHEET","ATOM and HETATM","CONECT"],this._result=null,this._tagExtractors={HEADER:this._extractHEADER,TITLE:this._extractTITLE,"ATOM and HETATM":this._extractATOM,CONECT:this._extractCONECT,COMPND:this._extractCOMPND,REMARK:this._extractREMARK,HELIX:this._extractHELIX,SHEET:this._extractSHEET},this._stringForRemark350=`COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN
BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE
MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS
GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND
CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.`,this._stringForRemark290=`CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS
THE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM
RECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY
RELATED MOLECULES.`}exportSync(){const e=new FL;if(!this._source)return this._result;for(let t=0;t<this._tags.length;t++){const n=this._tags[t],i=this._tagExtractors[n];de.default.isFunction(i)&&i.call(this,e)}return this._result=e.getResult(),this._result}_extractHEADER(e){if(!this._source.metadata)return;const{metadata:t}=this._source;e.newTag("HEADER"),e.newString(),t.classification&&e.writeString(t.classification,11,50),t.date&&e.writeString(t.date,51,59),t.id&&e.writeString(t.id,63,66)}_extractTITLE(e){if(!this._source.metadata)return;const{metadata:t}=this._source;if(t.title){e.newTag("TITLE",!0);for(let n=0;n<t.title.length;n++)e.newString(),e.writeString(t.title[n],11,80)}}_extractCONECT(e){if(!this._source._atoms)return;const t=this._source._atoms;e.newTag("CONECT");for(let n=0;n<t.length;n++){const i=t[n].bonds.filter(s=>s._fixed);i.length!==0&&e.writeBondsArray(i.reverse(),t[n])}}_extractSHEET(e){if(!this._source._sheets)return;e.newTag("SHEET");const t=this._source._sheets;for(let n=0;n<t.length;n++)if(t[n]._strands){const i=t[n]._strands;for(let s=0;s<i.length;s++)e.newString(),e.writeString(s+1,10,8),e.writeString(t[n]._name,14,12),e.writeString(i.length,16,15),e.writeString(i[s].init._type._name,18,20),e.writeString(i[s].init._chain._name,22,22),e.writeString(i[s].init._sequence,26,23),e.writeString(i[s].init._icode,27,27),e.writeString(i[s].term._type._name,29,31),e.writeString(i[s].init._chain._name,33,33),e.writeString(i[s].term._sequence,37,34),e.writeString(i[s].term._icode,38,38),e.writeString(i[s].sense,40,39)}}_extractHELIX(e){if(!this._source._helices)return;e.newTag("HELIX");const t=this._source._helices;for(let n=0;n<t.length;n++){const i=t[n],s=de.default.invert(z0);e.newString(),e.writeString(i.serial,10,8),e.writeString(i.name,14,12),e.writeString(i.init._type._name,16,18),e.writeString(i.init._chain._name,20,20),e.writeString(i.init._sequence,25,22),e.writeString(i.init._icode,26,26),e.writeString(i.term._type._name,28,30),e.writeString(i.term._chain._name,32,32),e.writeString(i.term._sequence,37,34),e.writeString(i.term._icode,38,38),e.writeString(s[i.type],40,39),e.writeString(i.comment,41,70),e.writeString(i.length,76,72)}}_extractATOM(e){if(!this._source._atoms)return;const t=this._source._atoms;for(let n=0;n<t.length;n++){const i=t[n].het?"HETATM":"ATOM";e.newString(i);const s=t[n].element.name.length>1||t[n].name.length>3?13:14;e.writeString(t[n].serial,11,7),e.writeString(t[n].name,s,16),e.writeString(String.fromCharCode(t[n].location),17,17),e.writeString(t[n].residue._type._name,20,18),e.writeString(t[n].residue._chain._name,22,22),e.writeString(t[n].residue._sequence,26,23),e.writeString(t[n].residue._icode,27,27),e.writeString(t[n].position.x.toFixed(3),38,31),e.writeString(t[n].position.y.toFixed(3),46,39),e.writeString(t[n].position.z.toFixed(3),54,47),e.writeString(t[n].occupancy.toFixed(2),60,55),e.writeString(t[n].temperature.toFixed(2),66,61),e.writeString(t[n].element.name,78,77),t[n].charge&&e.writeString(t[n].charge,79,80)}}_extractCOMPND(e){if(!this._source._molecules)return;const t=this._source._molecules;e.newTag("COMPND",!0);for(let n=0;n<t.length;n++){const i=this._getMoleculeChains(t[n]);e.newString(),e.writeString(`MOL_ID: ${t[n].index};`,11,80),e.newString(),e.writeString(`MOLECULE: ${t[n].name};`,11,80),e.newString(),e.writeString("CHAIN: ",11,18);const s=`${i.join(", ")};`;e.writeEntireString(s,81)}}_extractREMARK(e){this._Remark290(e),this._Remark350(e)}_Remark290(e){if(this._source.symmetry&&this._source.symmetry.length!==0){const t=this._source.symmetry;e.newTag("REMARK",290),e.newString(),e.newString(),e.writeEntireString(this._stringForRemark290),e.writeMatrices(t,"SMTRY"),e.newString(),e.newString(),e.writeString("REMARK: NULL",11,80)}}_Remark350(e){if(!this._source.units)return;const{units:t}=this._source;let n=0;e.newTag("REMARK",350),e.newString(),e.newString(),e.writeEntireString(this._stringForRemark350);const i=t.filter(s=>s instanceof If);for(let s=0;s<i.length;s++){e.newString(),e.newString(),n++,e.writeString(`BIOMOLECULE: ${n}`,11,80);const o=i[s].chains.join(", ");e.newString(),e.writeString("APPLY THE FOLLOWING TO CHAINS: "),e.writeEntireString(o,69,{tag:"AND CHAINS: ",begin:31,end:42});const{matrices:a}=i[s];e.writeMatrices(a,"BIOMT")}}_getMoleculeChains(e){function t(i){return i._chain._name}const n=e.residues.map(t);return n.filter((i,s)=>n.indexOf(i)===s)}}lp.formats=["pdb"];lp.SourceClass=Df;const Xr=3,Vo=3,Pu=4;function e_(r,e,t,n){t[n]=r[e],t[n+1]=r[e+1],t[n+2]=r[e+2]}function zL(r,e,t,n,i){t[n]=r[e],t[n+1]=r[e+1],t[n+2]=r[e+2],t[n+3]=i}const Bo=new x.Vector4;function t_(r,e,t,n,i){Bo.set(r[e],r[e+1],r[e+2],i.w),Bo.applyMatrix4(i.matrix),t[n]=Bo.x,t[n+1]=Bo.y,t[n+2]=Bo.z}function Iu(r,e,t,n,i){if(!((e.array.length-e.start)/e.stride<t||(r.array.length-r.start)/r.stride<t))if(r.stride===e.stride)e.array.set(r.array,e.start);else{let s=e.start,o=r.start;for(let a=0;a<t;++a,s+=e.stride,o+=r.stride)n(r.array,o,e.array,s,i)}}class Lu{constructor(){this.positions=null,this.normals=null,this.colors=null,this.indices=null,this.lastPos=0,this.lastNorm=0,this.lastCol=0,this.lastIdx=0}init(e,t){this.positions=new Float32Array(e*Xr),this.normals=new Float32Array(e*Vo),this.colors=new Float32Array(e*Pu),this.indices=new Int32Array(t)}setPositions(e,t,n,i){const s={array:e,start:t,stride:i},o={array:this.positions,start:this.lastPos,stride:Xr};Iu(s,o,n,e_),this.lastPos+=n*Xr}setTransformedPositions(e,t,n,i,s){let o=this.lastPos,a=t;const l={matrix:s,w:1};for(let c=0;c<n;++c,a+=i,o+=Xr)t_(e,a,this.positions,o,l);this.lastPos+=n*Xr}setNormals(e,t,n,i){const s={array:e,start:t,stride:i},o={array:this.normals,start:this.lastNorm,stride:Vo};Iu(s,o,n,e_),this.lastNorm+=n*Vo}setTransformedNormals(e,t,n,i,s){let o=this.lastNorm,a=t;const l={matrix:s,w:0};for(let c=0;c<n;++c,a+=i,o+=Vo)t_(e,a,this.normals,o,l);this.lastNorm+=n*Vo}setColors(e,t,n,i){const s={array:e,start:t,stride:i},o={array:this.colors,start:this.lastCol,stride:Pu};Iu(s,o,n,zL,1),this.lastCol+=n*Pu}setIndices(e,t,n){this.indices.set(e,this.lastIdx),this.lastIdx+=n}setShiftedIndices(e,t,n){const i=e.map(s=>s+n);this.setIndices(i,0,t)}getVerticesNumber(){return this.lastPos/Xr}addInstance(e,t){const n=this.getVerticesNumber();this.setShiftedIndices(t.indices,t.indices.length,n);const i=t.itemSize;this.setTransformedPositions(t.positions,0,t.vertsCount,i.position,e),this.setTransformedNormals(t.normals,0,t.vertsCount,i.normal,e),this.setColors(t.colors,0,t.vertsCount,i.color)}}class Uy{constructor(){this.positions=null,this.normals=null,this.colors=null,this.indices=null,this.vertsCount=0,this.itemSize=null}init(e,t){const{attributes:n}=e;this.itemSize={position:n.position.itemSize,normal:n.normal.itemSize,color:n.color.itemSize}}}class n_ extends Uy{init(e,t){super.init(e,t);const{attributes:{position:n,normal:i},index:s}=e;this.vertsCount=n.count,this.positions=n.array,this.normals=i.array,this.colors=new Float32Array(this.vertsCount*this.itemSize.color),this.indices=s.array}setColors(e){let t=0;for(let n=0,i=this.colors.length,s=this.itemSize.color;n<i;n+=s)this.colors[t++]=e.r,this.colors[t++]=e.g,this.colors[t++]=e.b}}class VL extends Uy{constructor(){super(),this._cutRawStart=0,this._cutRawEnd=0,this._facesPerSlice=0}init(e,t){super.init(e,t);const{attributes:{position:n},index:i}=e;this.vertsCount=n.count+t.addPerCylinder,this._facesPerSlice=t.addPerCylinder,this.positions=new Float32Array(this.vertsCount*n.itemSize),this.normals=new Float32Array(this.vertsCount*this.itemSize.normal),this.colors=new Float32Array(this.vertsCount*this.itemSize.color),this._extendVertices(e,t),this.indices=new Uint32Array(i.count),this._extendIndices(e,t)}_extendVertices(e,t){const{position:n}=e.attributes,{normal:i}=e.attributes,s=e.getGeoParams(),o=1;this._cutRawStart=o*s.radialSegments,this._cutRawEnd=this._cutRawStart+t.addPerCylinder;{let a=n.array.slice(0,this._cutRawEnd*n.itemSize);this.positions.set(a,0),a=i.array.slice(0,this._cutRawEnd*i.itemSize),this.normals.set(a,0)}{let a=n.array.slice(this._cutRawStart*n.itemSize,n.array.length);this.positions.set(a,this._cutRawEnd*n.itemSize),a=i.array.slice(this._cutRawStart*i.itemSize,i.array.length),this.normals.set(a,this._cutRawEnd*i.itemSize)}}_extendIndices(e,t){const{index:n}=e,s=t.addPerCylinder*6,o=t.addPerCylinder;let a=n.array.slice(s,n.count);a=a.map(l=>l+o),this.indices.set(n.array,0),this.indices.set(a,s)}_setColorRange(e,t,n,i){const s=i.length;for(let o=e;o<t;o+=s)n.set(i,o)}setColors(e,t){const n=this.itemSize.color,i=this._cutRawEnd*n,s=i*2;if(this._setColorRange(0,i,this.colors,e.toArray()),this._setColorRange(i,s,this.colors,t.toArray()),s<this.colors.length){const o=(this._facesPerSlice+1)*n,a=s+o;this._setColorRange(s,a,this.colors,t.toArray());const l=a+o;this._setColorRange(a,l,this.colors,e.toArray())}}}class BL{constructor(){this._materials=[],this._models=[]}process(e){this._extractModelsAndMaterials(e);const t=this._flattenModels();return{name:e.name,models:t,materials:this._materials}}_extractModelsAndMaterials(e){const t=new x.Layers;t.set(Je.LAYERS.DEFAULT),t.enable(Je.LAYERS.TRANSPARENT),e.traverse(n=>{n instanceof x.Mesh&&n.layers.test(t)&&this.checkExportAbility(n)&&(n.geometry.type==="InstancedBufferGeometry"?this._collectInstancedGeoInfo(n):this._collectGeoInfo(n))})}_reworkIndices(e){for(let n=2;n<e.length;n+=3)e[n]*=-1,e[n]--}_flattenModels(){let e=0;function t(i){return i+e}const n=[];for(let i=0,s=this._models.length;i<s;i++){const o=this._models[i];let a=[],l=[],c=[],h=[];e=0;for(let u=0;u<o.length;u++){const d=o[u];a.push(d.indices.map(t)),e+=d.getVerticesNumber(),l.push(d.positions),c.push(d.normals),h.push(d.colors)}a=be.mergeTypedArraysUnsafe(a),this._reworkIndices(a),l=be.mergeTypedArraysUnsafe(l),c=be.mergeTypedArraysUnsafe(c),h=be.mergeTypedArraysUnsafe(h),n.push({indices:a,positions:l,normals:c,colors:h,verticesCount:e})}return n}checkExportAbility(e){return e.geometry.attributes.position.count===0?!1:e instanceof dy?(Ut.warn("Currently we cannot export 'sprites' modes, like BS, WV, LC. Please turn of settings 'zSprites' and try again"),!1):e instanceof fy?(Ut.warn("Currently we cannot export Lines mode"),!1):!0}_collectGeoInfo(e){const{geometry:{attributes:{position:t,color:n,normal:i},index:s},matrix:o}=e,a=new Lu,l=t.count;a.init(l,s.count),o.isIdentity()?(a.setPositions(t.array,0,l,t.itemSize),a.setNormals(i.array,0,l,i.itemSize)):(a.setTransformedPositions(t.array,0,l,t.itemSize,o),a.setTransformedNormals(i.array,0,l,i.itemSize,o)),a.setColors(n.array,0,l,n.itemSize),a.setIndices(s.array,0,s.count);const c=this._collectMaterialInfo(e);this._addToPool(a,c)}_collectSpheresInfo(e){const{geometry:{attributes:{position:t,color:n},index:i},matrix:s}=e,o=new Lu,a=e.geometry.instanceCount,l=t.count,c=i.count;o.init(a*l,a*c);const h=new n_;h.init(e.geometry);const u=new x.Matrix4,d=new x.Matrix4,f=new x.Color;for(let _=0;_<a;++_){const g=_*n.itemSize;f.fromArray(n.array,g),h.setColors(f),this._getSphereInstanceMatrix(e.geometry,_,u),d.multiplyMatrices(s,u),o.addInstance(d,h)}const p=this._collectMaterialInfo(e);this._addToPool(o,p)}_collectCylindersInfo(e){const{geometry:{attributes:{position:t,color:n,color2:i},index:s},matrix:o}=e,a=new Lu,l=e.geometry.instanceCount,c=new n_;c.init(e.geometry);const h=this._gatherCylindersColoringInfo(e.geometry);let u=null;h.needToSplit>0&&(u=new VL,u.init(e.geometry,h));const d=h.addPerCylinder*h.needToSplit,f=t.count,p=s.count;a.init(l*f+d,l*p);const _=new x.Matrix4,g=new x.Matrix4,m=new x.Color,v=new x.Color;let y={};for(let b=0;b<l;++b){const M=b*n.itemSize;h.is2Colored[b]?(m.fromArray(i.array,M),v.fromArray(n.array,M),u&&(u.setColors(m,v),y=u)):(m.fromArray(n.array,M),c.setColors(m),y=c),this._getCylinderInstanceMatrix(e.geometry,b,_),g.multiplyMatrices(o,_),a.addInstance(g,y)}const S=this._collectMaterialInfo(e);this._addToPool(a,S)}_addToPool(e,t){const n=this._checkExistingMaterial(t);n<0?(this._models.push([e]),this._materials.push(t)):this._models[n].push(e)}_checkExistingMaterial(e){return de.default.findIndex(this._materials,t=>de.default.isEqual(t,e))}_gatherCylindersColoringInfo(e){const t=e.instanceCount,n=e.attributes.color.array,i=e.attributes.color2.array,s=e.attributes.color.itemSize,o=new Array(t);let a=0,l=0;for(let u=0;u<t;u++,l+=s){const d=Math.abs(n[l]-i[l])>1e-7||Math.abs(n[l+1]-i[l+1])>1e-7||Math.abs(n[l+2]-i[l+2])>1e-7;o[u]=d,a+=d}const h=e.getGeoParams().radialSegments;return{is2Colored:o,needToSplit:a,addPerCylinder:h}}_collectInstancedGeoInfo(e){e.geometry instanceof J0?this._collectSpheresInfo(e):e.geometry instanceof ey&&this._collectCylindersInfo(e)}_collectMaterialInfo(e){const{uberOptions:t}=e.material;return{diffuse:t.diffuse.toArray(),opacity:t.opacity,shininess:t.shininess,specular:t.specular.toArray()}}_getCylinderInstanceMatrix(e,t,n){const i=e.attributes.matVector1.array,s=e.attributes.matVector2.array,o=e.attributes.matVector3.array,a=t*4;n.set(i[a],i[a+1],i[a+2],i[a+3],s[a],s[a+1],s[a+2],s[a+3],o[a],o[a+1],o[a+2],o[a+3],0,0,0,1)}_getSphereInstanceMatrix(e,t,n){const{offset:i}=e.attributes,s=t*i.itemSize,o=i.array[s],a=i.array[s+1],l=i.array[s+2],c=i.array[s+3];n.set(c,0,0,o,0,c,0,a,0,0,c,l,0,0,0,1)}}const kL=`
Definitions:  {
  Version: 100
  Count: 3
  ObjectType: "Model" {
    Count: 1
  }
  ObjectType: "Geometry" {
    Count: 1
  }
  ObjectType: "Material" {
    Count: 1
  }
  ObjectType: "Pose" {
    Count: 1
  }
  ObjectType: "GlobalSettings" {
    Count: 1
  }
} `,GL=`Properties60: {
      Property: "QuaternionInterpolate", "bool", "",0
      Property: "Visibility", "Visibility", "A",1
      Property: "Lcl Translation", "Lcl Translation", "A",0.000000000000000,0.000000000000000,-1789.238037109375000
      Property: "Lcl Rotation", "Lcl Rotation", "A",0.000009334667643,-0.000000000000000,0.000000000000000
      Property: "Lcl Scaling", "Lcl Scaling", "A",1.000000000000000,1.000000000000000,1.000000000000000
      Property: "RotationOffset", "Vector3D", "",0,0,0
      Property: "RotationPivot", "Vector3D", "",0,0,0
      Property: "ScalingOffset", "Vector3D", "",0,0,0
      Property: "ScalingPivot", "Vector3D", "",0,0,0
      Property: "TranslationActive", "bool", "",0
      Property: "TranslationMin", "Vector3D", "",0,0,0
      Property: "TranslationMax", "Vector3D", "",0,0,0
      Property: "TranslationMinX", "bool", "",0
      Property: "TranslationMinY", "bool", "",0
      Property: "TranslationMinZ", "bool", "",0
      Property: "TranslationMaxX", "bool", "",0
      Property: "TranslationMaxY", "bool", "",0
      Property: "TranslationMaxZ", "bool", "",0
      Property: "RotationOrder", "enum", "",0
      Property: "RotationSpaceForLimitOnly", "bool", "",0
      Property: "AxisLen", "double", "",10
      Property: "PreRotation", "Vector3D", "",0,0,0
      Property: "PostRotation", "Vector3D", "",0,0,0
      Property: "RotationActive", "bool", "",0
      Property: "RotationMin", "Vector3D", "",0,0,0
      Property: "RotationMax", "Vector3D", "",0,0,0
      Property: "RotationMinX", "bool", "",0
      Property: "RotationMinY", "bool", "",0
      Property: "RotationMinZ", "bool", "",0
      Property: "RotationMaxX", "bool", "",0
      Property: "RotationMaxY", "bool", "",0
      Property: "RotationMaxZ", "bool", "",0
      Property: "RotationStiffnessX", "double", "",0
      Property: "RotationStiffnessY", "double", "",0
      Property: "RotationStiffnessZ", "double", "",0
      Property: "MinDampRangeX", "double", "",0
      Property: "MinDampRangeY", "double", "",0
      Property: "MinDampRangeZ", "double", "",0
      Property: "MaxDampRangeX", "double", "",0
      Property: "MaxDampRangeY", "double", "",0
      Property: "MaxDampRangeZ", "double", "",0
      Property: "MinDampStrengthX", "double", "",0
      Property: "MinDampStrengthY", "double", "",0
      Property: "MinDampStrengthZ", "double", "",0
      Property: "MaxDampStrengthX", "double", "",0
      Property: "MaxDampStrengthY", "double", "",0
      Property: "MaxDampStrengthZ", "double", "",0
      Property: "PreferedAngleX", "double", "",0
      Property: "PreferedAngleY", "double", "",0
      Property: "PreferedAngleZ", "double", "",0
      Property: "InheritType", "enum", "",0
      Property: "ScalingActive", "bool", "",0
      Property: "ScalingMin", "Vector3D", "",1,1,1
      Property: "ScalingMax", "Vector3D", "",1,1,1
      Property: "ScalingMinX", "bool", "",0
      Property: "ScalingMinY", "bool", "",0
      Property: "ScalingMinZ", "bool", "",0
      Property: "ScalingMaxX", "bool", "",0
      Property: "ScalingMaxY", "bool", "",0
      Property: "ScalingMaxZ", "bool", "",0
      Property: "GeometricTranslation", "Vector3D", "",0,0,0
      Property: "GeometricRotation", "Vector3D", "",0,0,0
      Property: "GeometricScaling", "Vector3D", "",1,1,1
      Property: "LookAtProperty", "object", ""
      Property: "UpVectorProperty", "object", ""
      Property: "Show", "bool", "",1
      Property: "NegativePercentShapeSupport", "bool", "",1
      Property: "DefaultAttributeIndex", "int", "",0
      Property: "Color", "Color", "A+",0,0,0
      Property: "Size", "double", "",100
      Property: "Look", "enum", "",1
    }`,HL=`
    LayerElementMaterial: 0 {
      Version: 101
      Name: ""
      MappingInformationType: "AllSame"
      ReferenceInformationType: "Direct"
      Materials: 0
    }`,WL=`
    Layer: 0 {
      Version: 100
      LayerElement:  {
        Type: "LayerElementNormal"
        TypedIndex: 0
      }
      LayerElement:  {
        Type: "LayerElementColor"
        TypedIndex: 0
      }
      LayerElement:  {
        Type: "LayerElementMaterial"
        TypedIndex: 0
      }
    }`,XL=`GlobalSettings: {
    Version: 1000
    Properties60:  {
      Property: "UpAxis", "int", "",1
      Property: "UpAxisSign", "int", "",1
      Property: "FrontAxis", "int", "",2
      Property: "FrontAxisSign", "int", "",1
      Property: "CoordAxis", "int", "",0
      Property: "CoordAxisSign", "int", "",1
      Property: "UnitScaleFactor", "double", "",1
    }
  }`;class jL{constructor(){this._resultArray=[],this._info=null}getResult(e){return this._info=e,this._resultArray.push(this._writeHeader()),this._resultArray.push(this._writeDefinitions()),this._resultArray.push(this._writeObjects(e.models,e.materials)),this._resultArray.push(this._writeRelations()),this._resultArray.push(this._writeConnections()),this._info=null,this._resultArray.join("")}_writeHeader(){const n=new Date,i=1e3,s=`Miew FBX Exporter v${this._info.version}`;return`; FBX 6.1.0 project file
; Created by ${s} Copyright (c) 2015-2024 EPAM Systems, Inc.
; For support please contact miew@epam.com
; ----------------------------------------------------

FBXHeaderExtension:  {
  FBXHeaderVersion: 1003
  FBXVersion: 6100
  CreationTimeStamp:  {
    Version: ${i}
    Year: ${n.getFullYear()}
    Month: ${n.getMonth()+1}
    Day: ${n.getDate()}
    Hour: ${n.getHours()}
    Minute: ${n.getMinutes()}
    Second: ${n.getSeconds()}
    Millisecond: ${n.getMilliseconds()}
  }
  Creator: "${s}"
  OtherFlags:  {
    FlagPLE: 0
  }
}
CreationTime: "${n}"
Creator: "${s}"
`}_writeDefinitions(){return`
; Object definitions
;------------------------------------------------------------------

${kL}
`}_models(){let t="";const{models:n}=this._info;for(let i=0;i<n.length;++i){const s=n[i],o=s.verticesCount;t+=`
  Model: "Model::${this._info.name}_${i}", "Mesh" {
    Version: 232
    ${GL}
    ${this._verticesIndices(s.positions,s.indices)}
    ${this._normalLayer(s.normals)}
    ${this._colorLayer(s.colors,o)}
    ${HL}
    ${WL}
  }`}return t}_materials(){let t="";const{materials:n}=this._info;for(let i=0;i<n.length;++i){const s=n[i];t+=`
  Material: "Material::${this._info.name}_${i}_default", "" {
    Version: 102
    ShadingModel: "lambert"
    MultiLayer: 0
    ${this._materialProperties(s)}
  }`}return t}_writeObjects(){return`
; Object properties
;------------------------------------------------------------------

Objects:  {
  ${this._models()}
  ${this._materials()}
  ${XL}
}
`}_writeRelations(){let e="";for(let n=0;n<this._info.models.length;++n)e+=`
  Model: "Model::${this._info.name}_${n}", "Mesh" {
  }`;let t="";for(let n=0;n<this._info.materials.length;++n)t+=`
  Material: "Material::${this._info.name}_${n}_default", "" {
  }`;return`
; Object relations
;------------------------------------------------------------------

Relations:  {
  ${e}
  Model: "Model::Producer Perspective", "Camera" {
  }
  Model: "Model::Producer Top", "Camera" {
  }
  Model: "Model::Producer Bottom", "Camera" {
  }
  Model: "Model::Producer Front", "Camera" {
  }
  Model: "Model::Producer Back", "Camera" {
  }
  Model: "Model::Producer Right", "Camera" {
  }
  Model: "Model::Producer Left", "Camera" {
  }
  Model: "Model::Camera Switcher", "CameraSwitcher" {
  }
  ${t}
}`}_writeConnections(){let e="";const{name:t}=this._info;for(let i=0;i<this._info.models.length;++i)e+=`
  Connect: "OO", "Model::${t}_${i}", "Model::Scene"`;let n="";for(let i=0;i<this._info.materials.length;++i)n+=`
  Connect: "OO", "Material::${t}_${i}_default", "Model::${t}_${i}"`;return`
; Object connections
;------------------------------------------------------------------

Connections:  {
  ${e}
  ${n}
}`}_floatArrayToString(e){const t=[];for(let n=0;n<e.length;++n)t[n]=e[n].toFixed(6);return t.join(",")}_colorLayer(e,t){const o=this._floatArrayToString(e),a=[...Array(t).keys()];return`
    LayerElementColor: 0 {
      Version: 101
      Name: ""
      MappingInformationType: "ByVertice"
      ReferenceInformationType: "Direct"
      Colors: ${o}
      ColorIndex: ${a}
    }`}_normalLayer(e){return`
    LayerElementNormal: 0 {
      Version: 101
      Name: ""
      MappingInformationType: "ByVertice"
      ReferenceInformationType: "Direct"
      Normals: ${this._floatArrayToString(e)}
    }`}_verticesIndices(e,t){const o="CullingOff",l=this._floatArrayToString(e);return`MultiLayer: 0
    MultiTake: 1
    Shading: Y
    Culling: "${o}"
    Vertices: ${l}
    PolygonVertexIndex: ${t}
    GeometryVersion: 124`}_materialProperties(e){return`Properties60:  {
      Property: "ShadingModel", "KString", "", "Lambert"
      Property: "MultiLayer", "bool", "",0
      Property: "EmissiveColor", "ColorRGB", "",0,0,0
      Property: "EmissiveFactor", "double", "",0.0000
      Property: "AmbientColor", "ColorRGB", "",1,1,1
      Property: "AmbientFactor", "double", "",0.0000
      Property: "DiffuseColor", "ColorRGB", "",${e.diffuse}
      Property: "DiffuseFactor", "double", "",1.0000
      Property: "Bump", "Vector3D", "",0,0,0
      Property: "TransparentColor", "ColorRGB", "",1,1,1
      Property: "TransparencyFactor", "double", "",0.0000
      Property: "SpecularColor", "ColorRGB", "",${e.specular}
      Property: "SpecularFactor", "double", "",1.0000
      Property: "ShininessExponent", "double", "",${e.shininess}
      Property: "ReflectionColor", "ColorRGB", "",0,0,0
      Property: "ReflectionFactor", "double", "",1
      Property: "Ambient", "ColorRGB", "",1,1,1
      Property: "Diffuse", "ColorRGB", "",${e.diffuse}
      Property: "Specular", "ColorRGB", "",${e.specular}
      Property: "Shininess", "double", "",${e.shininess}
      Property: "Opacity", "double", "",${e.opacity}
      Property: "Reflectivity", "double", "",0
    }`}}class cp extends ap{constructor(e,t){super(e,t),this._data=e,this._version=t.miewVersion||"0.0-UNSPECIFIED",this._extractor=new BL}exportSync(){const e=new jL;if(!this._source)return this._result;const t=this._extractor.process(this._data);return t.version=this._version,this._result=e.getResult(t),this._result}}cp.formats=["fbx"];cp.SourceClass=Bi;const YL=new UL([lp,cp]),gs={loaders:tI,parsers:OL,exporters:YL},ko=new x.Color;class qL{constructor(){this._width=0,this._height=0,this._widthHalf=0,this._heightHalf=0,this._vector=new x.Vector3,this._viewMatrix=new x.Matrix4,this._projectionMatrix=new x.Matrix4,this._domElement=document.createElement("div"),this._domElement.style.overflow="hidden",this._domElement.style.position="absolute",this._domElement.style.top="0",this._domElement.style.zIndex="0",this._domElement.style.pointerEvents="none"}getElement(){return this._domElement}reset(){const e=this.getElement();for(;e.firstChild;)e.removeChild(e.firstChild)}setSize(e,t){this._width=e,this._height=t,this._widthHalf=this._width/2,this._heightHalf=this._height/2,this._domElement.style.width=`${e}px`,this._domElement.style.height=`${t}px`}_renderObject(e,t,n){function i(o,a,l){return ko.setHex(o),ko.lerp(a,l),`#${ko.getHexString()}`}function s(o){return ko.setHex(o),`#${ko.getHexString()}`}if(e instanceof Ff){if(this._vector.setFromMatrixPosition(e.matrixWorld),e.userData!==void 0&&e.userData.offset!==void 0){const h=new x.Vector3(e.userData.offset.x,e.userData.offset.y,0);this._vector.add(h.multiplyScalar(e.matrixWorld.getMaxScaleOnAxis()))}this._vector.applyMatrix4(this._viewMatrix);const o=this._vector.z>-t.near?"hidden":"visible",a=1e4*(t.far- -this._vector.z)/(t.far-t.near),l=e.getElement();if(typeof n.fog>"u")l.style.color=s(e.userData.color),e.userData.background!=="transparent"&&(l.style.background=s(e.userData.background));else{const h=x.MathUtils.smoothstep(-this._vector.z,n.fog.near,n.fog.far);l.style.color=i(e.userData.color,n.fog.color,h),e.userData.background!=="transparent"&&(l.style.background=i(e.userData.background,n.fog.color,h))}this._vector.applyMatrix4(this._projectionMatrix);const c=`${e.userData!=={}?e.userData.translation:"translate(-50%, -50%) "}translate(${this._vector.x*this._widthHalf+this._widthHalf}px,${-this._vector.y*this._heightHalf+this._heightHalf}px)`;l.style.visibility=o,l.style.WebkitTransform=c,l.style.MozTransform=c,l.style.oTransform=c,l.style.transform=c,l.style.zIndex=Number(a).toFixed(0),l.parentNode!==this._domElement&&this._domElement.appendChild(l)}for(let o=0,a=e.children.length;o<a;o++)this._renderObject(e.children[o],t,n)}render(e,t){e.updateMatrixWorld(),t.parent===null&&t.updateMatrixWorld(),t.matrixWorldInverse.copy(t.matrixWorld).invert(),this._viewMatrix.copy(t.matrixWorldInverse),this._projectionMatrix.copy(t.projectionMatrix),this._renderObject(e,t,e)}}const $L=qL;function Fy(){try{if(window.top.location.href!==void 0)return window.top}catch{}return window}const hp=37,up=38,dp=39,fp=40,St={NONE:-1,ROTATE:0,TRANSLATE:1,SCALE:2,TRANSLATE_PIVOT:3},ZL=.1,Id=new x.Quaternion,os=new x.Matrix4;function ki(r,e,t,n){this.objects=r,[this.object]=r,this.camera=e,this.pivot=t,this.axis=new x.Vector3(0,0,1),this.options=n,this.lastRotation={axis:new x.Vector3,angle:0}}ki.prototype._rotate=(function(){const r=new x.Vector3,e=new x.Quaternion,t=new x.Vector3,n=new x.Matrix4;return function(i){const s=this.pivot.x===0&&this.pivot.y===0&&this.pivot.z===0;if(n.copy(this.object.matrix),s?n.multiply(os.makeRotationFromQuaternion(i)):(n.multiply(os.makeTranslation(this.pivot.x,this.pivot.y,this.pivot.z)),n.multiply(os.makeRotationFromQuaternion(i)),n.multiply(os.makeTranslation(-this.pivot.x,-this.pivot.y,-this.pivot.z))),n.decompose(r,e,t),!s)for(let o=0;o<this.objects.length;++o)this.objects[o].position.copy(r);for(let o=0;o<this.objects.length;++o)this.objects[o].quaternion.copy(e),this.objects[o].updateMatrix()}})();ki.prototype.setObjects=function(r){this.objects=r,[this.object]=r};ki.prototype.rotate=(function(){const r={axis:new x.Vector3,angle:0};return function(e,t,n,i){this.mouse2rotation(r,t,n,i),e.setFromAxisAngle(r.axis,r.angle),r.angle&&this._rotate(e),this.lastRotation=r}})();ki.prototype.translate=(function(){const r=new x.Vector3,e=new x.Vector3;return function(t){r.set(t.x/this.camera.projectionMatrix.elements[0],t.y/this.camera.projectionMatrix.elements[5],0);let n=r.length();r.normalize(),r.transformDirection(os.copy(this.object.matrixWorld).invert()),e.copy(this.pivot),this.object.localToWorld(e),n*=Math.abs(e.z-this.camera.position.z),n/=this.object.matrixWorld.getMaxScaleOnAxis();for(let i=0;i<this.objects.length;++i)this.objects[i].translateOnAxis(r,n)}})();ki.prototype.update=(function(){const r=new x.Vector3;return function(e,t){if(te.now.autoRotation!==0)return te.now.autoRotationAxisFixed||this.lastRotation.axis.length()===0?r.set(0,1,0).transformDirection(os.copy(this.object.matrixWorld).invert()):r.copy(this.lastRotation.axis),this._rotate(Id.setFromAxisAngle(r,te.now.autoRotation*e)),!0;if(this.options.intertia&&this.lastRotation.angle){const n=this.lastRotation.angle*(1-this.options.dynamicDampingFactor)**(40*t);if(Math.abs(n)<=this.options.intertiaThreshold)this.lastRotation.angle=0;else return this._rotate(Id.setFromAxisAngle(this.lastRotation.axis,n)),!0}return!1}})();ki.prototype.stop=function(){this.lastRotation.angle=0};ki.prototype.mouse2rotation=(function(){const r=new x.Vector3,e=new x.Vector3,t=new x.Vector3,n=new x.Vector3,i=new x.Vector3,s=new x.Vector3,o=new x.Vector2;return function(a,l,c,h){if(h)a.axis.copy(this.axis),a.angle=this.options.axisRotateFactor*(c.y-l.y);else{o.subVectors(c,l);const u=o.length();if(u===0)return;r.copy(this.pivot),this.object.localToWorld(r),e.subVectors(this.camera.position,r),t.copy(e).normalize(),n.copy(this.camera.up).normalize(),i.crossVectors(n,t).normalize(),n.setLength(o.y),i.setLength(o.x),s.copy(n.add(i)),a.axis.crossVectors(s,e),a.angle=-u*this.options.rotateFactor}a.axis.transformDirection(os.copy(this.object.matrixWorld).invert()),a.angle<0&&(a.axis.negate(),a.angle=-a.angle)}})();function ut(r,e,t,n,i){Dn.call(this);const s=this;this.object=r,this.objectPivot=e,this.camera=t,this.domElement=typeof n<"u"?n:document,this.getAltObj=i,this.enabled=!0,this.hotkeysEnabled=!0,this.screen={left:0,top:0,width:0,height:0},this.options={rotateFactor:Math.PI,axisRotateFactor:4*Math.PI,intertia:!0,dynamicDampingFactor:.1,intertiaThreshold:.001},this._state=St.NONE,this._mousePrevPos=new x.Vector2,this._mouseCurPos=new x.Vector2,this._mainObj=new ki([this.object],this.camera,new x.Vector3(0,0,0),this.options),this._altObj=new ki([this.object],this.camera,new x.Vector3(0,0,0),this.options),this._affectedObj=this._mainObj,this._isAltObjFreeRotationAllowed=!0,this._isTranslationAllowed=!0,this._isKeysTranslatingObj=!1,this._pressedKeys=[],this._clock=new Qs,this._clock.start(),this._lastUpdateTime=this._clock.getElapsedTime(),this._listeners=[{obj:s.domElement,type:"mousedown",handler(o){s.mousedown(o)}},{obj:s.domElement,type:"mouseup",handler(o){s.mouseup(o)}},{obj:s.domElement,type:"mousemove",handler(o){s.mousemove(o)}},{obj:s.domElement,type:"mousewheel",handler(o){s.mousewheel(o)}},{obj:s.domElement,type:"DOMMouseScroll",handler(o){s.mousewheel(o)}},{obj:s.domElement,type:"mouseout",handler(o){s.mouseup(o)}},{obj:s.domElement,type:"touchstart",handler(o){s.touchstartend(o)}},{obj:s.domElement,type:"touchend",handler(o){s.touchstartend(o)}},{obj:s.domElement,type:"touchmove",handler(o){s.touchmove(o)}},{obj:s.getKeyBindObject(),type:"keydown",handler(o){s.keydownup(o)}},{obj:s.getKeyBindObject(),type:"keyup",handler(o){s.keydownup(o)}},{obj:window,type:"resize",handler(){s.handleResize()}},{obj:window,type:"blur",handler(){s.resetKeys()}},{obj:s.domElement,type:"contextmenu",handler(o){s.contextmenu(o)}}];for(let o=0;o<this._listeners.length;o++){const a=this._listeners[o];a.obj.addEventListener(a.type,a.handler)}this.handleResize(),this.resetKeys(),this.update()}ut.prototype=Object.create(Dn.prototype);ut.prototype.constructor=ut;ut.prototype.resetKeys=function(){this._pressedKeys[hp]=!1,this._pressedKeys[up]=!1,this._pressedKeys[dp]=!1,this._pressedKeys[fp]=!1};ut.prototype.contextmenu=function(r){r.stopPropagation(),r.preventDefault()};ut.prototype.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{const r=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=r.left+window.pageXOffset-e.clientLeft,this.screen.top=r.top+window.pageYOffset-e.clientTop,this.screen.width=r.width,this.screen.height=r.height}};ut.prototype.enable=function(r){this.enabled=r};ut.prototype.enableHotkeys=function(r){this.hotkeysEnabled=r};ut.prototype.allowTranslation=function(r){this._isTranslationAllowed=r};ut.prototype.allowAltObjFreeRotation=function(r){this._isAltObjFreeRotationAllowed=r};ut.prototype.keysTranslateObj=function(r){this._isKeysTranslatingObj=r};ut.prototype.isEditingAltObj=function(){return(this._state===St.ROTATE||this._state===St.TRANSLATE)&&this._affectedObj===this._altObj};ut.prototype.convertMouseToOnCircle=function(r,e,t){const n=Math.min(this.screen.width,this.screen.height);if(n===0){r.set(0,0);return}r.set((e-this.screen.width*.5-this.screen.left)/n,(.5*this.screen.height+this.screen.top-t)/n)};ut.prototype.convertMouseToViewport=function(r,e,t){if(this.screen.width===0||this.screen.height===0){r.set(0,0);return}r.set(2*(e-this.screen.width*.5-this.screen.left)/this.screen.width,2*(.5*this.screen.height+this.screen.top-t)/this.screen.height)};ut.prototype.stop=function(){this._mainObj.stop(),this._altObj.stop()};ut.prototype.rotateByMouse=(function(){const r=new x.Quaternion;return function(e){this._affectedObj.rotate(r,this._mousePrevPos,this._mouseCurPos,e),this.dispatchEvent({type:"change",action:"rotate",quaternion:r})}})();ut.prototype.rotate=function(r){this.object.quaternion.multiply(r),this.dispatchEvent({type:"change",action:"rotate",quaternion:r})};ut.prototype.getOrientation=function(){return this.object.quaternion};ut.prototype.setOrientation=function(r){this.object.quaternion.copy(r)};ut.prototype.translate=(function(){const r=new x.Vector2;return function(){r.subVectors(this._mouseCurPos,this._mousePrevPos),this._affectedObj.translate(r),this.dispatchEvent({type:"change",action:"translate"})}})();ut.prototype.getScale=function(){return this.object.scale.x};ut.prototype.setScale=function(r){this.object.scale.set(r,r,r)};ut.prototype.scale=function(r){r<=0||(this.setScale(this.object.scale.x*r),this.dispatchEvent({type:"change",action:"zoom",factor:r}))};ut.prototype.update=(function(){const r=new x.Vector2;return function(){const e=this._clock.getElapsedTime(),t=e-this._lastUpdateTime;if(this._state===St.NONE){const n=e-this._lastMouseMoveTime;(this._mainObj.update(t,n)||this._altObj.update(t,n))&&this.dispatchEvent({type:"change",action:"auto"})}if(this._isKeysTranslatingObj){const n=Number(this._pressedKeys[dp])-Number(this._pressedKeys[hp]),i=Number(this._pressedKeys[up])-Number(this._pressedKeys[fp]);if(n!==0||i!==0){const s=t,o=this.getAltObj();o.objects.length>0&&(this._altObj.setObjects(o.objects),this._altObj.pivot=o.pivot,"axis"in o?this._altObj.axis=o.axis.clone():this._altObj.axis.set(0,0,1),r.set(s*n,s*i),this._altObj.translate(r),this.dispatchEvent({type:"change",action:"translate"}))}}this._lastUpdateTime=e}})();ut.prototype.reset=function(){this._state=St.NONE,this.object.quaternion.copy(Id.set(0,0,0,1))};ut.prototype.mousedown=function(r){if(!(this.enabled===!1||this._state!==St.NONE)){if(r.preventDefault(),r.stopPropagation(),this._state===St.NONE)if(r.button===0){this._affectedObj.stop();let e=!1;if(r.altKey){const t=this.getAltObj();e=t.objects.length>0,e&&(this._altObj.setObjects(t.objects),this._altObj.pivot=t.pivot,"axis"in t?this._altObj.axis=t.axis.clone():this._altObj.axis.set(0,0,1))}this._affectedObj=e?this._altObj:this._mainObj,this._state=e&&r.ctrlKey&&this._isTranslationAllowed?St.TRANSLATE:St.ROTATE}else r.button===2&&(this._state=St.TRANSLATE_PIVOT);this._state===St.ROTATE&&(this.convertMouseToOnCircle(this._mouseCurPos,r.pageX,r.pageY),this._mousePrevPos.copy(this._mouseCurPos)),(this._state===St.TRANSLATE||this._state===St.TRANSLATE_PIVOT)&&(this.convertMouseToViewport(this._mouseCurPos,r.pageX,r.pageY),this._mousePrevPos.copy(this._mouseCurPos))}};ut.prototype.mousemove=function(r){if(!(this.enabled===!1||this._state===St.NONE))switch(r.preventDefault(),r.stopPropagation(),this._state){case St.ROTATE:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToOnCircle(this._mouseCurPos,r.pageX,r.pageY),this.rotateByMouse(r.altKey&&!this._isAltObjFreeRotationAllowed||r.shiftKey),this._lastMouseMoveTime=this._clock.getElapsedTime();break;case St.TRANSLATE:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToViewport(this._mouseCurPos,r.pageX,r.pageY),this.translate();break;case St.TRANSLATE_PIVOT:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToViewport(this._mouseCurPos,r.pageX,r.pageY),this.translatePivotByMouse();break}};ut.prototype.mousewheel=function(r){if(this.enabled===!1||!te.now.zooming||this._state!==St.NONE||r.shiftKey)return;r.preventDefault();let e=0;r.wheelDelta?e=r.wheelDelta/40:r.detail&&(e=-r.detail/3);let t=1+e*.05;t=Math.max(t,.01),this.scale(t)};ut.prototype.mouseup=function(r){this.enabled===!1||this._state===St.NONE||(r.preventDefault(),r.stopPropagation(),this._state=St.NONE,this._clock.getElapsedTime()-this._lastMouseMoveTime>ZL&&this._affectedObj.stop())};ut.prototype.touchstartend=function(r){if(this.enabled!==!1)switch(r.preventDefault(),r.stopPropagation(),r.touches.length){case 1:this._state=St.ROTATE,this.convertMouseToOnCircle(this._mouseCurPos,r.touches[0].pageX,r.touches[0].pageY),this._mousePrevPos.copy(this._mouseCurPos);break;case 2:{this._mainObj.stop(),this._altObj.stop(),this._state=St.SCALE;const e=r.touches[0].pageX-r.touches[1].pageX,t=r.touches[0].pageY-r.touches[1].pageY;this._touchDistanceCur=this._touchDistanceStart=Math.sqrt(e*e+t*t),this._scaleStart=this.object.scale.x;break}default:this._state=St.NONE}};ut.prototype.touchmove=function(r){if(!(this.enabled===!1||this._state===St.NONE))switch(r.preventDefault(),r.stopPropagation(),this._state){case St.ROTATE:this._mousePrevPos.copy(this._mouseCurPos),this.convertMouseToOnCircle(this._mouseCurPos,r.touches[0].pageX,r.touches[0].pageY),this.rotateByMouse(!1),this._lastMouseMoveTime=this._clock.getElapsedTime();break;case St.SCALE:if(te.now.zooming){const e=r.touches[0].pageX-r.touches[1].pageX,t=r.touches[0].pageY-r.touches[1].pageY;this._touchDistanceCur=Math.sqrt(e*e+t*t);const i=this._scaleStart*this._touchDistanceCur/this._touchDistanceStart/this.object.scale.x;this.scale(i)}break}};ut.prototype.keydownup=function(r){if(!(this.enabled===!1||this.hotkeysEnabled===!1))switch(r.keyCode){case hp:case up:case dp:case fp:this._pressedKeys[r.keyCode]=r.type==="keydown",r.preventDefault(),r.stopPropagation();break}};ut.prototype.getKeyBindObject=function(){return Fy()};ut.prototype.dispose=function(){for(let r=0;r<this._listeners.length;r++){const e=this._listeners[r];e.obj.removeEventListener(e.type,e.handler)}};ut.prototype.translatePivotByMouse=(function(){const r=new x.Vector2;return function(){r.subVectors(this._mouseCurPos,this._mousePrevPos),this.translatePivotInWorld(te.now.translationSpeed*r.x,te.now.translationSpeed*r.y,0)}})();ut.prototype.translatePivotInWorld=function(r,e,t){const n=this.objectPivot.position;n.applyMatrix4(this.object.matrixWorld),n.setX(n.x+r),n.setY(n.y+e),n.setZ(n.z+t),n.applyMatrix4(os.copy(this.object.matrixWorld).invert()),this.dispatchEvent({type:"change",action:"translatePivot"})};ut.prototype.translatePivot=function(r,e,t){const n=this.objectPivot.position;n.setX(n.x+r),n.setY(n.y+e),n.setZ(n.z+t),this.dispatchEvent({type:"change",action:"translatePivot"})};ut.prototype.setPivot=function(r){this.objectPivot.position.copy(r),this.dispatchEvent({type:"change",action:"translatePivot"})};const KL=ut;function vn(r,e,t){Dn.call(this);const n=this;this.gfxObj=r,this.camera=e,this.domElement=typeof t<"u"?t:document,this.screen={left:0,top:0,width:0,height:0},this._lastMousePos=new x.Vector2(0,0),this._mouseTotalDist=0,this._lastClickBeginTime=-1e3,this._lastClickPos=new x.Vector2(0,0),this._clickBeginTime=0,this._clock=new Qs,this._clock.start(),this._listeners=[{obj:n.domElement,type:"mousedown",handler(i){n.mousedown(i)}},{obj:n.domElement,type:"mouseup",handler(i){n.mouseup(i)}},{obj:n.domElement,type:"mousemove",handler(i){n.mousemove(i)}},{obj:n.domElement,type:"touchstart",handler(i){n.touchstart(i)}},{obj:n.domElement,type:"touchend",handler(i){n.touchend(i)}},{obj:window,type:"resize",handler(){n.handleResize()}}];for(let i=0;i<this._listeners.length;i++){const s=this._listeners[i];s.obj.addEventListener(s.type,s.handler)}this.handleResize()}vn.prototype=Object.create(Dn.prototype);vn.prototype.constructor=vn;vn.prototype.reset=function(){this.picked={},this.dispatchEvent({type:"newpick",obj:{}})};vn.prototype.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{const r=this.domElement.getBoundingClientRect(),e=this.domElement.ownerDocument.documentElement;this.screen.left=r.left+window.pageXOffset-e.clientLeft,this.screen.top=r.top+window.pageYOffset-e.clientTop,this.screen.width=r.width,this.screen.height=r.height}};vn.prototype.pickObject=function(r){if(!this.gfxObj){this.picked={},this.dispatchEvent({type:"newpick",obj:{}});return}const{gfxObj:e}=this,t=new x.Raycaster;t.ray.origin.setFromMatrixPosition(this.camera.matrixWorld),t.ray.direction.set(r.x,r.y,.5).unproject(this.camera).sub(t.ray.origin).normalize();const n=te.now.draft.clipPlane&&this.clipPlaneValue?this.clipPlaneValue:1/0,i=te.now.fog&&this.fogFarValue?this.fogFarValue:1/0,s=t.intersectVisibleObject(e,this.camera,n,i);if(!s){this.picked={},this.dispatchEvent({type:"newpick",obj:{}});return}let o={};if(s.residue||s.atom){const a=s.residue||s.atom.residue;te.now.pick==="chain"?o={chain:a.getChain()}:te.now.pick==="molecule"?o={molecule:a.getMolecule()}:s.residue||te.now.pick==="residue"?o={residue:a}:s.atom&&(o={atom:s.atom})}this.picked=o,this.dispatchEvent({type:"newpick",obj:o})};vn.prototype.getMouseInViewport=function(r,e){return new x.Vector2((r-this.screen.left)/this.screen.width*2-1,-(e-this.screen.top)/this.screen.height*2+1)};vn.prototype.mousedown=function(r){r.preventDefault(),r.stopPropagation(),r.button===0&&(this._lastMousePos=this.getMouseInViewport(r.pageX,r.pageY),this._mouseTotalDist=0,this._clickBeginTime=this._clock.getElapsedTime())};vn.prototype.mousemove=function(r){r.preventDefault(),r.stopPropagation();const e=this.getMouseInViewport(r.pageX,r.pageY);this._mouseTotalDist+=e.sub(this._lastMousePos).length()};vn.prototype.mouseup=function(r){const e=this;if(r.preventDefault(),r.stopPropagation(),r.button===0&&this._mouseTotalDist<.01){const t=this._clock.getElapsedTime(),n=this.getMouseInViewport(r.pageX,r.pageY);if(t-this._lastClickBeginTime<.7&&new x.Vector2().subVectors(n,this._lastClickPos).length()<.01){this.dispatchEvent({type:"dblclick",obj:this.picked}),this._lastClickPos=n,this._lastClickBeginTime=-1e3;return}setTimeout(()=>{e.pickObject(n)},0),this._lastClickPos=n,this._lastClickBeginTime=this._clickBeginTime}};vn.prototype.touchstart=function(r){r.preventDefault(),r.stopPropagation(),r.touches.length===1&&(this._lastTouchdownPos=this.getMouseInViewport(r.touches[0].pageX,r.touches[0].pageY))};vn.prototype.touchend=function(r){const e=this;r.preventDefault(),r.stopPropagation(),r.touches.length===0&&r.changedTouches.length===1&&this.getMouseInViewport(r.changedTouches[0].pageX,r.changedTouches[0].pageY).sub(this._lastTouchdownPos).length()<.01&&setTimeout(()=>{e.pickObject(e._lastTouchdownPos)},0)};vn.prototype.dispose=function(){for(let r=0;r<this._listeners.length;r++){const e=this._listeners[r];e.obj.removeEventListener(e.type,e.handler)}};const JL=vn;class QL{constructor(e,t){this._target=e,this._targetCamera=t,this._camera=new x.PerspectiveCamera(t.fov,t.aspect,1,100),this._object=new x.AxesHelper(1),this._scene=new x.Scene,this._scene.add(this._object),this._full=new x.Vector2,this._update()}_update(){const{fov:e}=this._targetCamera,t=this._camera;t.aspect=this._targetCamera.aspect,t.setMinimalFov(e),t.setDistanceToFit(1,e),t.updateProjectionMatrix(),this._object.quaternion.copy(this._target.quaternion)}render(e){this._update(),e.getSize(this._full);const t=this._full.width*.25,n=this._full.height*.25,{autoClear:i}=e;e.autoClear=!1,e.setViewport(0,0,t,n),e.clear(!1,!0,!1),e.render(this._scene,this._camera),e.setViewport(0,0,this._full.width,this._full.height),e.autoClear=i}}const eN=QL,tN=12,nN=268435200,iN=8,sN=255,rN=12,oN=4293918720,aN=20,lN=1048575,cN=4026531840,hN=28,uN=1<<19,dN=1<<20,fN=1,pN=2,mN=["helix","strand"],i_=["fs","ps","ns","us"];function gN(r,e){const t=e._residues,n=t.length,i=new Uint8Array(n),s=e._atoms;for(let l=0,c=r.length;l<c;++l){const h=s[l];i[h.residue._index]=r[l]}const o=[];let a=0;for(;a<n;){if(i[a]!==0){const l=a,c=i[a];for(;a<n-1&&i[a+1]===c&&t[a].isConnected(t[a+1]);)++a;o.push({start:l,end:a,type:mN[c-1]})}++a}return o}function Nu(r){return r>=uN?r-dN:r}class pp{constructor(e,t,n){this._complex=e,this._secondary=null,this.isLoading=!1,this._framesRange={start:0,end:-1},this.frameIsReady=!1,this._buffer=null,this._frameRequest=null,this._callbacks=n,typeof t=="function"?(this._framesRequestLength=1,this._downloadDataFn=t):this.parseBinaryData(t,!0),this.reset(),this.setFrame(0)}_prepareBuffer(e,t){if(e==null&&(e=0),t==null&&(t=e+this._framesRequestLength),this._framesCount!==void 0&&(t=Math.min(this._framesCount-1,t)),this._downloadDataFn){const n=this,i=function(o){if(n.isLoading=!1,n._callbacks&&typeof n._callbacks.onLoadStatusChanged=="function"&&n._callbacks.onLoadStatusChanged(),n._buffer={data:o,state:"ready",start:e,end:t},n._frameRequest!==null){const a=n._frameRequest;n._frameRequest=null,n.setFrame(a)}},s=function(){n.isLoading=!1,n._callbacks&&typeof n._callbacks.onError=="function"&&n._callbacks.onError("Streaming failed")};this._buffer||(this._buffer={}),this._buffer.state="downloading",this.isLoading=!0,n._callbacks&&typeof n._callbacks.onLoadStatusChanged=="function"&&n._callbacks.onLoadStatusChanged(),this._downloadDataFn({start:e,end:t+1},i,s)}}_parseBuffer(){if(this._buffer&&this._buffer.state==="ready"){this._framesRange={start:this._buffer.start,end:this._buffer.end},this.parseBinaryData(this._buffer.data,!1);let e=(this._buffer.end+1)%this._framesCount;if(e>=this._framesCount&&(e=0),this._buffer={state:"none"},this._prepareBuffer(e,e+this._framesRequestLength),this._frameRequest!==null){const t=this._frameRequest;this._frameRequest=null,this.setFrame(t)}}}parseBinaryData(e){const t=new DataView(e);let n=0;const i=t.getUint32(n,!0);n+=4;const s=t.getUint32(n,!0);this._framesCount=s,this._framesRange.end=this._framesRange.end>0?Math.min(this._framesRange.end,s-1):s-1,n+=4,this._atomsCount=i;const o=1024*1024;this._framesRequestLength=Math.ceil(o/(i*8));const a=this._framesRange.end-this._framesRange.start+1;if(i!==this._complex._atoms.length||e.byteLength!==tN+a*i*8)throw new Error;const l=this._complex;let c=t.getUint32(n,!0),h=0;for(;c>1e3&&h<i_.length-1;)c/=1e3,++h;this._timeStep=`${c.toString()} ${i_[h]}`,n+=4;const u=[],d=new Float32Array(a*i*3);let f=0;const p=new Int8Array(i);for(let _=0;_<a;++_){for(let g=0;g<i;++g){const m=t.getUint32(n,!0);n+=4;const v=t.getUint32(n,!0);n+=4;const y=(v&cN)>>>hN,S=Nu((v&nN)>>>iN>>0),b=Nu(((v&sN)<<rN|(m&oN)>>>aN)>>0),M=Nu((m&lN)>>0);p[g]=0,y>0&&y<4?p[g]=fN:y===4&&(p[g]=pN),d[f++]=S/100,d[f++]=b/100,d[f++]=M/100}u.push(gN(p,l))}this._secondaryData=u,this._data=d}nextFrame(){this.setFrame((this._currFrame+1)%this._framesCount)}needsColorUpdate(e){return e instanceof Sy}getAtomColor(e,t){return e.getResidueColor(this._residues[t.residue._index],this._complex)}getResidueColor(e,t){return e.getResidueColor(this._residues[t._index],this._complex)}_updateSecondary(){let e;const t=this._residues;let n=t.length;for(e=0;e<n;++e)t[e]._secondary=null;const i=this._secondaryData[this._currFrame-this._framesRange.start];for(e=0,n=i.length;e<n;++e){const s=i[e],{start:o,end:a}=s,l={_start:t[o],_end:t[a],type:s.type,generic:s.generic};for(let c=o;c<=a;++c)t[c]._secondary=l}}reset(){const e=this._complex._residues,t=e.length;this._residues=new Array(t);const n=this._residues,i=function(){return this._secondary};for(let s=0;s<t;++s)n[s]={_type:e[s]._type,_isValid:e[s]._isValid,_controlPoint:null,_wingVector:null,_secondary:null,getSecondary:i}}setFrame(e){if(this.frameIsReady=!1,e>=this._framesRange.start&&e<=this._framesRange.end)this._currFrame=e,this._cachedResidues=!1,this._updateSecondary(),this.frameIsReady=!0;else if(this._frameRequest=e,!this._buffer)this._prepareBuffer(e);else{const t=this;switch(this._buffer.state){case"none":this._prepareBuffer(e);break;case"ready":t._parseBuffer();break}}}disableEvents(){this._callbacks=null}static _vec=new x.Vector3;getAtomPos(e){const t=pp._vec,n=this,i=n._data,s=(n._atomsCount*(n._currFrame-n._framesRange.start)+e)*3;return t.set(i[s],i[s+1],i[s+2]),t}getResidues(){return this._cachedResidues?this._residues:(this._complex.updateToFrame(this),this._residues)}}const _N=pp;class vh{constructor(e,t){if(this.constructor===vh)throw new Error("Can not instantiate abstract class!");this.params=e,this.opts=de.default.merge(be.deriveDeep(te.now.objects[this.type],!0),t),this.needsRebuild=!1,this._mesh=null,this.id=null}identify(){const e={type:this.type,params:this.params},t=be.objectsDiff(this.opts,te.now.modes[this.id]);return de.default.isEmpty(t)||(e.opts=t),e}toString(){const e=`o=${this.type},${this.params.join(",")}`,t=be.compareOptionsWithDefaults(this.opts,te.defaults.objects[this.type]);return e+t}getGeometry(){return this._mesh}destroy(){this._mesh&&Je.destroyObject(this._mesh)}}vh.prototype.type="__";const yN=vh;class Ec extends yN{constructor(e,t){if(super(e,t),e.length<2)throw new Error("Wrong number of argumets on line object creation!");[this._id1,this._id2]=e}_getAtomFromName(e,t){const n=" - Wrong atom format it must be '#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME' (e.g. 'A.38.CO1')",i=e.getAtomByFullname(t);if(!i)throw new Error(t+n);return i}build(e){const t=new x.BufferGeometry;this._atom1=this._getAtomFromName(e,this._id1),this._atom2=this._getAtomFromName(e,this._id2);const n=this._atom1.position,i=this._atom2.position,s=new Float32Array([n.x,n.y,n.z,i.x,i.y,i.z]);t.setAttribute("position",new x.BufferAttribute(s,3)),t.computeBoundingBox(),this._line=new kn.Line(t,new xi({lights:!1,overrideColor:!0,dashedLine:!0,fogTransparent:te.now.bg.transparent})),this._line.computeLineDistances(),this._line.material.setUberOptions({fixedColor:new x.Color(this.opts.color),dashedLineSize:this.opts.dashSize,dashedLinePeriod:this.opts.dashSize+this.opts.gapSize}),this._line.material.updateUniforms(),this._line.raycast=function(a,l){},this._mesh=this._line;const o=e.getTransforms();o.length>0&&(this._mesh=new x.Group,this._mesh.add(this._line),io.applyTransformsToMeshes(this._mesh,o))}updateToFrame(e){if(!this._atom1||!this._atom2||!this._line)return;const t=this._line.geometry;t.vertices[0].copy(e.getAtomPos(this._atom1.index)),t.vertices[1].copy(e.getAtomPos(this._atom2.index)),this._line.computeLineDistances(),t.computeBoundingSphere(),t.verticesNeedUpdate=!0}}Ec.prototype.constructor=Ec;Ec.prototype.type="line";const s_=Ec,xN=`precision highp float;\r
\r
uniform sampler2D srcTex;\r
uniform vec2 srcTexSize;\r
uniform vec2 thickness;\r
varying vec2 vUv;\r
\r
#ifdef DEPTH_OUTLINE\r
  uniform sampler2D srcDepthTex; //depthTexture\r
  uniform vec3 color;\r
  uniform float threshold;\r
#endif\r
\r
void main() {\r
\r
  vec2 pixelSize = thickness / srcTexSize;\r
\r
  #ifdef DEPTH_OUTLINE\r
    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r
    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r
    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r
    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r
    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r
    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r
    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r
    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r
\r
    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r
    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r
\r
    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r
\r
    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r
\r
  #else\r
    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r
    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r
    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r
    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r
    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r
    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r
    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r
    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r
\r
    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r
    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r
\r
    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r
    gl_FragColor = grad;\r
  #endif\r
}\r
`;class zy extends x.RawShaderMaterial{constructor(e){super(e);const t={uniforms:{srcTex:{type:"t",value:null},srcDepthTex:{type:"t",value:null},srcTexSize:{type:"v2",value:new x.Vector2(512,512)},color:{type:"v3",value:null},threshold:{type:"f",value:null},opacity:{type:"f",value:1},thickness:{type:"v2",value:new x.Vector2(1,1)}},vertexShader:bs,fragmentShader:xN,transparent:!0,depthTest:!1,depthWrite:!1};this.setValues(t)}copy(e){super.copy(e),this.depth=e.depth}setValues(e){if(typeof e>"u")return;super.setValues(e);const t={};this.depth&&(t.DEPTH_OUTLINE=1),this.defines=t}}zy.prototype.depth=!1;const Vy=zy,vN=`precision highp float;\r
\r
// edge end finding algorithm parameters\r
#define FXAA_QUALITY_PS 8\r
#define FXAA_QUALITY_P0 1.0\r
#define FXAA_QUALITY_P1 1.5\r
#define FXAA_QUALITY_P2 2.0\r
#define FXAA_QUALITY_P3 2.0\r
#define FXAA_QUALITY_P4 2.0\r
#define FXAA_QUALITY_P5 2.0\r
#define FXAA_QUALITY_P6 4.0\r
#define FXAA_QUALITY_P7 12.0\r
// constants\r
float fxaaQualityEdgeThreshold = 0.125;\r
float fxaaQualityEdgeThresholdMin = 0.0625;\r
float fxaaQualitySubpix = 0.7; //0.65;\r
// global params\r
uniform sampler2D srcTex;\r
uniform vec2 srcTexelSize;\r
uniform vec3 bgColor;\r
// from vs\r
varying vec2 vUv;\r
//=====================================================================//\r
// calc luminance from rgb\r
//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r
float FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r
                                                                           // for non-real scene rendering\r
// texture sampling by pixel position(coords) and offset(in pixels)\r
 vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r
  #ifdef BG_TRANSPARENT\r
    vec4 color = texture2D( tex, pos + off * res );\r
    return mix(color.rgb, bgColor, 1.0 - color.a);\r
  #else\r
    return texture2D( tex, pos + off * res ).xyz;\r
  #endif\r
}\r
vec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r
  #ifdef BG_TRANSPARENT\r
    vec4 color = texture2D( tex, pos );\r
    return mix(color.rgb, bgColor, 1.0 - color.a);\r
  #else\r
    return texture2D( tex, pos).xyz;\r
  #endif\r
}\r
vec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r
  return texture2D( tex, pos);\r
}\r
\r
//=====================================================================//\r
void main() {\r
  // renaming\r
  vec2 posM = vUv;\r
  // get luminance for neighbours\r
  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r
  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r
  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r
  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r
  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r
  // find max and min luminance\r
  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r
  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r
  // calc maximum non-edge range\r
  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r
  float range = rangeMax - rangeMin;\r
  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r
  // exit when luma contrast is small (is not edge)\r
  if(range < rangeMaxClamped){\r
    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r
    return;\r
  }\r
  float subpixRcpRange = 1.0/range;\r
  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r
  // visibly, thus we decided to leave calculation here for better readability.\r
  // calc other neighbours luminance\r
  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r
  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r
  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r
  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r
/*--------------span calculation and subpix amount calulation-----------------*/\r
  float lumaNS = lumaN + lumaS;\r
  float lumaWE = lumaW + lumaE;\r
  float subpixNSWE = lumaNS + lumaWE;\r
  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r
  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r
/*--------------------------------------------------------------------------*/\r
  float lumaNESE = lumaNE + lumaSE;\r
  float lumaNWNE = lumaNW + lumaNE;\r
  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r
  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r
/*--------------------------------------------------------------------------*/\r
  float lumaNWSW = lumaNW + lumaSW;\r
  float lumaSWSE = lumaSW + lumaSE;\r
  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r
  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r
  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r
  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r
  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r
  float edgeVert = abs(edgeVert3) + edgeVert4;\r
/*--------------------subpix amount calulation------------------------------*/\r
  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r
  float lengthSign = srcTexelSize.x;\r
  bool horzSpan = edgeHorz >= edgeVert;\r
   // debug  code edge span visualization\r
/*'  if (horzSpan)\r
      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r
  else\r
    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r
  return;*/\r
  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r
/*--------------------------------------------------------------------------*/\r
  if(!horzSpan) lumaN = lumaW;\r
  if(!horzSpan) lumaS = lumaE;\r
  if(horzSpan) lengthSign = srcTexelSize.y;\r
  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r
/*--------------------------------------------------------------------------*/\r
  float gradientN = lumaN - lumaM;\r
  float gradientS = lumaS - lumaM;\r
  float lumaNN = lumaN + lumaM;\r
  float lumaSS = lumaS + lumaM;\r
  bool pairN = abs(gradientN) >= abs(gradientS);\r
  float gradient = max(abs(gradientN), abs(gradientS));\r
  if(pairN) lengthSign = -lengthSign;\r
  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r
/*--------------------------------------------------------------------------*/\r
  vec2 posB;\r
  posB = posM;\r
  vec2 offNP;\r
  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r
  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r
  if(!horzSpan) posB.x += lengthSign * 0.5;\r
  if( horzSpan) posB.y += lengthSign * 0.5;\r
/*--------------------------------------------------------------------------*/\r
  vec2 posN;\r
  posN = posB - offNP * FXAA_QUALITY_P0;\r
  vec2 posP;\r
  posP = posB + offNP * FXAA_QUALITY_P0;\r
  float subpixD = ((-2.0)*subpixC) + 3.0;\r
  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r
  float subpixE = subpixC * subpixC;\r
  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r
/*--------------------------------------------------------------------------*/\r
  if(!pairN) lumaNN = lumaSS;\r
  float gradientScaled = gradient * 1.0/4.0;\r
  float lumaMM = lumaM - lumaNN * 0.5;\r
  float subpixF = subpixD * subpixE;\r
  bool lumaMLTZero = lumaMM < 0.0;\r
/*---------------------looped edge-end search-------------------------------*/\r
  lumaEndN -= lumaNN * 0.5;\r
  lumaEndP -= lumaNN * 0.5;\r
  bool doneN = abs(lumaEndN) >= gradientScaled;\r
  bool doneP = abs(lumaEndP) >= gradientScaled;\r
  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r
  bool doneNP = (!doneN) || (!doneP);\r
  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r
/*--------------------------------------------------------------------------*/\r
  if(doneNP) {\r
    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r
    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r
    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r
    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r
    doneN = abs(lumaEndN) >= gradientScaled;\r
    doneP = abs(lumaEndP) >= gradientScaled;\r
    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r
    doneNP = (!doneN) || (!doneP);\r
    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r
/*--------------------------------------------------------------------------*/\r
    #if (FXAA_QUALITY_PS > 3)\r
      if(doneNP) {\r
        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r
        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r
        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r
        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r
        doneN = abs(lumaEndN) >= gradientScaled;\r
        doneP = abs(lumaEndP) >= gradientScaled;\r
        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r
        doneNP = (!doneN) || (!doneP);\r
        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r
/*--------------------------------------------------------------------------*/\r
        #if (FXAA_QUALITY_PS > 4)\r
          if(doneNP) {\r
            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r
            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r
            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r
            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r
            doneN = abs(lumaEndN) >= gradientScaled;\r
            doneP = abs(lumaEndP) >= gradientScaled;\r
            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r
            doneNP = (!doneN) || (!doneP);\r
            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r
/*--------------------------------------------------------------------------*/\r
            #if (FXAA_QUALITY_PS > 5)\r
               if(doneNP) {\r
                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r
                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r
                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r
                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r
                 doneN = abs(lumaEndN) >= gradientScaled;\r
                 doneP = abs(lumaEndP) >= gradientScaled;\r
                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r
                 doneNP = (!doneN) || (!doneP);\r
                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r
/*--------------------------------------------------------------------------*/\r
                 #if (FXAA_QUALITY_PS > 6)\r
                   if(doneNP) {\r
                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r
                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r
                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r
                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r
                     doneN = abs(lumaEndN) >= gradientScaled;\r
                     doneP = abs(lumaEndP) >= gradientScaled;\r
                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r
                     doneNP = (!doneN) || (!doneP);\r
                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r
/*--------------------------------------------------------------------------*/\r
                     #if (FXAA_QUALITY_PS > 7)\r
                       if(doneNP) {\r
                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r
                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r
                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r
                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r
                         doneN = abs(lumaEndN) >= gradientScaled;\r
                         doneP = abs(lumaEndP) >= gradientScaled;\r
                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r
                         doneNP = (!doneN) || (!doneP);\r
                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r
/*--------------------------------------------------------------------------*/\r
                       }\r
                     #endif\r
                   }\r
                 #endif\r
               }\r
             #endif\r
           }\r
         #endif\r
      }\r
    #endif\r
  }\r
/*----------------calculate subpix offset due to edge ends-------------------*/\r
  float dstN = posM.x - posN.x;\r
  float dstP = posP.x - posM.x;\r
  if(!horzSpan) dstN = posM.y - posN.y;\r
  if(!horzSpan) dstP = posP.y - posM.y;\r
/*--------------------------------------------------------------------------*/\r
  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r
  float spanLength = (dstP + dstN);\r
  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r
  float spanLengthRcp = 1.0 / spanLength;\r
/*--------------------------------------------------------------------------*/\r
  bool directionN = dstN < dstP;\r
  float dst = min(dstN, dstP);\r
  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r
  float subpixG = subpixF * subpixF;\r
  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r
  float subpixH = subpixG * fxaaQualitySubpix;\r
/*-----------------calc texture offest using subpix-------------------------*/\r
  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r
  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r
\r
  float offset = pixelOffsetSubpix * lengthSign;\r
  #ifdef BG_TRANSPARENT\r
    // get original texel\r
    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r
    // calc step to blended texel\r
    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r
    // get neighboring texel\r
    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r
    //  calc blend factor from offset\r
    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r
    f = abs(f);\r
    // calc alpha (special formula to emulate blending with bg)\r
    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r
    // calc color (special formula to emulate blending with bg)\r
    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r
  #else\r
    if(!horzSpan) {\r
       posM.x += offset;\r
    } else {\r
       posM.y += offset;\r
    }\r
    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r
  #endif\r
  return;\r
}\r
`;class By extends x.RawShaderMaterial{constructor(e){super(e),this.setValues.call(this,{uniforms:{srcTex:{type:"t",value:null},srcTexelSize:{type:"v2",value:new x.Vector2(1/512,1/512)},bgColor:{type:"c",value:new x.Color(16777215)}},vertexShader:bs,fragmentShader:vN,transparent:!1,depthTest:!1,depthWrite:!1}),this.setValues(e)}copy(e){super.copy(e),this.depth=e.depth}setValues(e){if(typeof e>"u")return;super.setValues(e);const t={};this.bgTransparent&&(t.BG_TRANSPARENT=1),this.defines=t}}By.prototype.bgTransparent=!1;const SN=By,bN=`precision highp float;\r
#define EPSILON 0.0000001\r
\r
#define MAX_SAMPLES_COUNT 32\r
uniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r
uniform sampler2D noiseTexture;\r
uniform vec2      noiseTexelSize;\r
uniform sampler2D diffuseTexture;\r
uniform sampler2D depthTexture;\r
uniform sampler2D normalTexture;\r
uniform vec2      srcTexelSize;\r
uniform vec2      camNearFar;\r
uniform mat4      projMatrix;\r
\r
uniform float aspectRatio;\r
uniform float tanHalfFOV;\r
\r
uniform float kernelRadius;\r
uniform float depthThreshold;\r
uniform float factor;\r
\r
varying vec2 vUv;\r
\r
float CalcViewZ(vec2 screenPos)\r
{\r
  float depth = texture2D(depthTexture, screenPos).x;\r
  // [0, 1]->[-1, 1]\r
  float clipedZ = 2.0 * depth - 1.0;\r
  // see THREE.js camera.makeFrustum for projection details\r
  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r
}\r
\r
vec3 ViewPosFromDepth(vec2 screenPos)\r
{\r
  vec3 viewPos;\r
  viewPos.z = CalcViewZ(screenPos);\r
  //[0, 1]->[-1, 1]\r
  vec2 projPos = 2.0 * screenPos - 1.0;\r
  // reconstruct viewposition in right-handed sc with z to viewer\r
  viewPos.xy = vec2(\r
                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r
                    projPos.y * tanHalfFOV * abs(viewPos.z)\r
                   );\r
  return viewPos;\r
}\r
\r
void main() {\r
  vec3 viewPos = ViewPosFromDepth(vUv);\r
  // remap coordinates to prevent noise exture rescale\r
  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r
  vec4 normalData = texture2D(normalTexture, vUv);\r
  // return for background fragments (their normals are zero vectors)\r
  if (length(normalData.rgb) < EPSILON) {\r
    // 0.0 in alpha component means that it is background fragment\r
    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r
    return;\r
  }\r
  //[0, 1] -> [-1, 1]\r
  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r
  // normalData.a store 1.0 if normal was build for frontfaced surface\r
  // and 0.0 in other case\r
  if (normalData.a < EPSILON) {\r
    normal *= -1.0;\r
  }\r
  // get random vector for sampling sphere rotation\r
  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r
  randN = normalize(randN);\r
  // build TBN (randomly rotated around normal)\r
  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r
  vec3 bitangent = cross(tangent, normal);\r
  mat3 TBN = mat3(tangent, bitangent, normal);\r
  // calc AO value\r
  float AO = 0.0;\r
  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r
    // rotate sampling kernel around normal\r
    vec3 reflectedSample = TBN * samplesKernel[i];\r
    // get sample\r
    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r
\r
    // project sample to screen to get sample's screen pos\r
    vec4 SampleScrPos = vec4(samplePos, 1.0);\r
    // eye -> clip\r
    SampleScrPos = projMatrix * SampleScrPos;\r
    // normalize\r
    SampleScrPos.xy /= SampleScrPos.w;\r
    //[-1, 1] -> [0, 1]\r
    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r
\r
    // get view z for sample projected to the objct surface\r
    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r
    // calc occlusion made by object surface at the sample\r
    AO += step(samplePos.z, sampleDepth);\r
  }\r
  // calc result AO-map color\r
  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r
  // write value to AO-map\r
  gl_FragColor = vec4(AO, AO, AO, 1.0);\r
}\r
`,wN=[new x.Vector3(.295184,.077723,.068429),new x.Vector3(-.271976,-.365221,.838363),new x.Vector3(.547713,.467576,.488515),new x.Vector3(.662808,-.031733,.584758),new x.Vector3(-.025717,.218955,.657094),new x.Vector3(-.310153,-.365223,.370701),new x.Vector3(-.101407,-.006313,.747665),new x.Vector3(-.769138,.360399,.086847),new x.Vector3(-.271988,-.27514,.905353),new x.Vector3(.09674,-.566901,.700151),new x.Vector3(.562872,-.735136,.094647),new x.Vector3(.379877,.359278,.190061),new x.Vector3(.519064,-.023055,.405068),new x.Vector3(-.301036,.114696,.088885),new x.Vector3(-.282922,.598305,.487214),new x.Vector3(-.181859,.25167,.679702),new x.Vector3(-.191463,-.635818,.512919),new x.Vector3(-.293655,.427423,.078921),new x.Vector3(-.267983,.680534,.13288),new x.Vector3(.139611,.319637,.477439),new x.Vector3(-.352086,.31104,.653913),new x.Vector3(.321032,.805279,.487345),new x.Vector3(.073516,.820734,.414183),new x.Vector3(-.155324,.589983,.41146),new x.Vector3(.335976,.170782,.527627),new x.Vector3(.46346,-.355658,.167689),new x.Vector3(.222654,.59655,.769406),new x.Vector3(.922138,-.04207,.147555),new x.Vector3(-.72705,-.329192,.369826),new x.Vector3(-.090731,.53382,.463767),new x.Vector3(-.323457,-.876559,.238524),new x.Vector3(-.663277,-.372384,.342856)];class MN extends x.RawShaderMaterial{constructor(){super(),this.setValues.call(this,{uniforms:{noiseTexture:{type:"t",value:to.noiseTexture},noiseTexelSize:{type:"v2",value:new x.Vector2(1/to.noiseWidth,1/to.noiseHeight)},diffuseTexture:{type:"t",value:null},normalTexture:{type:"t",value:null},depthTexture:{type:"t",value:null},srcTexelSize:{type:"v2",value:new x.Vector2(1/512,1/512)},camNearFar:{type:"v2",value:new x.Vector2(1,10)},projMatrix:{type:"mat4",value:new x.Matrix4},aspectRatio:{type:"f",value:0},tanHalfFOV:{type:"f",value:0},samplesKernel:{type:"v3v",value:wN},kernelRadius:{type:"f",value:1},depthThreshold:{type:"f",value:1},factor:{type:"f",value:1}},vertexShader:bs,fragmentShader:bN,transparent:!1,depthTest:!1,depthWrite:!1})}}const AN=MN,EN=`precision highp float;\r
#define EPSILON 0.0000001\r
\r
#define MAX_SAMPLES_COUNT 5\r
uniform float samplesOffsets[MAX_SAMPLES_COUNT];\r
uniform sampler2D aoMap;\r
uniform sampler2D depthTexture;\r
uniform vec2      srcTexelSize;\r
\r
varying vec2 vUv;\r
\r
void main() {\r
  float x = vUv.x;\r
  float y = vUv.y;\r
  vec4 res = vec4(0.0);\r
  res.a = texture2D(aoMap, vec2(x, y )).a;\r
  // return for background fragments (0.0 in alpha component means that it is background fragment)\r
  if (res.a < EPSILON) {\r
    gl_FragColor = res;\r
    return;\r
  }\r
\r
  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r
  float weightSum = 0.0;\r
  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r
    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r
      continue;\r
    }\r
    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r
    float depth = texture2D(depthTexture, samplePos).x;\r
    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r
    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r
    weightSum += weight;\r
  }\r
  res.rgb = res.rgb / weightSum;\r
  gl_FragColor = res;\r
}\r
`,TN=[-2,-1,0,1,2];class CN extends x.RawShaderMaterial{constructor(){super(),this.setValues.call(this,{uniforms:{depthTexture:{type:"t",value:null},srcTexelSize:{type:"v2",value:new x.Vector2(1/512,1/512)},aoMap:{type:"t",value:null},samplesOffsets:{type:"fv1",value:TN}},vertexShader:bs,fragmentShader:EN,transparent:!1,depthTest:!1,depthWrite:!1})}}const RN=CN,PN=`precision highp float;\r
#define EPSILON 0.0000001\r
\r
#define MAX_SAMPLES_COUNT 5\r
uniform float samplesOffsets[MAX_SAMPLES_COUNT];\r
uniform sampler2D diffuseTexture;\r
uniform sampler2D aoMap;\r
uniform sampler2D depthTexture;\r
uniform vec2      srcTexelSize;\r
\r
uniform mat4  projMatrix;\r
uniform float aspectRatio;\r
uniform float tanHalfFOV;\r
\r
#ifdef USE_FOG\r
  uniform vec2 fogNearFar;\r
  uniform vec4 fogColor;\r
#endif\r
varying vec2 vUv;\r
\r
float CalcViewZ(vec2 screenPos)\r
{\r
  float depth = texture2D(depthTexture, screenPos).x;\r
  // [0, 1]->[-1, 1]\r
  float clipedZ = 2.0 * depth - 1.0;\r
  // see THREE.js camera.makeFrustum for projection details\r
  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r
}\r
\r
vec3 ViewPosFromDepth(vec2 screenPos)\r
{\r
  vec3 viewPos;\r
  viewPos.z = CalcViewZ(screenPos);\r
  //[0, 1]->[-1, 1]\r
  vec2 projPos = 2.0 * screenPos - 1.0;\r
  // reconstruct viewposition in right-handed sc with z to viewer\r
  viewPos.xy = vec2(\r
  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r
  projPos.y * tanHalfFOV * abs(viewPos.z)\r
  );\r
  return viewPos;\r
}\r
\r
void main() {\r
  vec3 viewPos = ViewPosFromDepth(vUv);\r
  float x = vUv.x;\r
  float y = vUv.y;\r
  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r
  vec4 res = vec4(0.0);\r
  res.a = texture2D(aoMap, vec2(x, y )).a;\r
  // return for background fragments (0.0 in alpha component means that it is background fragment)\r
  if (res.a < EPSILON) {\r
    gl_FragColor = color;\r
    return;\r
  }\r
\r
  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r
  float weightSum = 0.0;\r
  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r
    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r
      continue;\r
    }\r
    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r
    float depth = texture2D(depthTexture, samplePos).x;\r
    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r
    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r
    weightSum += weight;\r
  }\r
  res.rgb /= weightSum;\r
\r
  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r
    // Add fog to the result value\r
    // Proper way to get an image with fog and ao requires formula:\r
    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r
    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r
    // We have:  AO, fogFactor, fogColor,\r
    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r
    //                                                                where molecule has been already drawn with fog)\r
    // Transform:\r
    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r
    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r
    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r
    //        = color*AO + fogColor*fogFactor*(1 - AO)\r
    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r
    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r
    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r
  #else\r
    gl_FragColor.rgb = color.rgb * res.rgb;\r
  #endif\r
  gl_FragColor.a = color.a;\r
}\r
`,IN=[-2,-1,0,1,2];class mp extends x.RawShaderMaterial{constructor(e){super(e),this.setValues.call(this,{uniforms:{diffuseTexture:{type:"t",value:null},depthTexture:{type:"t",value:null},srcTexelSize:{type:"v2",value:new x.Vector2(1/512,1/512)},aoMap:{type:"t",value:null},samplesOffsets:{type:"fv1",value:IN},projMatrix:{type:"mat4",value:new x.Matrix4},aspectRatio:{type:"f",value:0},tanHalfFOV:{type:"f",value:0},fogNearFar:{type:"v2",value:new x.Vector2(100,100)},fogColor:{type:"v4",value:new x.Vector4(0,.5,0,1)}},vertexShader:bs,fragmentShader:PN,transparent:!1,depthTest:!1,depthWrite:!1}),this.setValues(e)}setValues(e){if(typeof e>"u")return;super.setValues(e);const t={};this.useFog&&(t.USE_FOG=1),this.fogTransparent&&(t.FOG_TRANSPARENT=1),this.defines=t}}mp.prototype.useFog=!0;mp.prototype.fogTransparent=!1;const LN=mp,NN=`precision highp float;\r
\r
uniform sampler2D srcL;\r
uniform sampler2D srcR;\r
varying vec2 vUv;\r
\r
void main() {\r
  vec4 l = texture2D(srcL, vUv);\r
  vec4 r = texture2D(srcR, vUv);\r
  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r
}\r
`;class ON extends x.RawShaderMaterial{constructor(){super();const e={uniforms:{srcL:{type:"t",value:null},srcR:{type:"t",value:null}},vertexShader:bs,fragmentShader:NN,transparent:!1,depthTest:!1,depthWrite:!1};this.setValues(e)}}const DN=ON;class UN{constructor(){this.position=new x.Vector3(0,0,0),this.scale=1,this.orientation=new x.Quaternion(0,0,0,1)}set(e,t,n){this.position=e,this.scale=t,this.orientation=n}}const FN=1.5;class zN{setup(e,t){this._startTime=void 0,this._endTime=void 0,this._isPaused=!1,this._srcView=e,this._dstView=t,this._isMoving=!1}isMoving(){return this._isMoving}wasStarted(){return typeof this._startTime<"u"&&typeof this._endTime<"u"}start(){this._startTime=Date.now();const e=te.now.interpolateViews?FN*1e3:0;this._endTime=this._startTime+e,this._isMoving=!0}getCurrentView(){if(typeof this._srcView>"u"||typeof this._dstView>"u"||!this._isMoving||!this.wasStarted())return{success:!1};let e=this.createView();const t=Date.now();if(t>this._endTime)return e=this._dstView,this.reset(),{success:!0,view:e};const n=(t-this._startTime)/(this._endTime-this._startTime);return e.position.copy(this._srcView.position),e.position.lerp(this._dstView.position,n),e.scale=(1-n)*this._srcView.scale+n*this._dstView.scale,e.orientation.copy(this._srcView.orientation),e.orientation.slerp(this._dstView.orientation,n),{success:!0,view:e}}reset(){this._startTime=this._endTime=0,this._isMoving=!1}pause(){this._isPaused||(this.setup(this.getCurrentView().view,this._dstView),this._isPaused=!0)}resume(){this._isPaused=!1}createView(){return new UN}}const VN=4e3,BN="Cnt";function kN(r,e){const t=r.length,n=[];for(let i=0,s=0;s<t;i++,s+=e)n[i]=r.slice(s,s+e);return n}function oi(r,e){this.context=r,this._opts=de.default.merge({path:"/"},e)}Fa(oi.prototype);oi.prototype.removeCookie=function(r){const e=this._toCount(r);let t=this._getSimpleCookie(e);if(!t){this._removeSimpleCookie(r);return}this._removeSimpleCookie(e),t=parseInt(t,10);for(let n=0;n<t;++n)this._removeSimpleCookie(r+n)};oi.prototype.setCookie=function(r,e){this.removeCookie(r),e=encodeURIComponent(e);const t=kN(e,VN-r.length-1),n=t.length;if(n===1){this._setSimpleCookie(r,e);return}const i=this._toCount(r);this._setSimpleCookie(i,n.toString());for(let s=0;s<n;++s)this._setSimpleCookie(r+s,t[s])};oi.prototype.getCookie=function(r){const e=this._toCount(r);let t=this._getSimpleCookie(e);if(!t)return this._getSimpleCookie(r);t=parseInt(t,10);const n=[];for(let i=0;i<t;++i)n[i]=this._getSimpleCookie(r+i);return n.join("")};oi.prototype._toCount=function(r){return r+BN};oi.prototype._removeSimpleCookie=function(r){document.cookie=`${r}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`};oi.prototype._getExpirationDate=function(){const r=new Date;return r.setFullYear(r.getFullYear()+10),r};oi.prototype._setSimpleCookie=function(r,e){document.cookie=`${r}=${e};expires=${this._getExpirationDate().toUTCString()};path=${this._opts.path}`};oi.prototype._getSimpleCookie=function(r){const e=document.cookie.match(new RegExp(`(?:^|; )${r}=([^;]*)`));return e?decodeURIComponent(e[1]):""};oi.prototype._exists=function(r){return document.cookie.match(new RegExp(`(?:^|; )${r}=([^;]*)`))};const GN=oi;function HN(r){function e(s){s.style.display="",s.style.cursor="pointer",s.style.left="calc(50% - 50px)",s.style.width="100px",s.textContent="ENTER VR";let o=null;function a(){o.removeEventListener("end",a),s.textContent="ENTER VR",o=null}function l(c){c.addEventListener("end",a),r._gfx.renderer.xr.setReferenceSpaceType("local"),r._gfx.renderer.xr.setSession(c),s.textContent="EXIT VR",o=c}s.onmouseenter=function(){s.style.opacity="1.0"},s.onmouseleave=function(){s.style.opacity="0.5"},s.onclick=function(){if(o===null){const c={optionalFeatures:["local-floor","bounded-floor"]};navigator.xr.requestSession("immersive-vr",c).then(l),r.moveSceneBehindHeadset()}else o.end()}}function t(s){s.style.display="",s.style.cursor="auto",s.style.left="calc(50% - 75px)",s.style.width="150px",s.textContent="VR NOT FOUND",s.onmouseenter=null,s.onmouseleave=null,s.onclick=null}function n(s){s.style.position="absolute",s.style.bottom="20px",s.style.padding="12px 6px",s.style.border="1px solid #fff",s.style.borderRadius="4px",s.style.background="transparent",s.style.color="#fff",s.style.font="normal 13px sans-serif",s.style.textAlign="center",s.style.opacity="0.5",s.style.outline="none",s.style.zIndex="999"}if("xr"in navigator){const s=document.createElement("button");return s.style.display="none",n(s),navigator.xr.isSessionSupported("immersive-vr").then(o=>o?e(s):t(s)),s}const i=document.createElement("a");return i.href="https://webvr.info",i.innerHTML="WEBXR NOT SUPPORTED",i.style.left="calc(50% - 90px)",i.style.width="180px",i.style.textDecoration="none",n(i),i}class WN{constructor(e){this._mainCamera=new x.PerspectiveCamera,this._button=null,this._onToggle=e,this._molContainer=new Je.RCGroup,this._user=new Je.RCGroup,this._scalingPivot=new x.Object3D,this._user.add(this._scalingPivot),this._controller1=null,this._controller2=null,this._pressedGripsCounter=0,this._distance=0,this._gfx=null}startScalingByControllers(){this._distance=this._controller1.position.distanceTo(this._controller2.position),Je.getMiddlePoint(this._controller1.position,this._controller2.position,this._scalingPivot.position),this._scalingPivot.scale.set(1,1,1),this._scalingPivot.updateMatrix(),this._scalingPivot.updateMatrixWorld(),this._scalingPivot.addSavingWorldTransform(this._molContainer)}stopScalingByControllers(){this._gfx.scene.addSavingWorldTransform(this._molContainer)}handleGripsDown(e){this._pressedGripsCounter++,this._pressedGripsCounter===2?this.startScalingByControllers():this._pressedGripsCounter===1&&e.target.addSavingWorldTransform(this._molContainer)}handleGripsUp(e){this._pressedGripsCounter--,this._pressedGripsCounter===1?(this.stopScalingByControllers(),(e.target===this._controller1?this._controller2:this._controller1).addSavingWorldTransform(this._molContainer)):this._pressedGripsCounter===0&&this._gfx.scene.addSavingWorldTransform(this._molContainer)}enable(e){if(!e){Ut.warn("WebVR couldn't be enabled, because gfx is not defined");return}this._gfx=e;const{renderer:t,camera:n}=e;if(!t)throw new Error("No renderer is available to toggle WebVR");if(!n)throw new Error("No camera is available to toggle WebVR");t.xr.enabled=!0,this._button?this._button.style.display="block":(this._button=HN(this),document.body.appendChild(this._button)),this._mainFog=te.now.fog,te.set("fog",!1),this._plugVRNodesIntoScene(e,t),this._setControllersListeners(),this._onToggle&&this._onToggle(!0)}_plugVRNodesIntoScene(e,t){this._mainCamera.copy(e.camera),e.scene.add(this._user),e.scene.add(this._molContainer),this._molContainer.add(e.root),this._controller1=t.xr.getController(0),this._controller2=t.xr.getController(1);const n=this._createControllerMesh();this._controller1.add(n),this._controller2.add(n.clone()),this._user.add(this._controller1),this._user.add(this._controller2)}_setControllersListeners(){this._controller1.addEventListener("selectstart",e=>{this.handleGripsDown(e)}),this._controller1.addEventListener("selectend",e=>{this.handleGripsUp(e)}),this._controller2.addEventListener("selectstart",e=>{this.handleGripsDown(e)}),this._controller2.addEventListener("selectend",e=>{this.handleGripsUp(e)}),this._controller1.addEventListener("squeezestart",e=>{this.handleGripsDown(e)}),this._controller1.addEventListener("squeezeend",e=>{this.handleGripsUp(e)}),this._controller2.addEventListener("squeezestart",e=>{this.handleGripsDown(e)}),this._controller2.addEventListener("squeezeend",e=>{this.handleGripsUp(e)})}disable(){if(!this._gfx)return;const{renderer:e,camera:t}=this._gfx;if(!e)throw new Error("No renderer is available to toggle WebVR");e.setAnimationLoop(null);const n=e.xr.getSession();n&&n.end(),e.xr.enabled=!1,this._button&&(this._button.style.display="none"),te.set("fog",this._mainFog),this._unplugVRNodesFromScene(t),this._onToggle&&this._onToggle(!1)}_unplugVRNodesFromScene(e){this._mainCamera&&e&&e.copy(this._mainCamera);const t=this._molContainer.children[0];t&&this._gfx.scene.add(t),this._molContainer.parent.remove(this._molContainer),this._user&&this._gfx.scene.remove(this._user),this._molContainer=null,this._user=null,this._scalingPivot=null,this._user=null,this._controller1=null,this._controller2=null}_createControllerMesh(){const e=new x.CylinderGeometry(.04,.04,.3),t=new xi({lights:!1,overrideColor:!0});t.setUberOptions({fixedColor:new x.Color(4474111)}),t.updateUniforms();const n=new x.Mesh(e,t);return n.rotateX(-Math.PI/2),n}updateMoleculeScale(){if(!this._controller1||!this._controller2)return;const e=this;if(e._pressedGripsCounter===2){Je.getMiddlePoint(e._controller1.position,e._controller2.position,e._scalingPivot.position);const t=e._controller1.position.distanceTo(e._controller2.position),n=t/e._distance;e._scalingPivot.scale.multiplyScalar(n),e._distance=t}}moveSceneBehindHeadset(){const e=this._gfx,{camera:t}=e,n=this._molContainer;n.matrix.identity(),n.position.set(0,0,-4),n.updateMatrix(),n.matrixWorld.multiplyMatrices(t.matrixWorld,n.matrix),e.scene.addSavingWorldTransform(n),this._onToggle&&this._onToggle(!0)}getCanvas(){const e=this._gfx;return e&&e.renderer?e.renderer.domElement:null}}const XN=`precision highp float;\r
\r
varying vec2 vUv;\r
uniform sampler2D srcTex;\r
uniform vec3 aberration;\r
\r
void main() {\r
  vec2 uv = vUv * 2.0 - 1.0;\r
  \r
  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r
  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r
  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r
  gl_FragColor.a = 1.0;\r
}`,{selectors:Tc,Atom:jN,Residue:YN,Chain:qN,Molecule:$N}=Bt,Et={COMPLEX:0,COMPONENT:1,FRAGMENT:2},Ld="Could not find suitable loader for this source",ZN="Could not find suitable parser for this source";x.ColorManagement.enabled=!1;const{createElement:tc}=be;function KN(r,e,t){r.near=e-t*te.now.fogNearFactor,r.far=e+t*te.now.fogFarFactor}function r_(r){const e=r.lastIndexOf(".");return e>=0&&(r=r.substr(0,e)),r}function JN(r){let e=!1;return r.forEachComponent(t=>{t.forEachResidue(n=>{n._isValid&&(e=!0)})}),e}function o_(r,e,t){t!==void 0?r.debug(`${e}... ${Math.floor(t*100)}%`):r.debug(`${e}...`)}function Sh(){return te.now.fogColorEnable?te.now.fogColor:te.now.bg.color}function le(r){Dn.call(this),this._opts=de.default.merge({settingsCookie:"settings",cookiePath:"/"},r),this._gfx=null,this._interpolator=new zN,this._container=r&&r.container||document.getElementById("miew-container")||de.default.head(document.getElementsByClassName("miew-container"))||document.body,this._containerRoot=this._container,this._running=!1,this._halting=!1,this._building=!1,this._needRender=!0,this._hotKeysEnabled=!0,this.settings=te;const e=Ut;e.console=!1,e.level="info",this.logger=e,this._cookies=new GN(this),this.restoreSettings(),r&&r.settings&&this.settings.set(r.settings),this._spinner=null,this._loading=[],this._animInterval=null,this._visuals={},this._curVisualName=null,this._objects=[],this._sourceWindow=null,this.reset(),this._repr&&e.debug(`Selected ${this._repr.mode.name} mode with ${this._repr.colorer.name} colorer.`);const t=this;le.registeredPlugins.forEach(n=>{n.call(t)}),this._initOnSettingsChanged()}le.prototype=Object.create(Dn.prototype);le.prototype.constructor=le;le.prototype.getMaxRepresentationCount=function(){return Bi.NUM_REPRESENTATION_BITS};function gp(r,e){const t=r;for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(e)}le.prototype._updateShadowCamera=(function(){const r=new x.Matrix4,e=new x.Vector3,t={center:new x.Vector3,halfSize:new x.Vector3};return function(){this._gfx.scene.updateMatrixWorld();for(let n=0;n<this._gfx.scene.children.length;n++)if(this._gfx.scene.children[n].type==="DirectionalLight"){const i=this._gfx.scene.children[n];r.copy(i.shadow.camera.matrixWorldInverse),this.getOBB(r,t),e.subVectors(i.target.position,i.position),i.position.subVectors(t.center,e),i.target.position.copy(t.center),i.shadow.bias=.09,i.shadow.camera.bottom=-t.halfSize.y,i.shadow.camera.top=t.halfSize.y,i.shadow.camera.right=t.halfSize.x,i.shadow.camera.left=-t.halfSize.x,i.shadow.camera.near=e.length()-t.halfSize.z,i.shadow.camera.far=e.length()+t.halfSize.z,i.shadow.camera.updateProjectionMatrix()}}})();le.prototype.init=function(){const r=this._container,e=be.createElement("div",{class:"miew-canvas"});gp(r,e),this._container=e;const t=document.createDocumentFragment();if(t.appendChild(this._msgMode=tc("div",{class:"mode-message overlay"},tc("p",{},"COMPONENT EDIT MODE"))),t.appendChild(this._msgAtomInfo=tc("div",{class:"atom-info overlay"},tc("p",{},""))),r.appendChild(t),this._gfx!==null)return!0;const n=this;this._showMessage("Viewer is being initialized...");try{this._initGfx(),this._initListeners(),this._spinner=new fT({lines:13,length:28,width:14,radius:42,color:"#fff",zIndex:700});const s=Fy();s.addEventListener("keydown",a=>{n._onKeyDown(a)}),s.addEventListener("keyup",a=>{n._onKeyUp(a)}),this._objectControls=new KL(this._gfx.root,this._gfx.pivot,this._gfx.camera,this._gfx.renderer.domElement,()=>n._getAltObj()),this._objectControls.addEventListener("change",a=>{switch(te.now.shadow.on&&n._updateShadowCamera(),a.action){case"rotate":n.dispatchEvent({type:"rotate",quaternion:a.quaternion});break;case"zoom":n.dispatchEvent({type:"zoom",factor:a.factor});break;default:n.dispatchEvent({type:a.action})}n.dispatchEvent({type:"transform"}),n._needRender=!0});const o=this._gfx;this._picker=new JL(o.root,o.camera,o.renderer.domElement),this._picker.addEventListener("newpick",a=>{n._onPick(a)}),this._picker.addEventListener("dblclick",a=>{n.center(a)})}catch(s){if(s.name==="TypeError"&&s.message==="Cannot read property 'getExtension' of null")this._showMessage("Could not create WebGL context.");else if(s.message.search(/webgl/i)>1)this._showMessage(s.message);else throw this._showMessage("Viewer initialization failed."),s;return!1}const i=this._opts&&this._opts.load;if(i){const s=this._opts&&this._opts.type;this.load(i,{fileType:s,keepRepsInfo:!0})}return!0};le.prototype.term=function(){this._showMessage("Viewer has been terminated."),this._loading.forEach(r=>{r.cancel()}),this._loading.length=0,this.halt(),this._gfx=null};le.prototype._showMessage=function(r){const e=document.createElement("div");e.setAttribute("class","miew-message"),e.appendChild(document.createElement("p")).appendChild(document.createTextNode(r)),gp(this._container,e)};le.prototype._showCanvas=function(){gp(this._container,this._gfx.renderer.domElement)};le.prototype._requestAnimationFrame=function(r){const{xr:e}=this._gfx.renderer;if(e&&e.enabled){this._gfx.renderer.setAnimationLoop(r);return}requestAnimationFrame(r)};function ky(r){return r.getExtension("EXT_frag_depth")}function Gy(r){return r.getExtension("WEBGL_depth_texture")&&r.getExtension("WEBGL_draw_buffers")}le.prototype._initGfx=function(){const r={width:this._container.clientWidth,height:this._container.clientHeight},e={preserveDrawingBuffer:!0,alpha:!0,premultipliedAlpha:!1};te.now.antialias&&(e.antialias=!0),r.renderer2d=new $L,r.renderer=new x.WebGL1Renderer(e),r.renderer.shadowMap.enabled=te.now.shadow.on,r.renderer.shadowMap.autoUpdate=!1,r.renderer.shadowMap.type=x.PCFShadowMap,ly.init(r.renderer),ky(r.renderer.getContext())||te.set("zSprites",!1),Gy(r.renderer.getContext())||te.set("ao",!1),r.renderer.autoClear=!1,r.renderer.setPixelRatio(window.devicePixelRatio),r.renderer.setSize(r.width,r.height),r.renderer.setClearColor(te.now.bg.color,+!te.now.bg.transparent),r.renderer.clearColor(),r.renderer2d.setSize(r.width,r.height),r.camera=new x.PerspectiveCamera(te.now.camFov,r.width/r.height,te.now.camNear,te.now.camFar),r.camera.setMinimalFov(te.now.camFov),r.camera.position.z=te.now.camDistance,r.camera.updateProjectionMatrix(),r.camera.layers.set(Je.LAYERS.DEFAULT),r.camera.layers.enable(Je.LAYERS.VOLUME),r.camera.layers.enable(Je.LAYERS.VOLUME_BFPLANE),r.stereoCam=new x.StereoCamera,r.scene=new x.Scene;const t=Sh();r.scene.fog=new x.Fog(t,te.now.camNear,te.now.camFar),r.root=new Je.RCGroup,r.scene.add(r.root),r.pivot=new Je.RCGroup,r.root.add(r.pivot),r.selectionScene=new x.Scene,r.selectionRoot=new x.Group,r.selectionRoot.matrixAutoUpdate=!1,r.selectionScene.add(r.selectionRoot),r.selectionPivot=new x.Group,r.selectionPivot.matrixAutoUpdate=!1,r.selectionRoot.add(r.selectionPivot);const n=new x.DirectionalLight(16777215,.45);n.position.set(0,.414,1),n.layers.enable(Je.LAYERS.TRANSPARENT),n.castShadow=!0,n.shadow.bias=.09,n.shadow.radius=te.now.shadow.radius,n.shadow.camera.layers.set(Je.LAYERS.SHADOWMAP);const i=r.renderer.getPixelRatio(),s=Math.max(r.width,r.height)*i;n.shadow.mapSize.width=s,n.shadow.mapSize.height=s,n.target.position.set(0,0,0),r.scene.add(n),r.scene.add(n.target);const o=new x.AmbientLight(6710886);o.layers.enable(Je.LAYERS.TRANSPARENT),r.scene.add(o),r.axes=new eN(r.root,r.camera);const a=r.width*i,l=r.height*i;r.offscreenBuf=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.NearestFilter,format:x.RGBAFormat,depthBuffer:!0}),r.renderer.getContext().getExtension("WEBGL_depth_texture")&&(r.offscreenBuf.depthTexture=new x.DepthTexture,r.offscreenBuf.depthTexture.type=x.UnsignedShortType),r.offscreenBuf2=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,depthBuffer:!1}),r.offscreenBuf3=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,depthBuffer:!1}),r.offscreenBuf4=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,depthBuffer:!1}),r.volBFTex=r.offscreenBuf3,r.volFFTex=r.offscreenBuf4,r.volWFFTex=r.offscreenBuf,r.renderer.getContext().getExtension("OES_texture_float")?(r.offscreenBuf5=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,type:x.FloatType,depthBuffer:!1}),r.offscreenBuf6=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,type:x.FloatType,depthBuffer:!1}),r.offscreenBuf7=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,type:x.FloatType,depthBuffer:!0}),r.volBFTex=r.offscreenBuf5,r.volFFTex=r.offscreenBuf6,r.volWFFTex=r.offscreenBuf7):this.logger.warn("Device doesn't support OES_texture_float extension"),r.stereoBufL=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,depthBuffer:!1}),r.stereoBufR=new x.WebGLRenderTarget(a,l,{minFilter:x.LinearFilter,magFilter:x.LinearFilter,format:x.RGBAFormat,depthBuffer:!1}),this._gfx=r,this._showCanvas(),this._embedWebXR(te.now.stereo==="WEBVR"),this._container.appendChild(r.renderer2d.getElement());const c=new xT;c.domElement.style.position="absolute",c.domElement.style.right="0",c.domElement.style.bottom="0",this._container.appendChild(c.domElement),this._fps=c,this._fps.show(te.now.fps)};le.prototype._initListeners=function(){const r=this;window.addEventListener("resize",()=>{r._onResize()})};le.prototype._makeUniqueVisualName=function(r){if(!r)return Math.random().toString();let e=r,t=1;for(;this._visuals.hasOwnProperty(e);)e=`${r} (${t.toString()})`,t++;return e};le.prototype._addVisual=function(r){if(!r)return null;const e=this._makeUniqueVisualName(r.name);return r.name=e,this._visuals[e]=r,this._gfx.pivot.add(r),r.getSelectionGeo&&this._gfx.selectionPivot.add(r.getSelectionGeo()),e};le.prototype._removeVisual=function(r){let e="",t=null;r instanceof _a?({name:e}=r,t=r):typeof r=="string"&&(e=r,t=this._visuals[e]),!(!t||!this._visuals.hasOwnProperty(e)||this._visuals[e]!==t)&&(e===this._curVisualName&&(this._curVisualName=void 0),delete this._visuals[e],t.release(),this._needRender=!0)};le.prototype._forEachVisual=function(r){for(const e in this._visuals)this._visuals.hasOwnProperty(e)&&r(this._visuals[e])};le.prototype._releaseAllVisuals=function(){if(!(!this._gfx||!this._gfx.pivot)){for(const r in this._visuals)this._visuals.hasOwnProperty(r)&&this._visuals[r].release();this._visuals={}}};le.prototype._forEachComplexVisual=function(r){if(!(!this._gfx||!this._gfx.pivot))for(const e in this._visuals)this._visuals.hasOwnProperty(e)&&this._visuals[e]instanceof Bi&&r(this._visuals[e])};le.prototype._getComplexVisual=function(r){r=r||this._curVisualName;let e=null,t=null;return this._forEachComplexVisual(n=>{e=n,n.name===r&&(t=n)}),t||e};le.prototype._getVolumeVisual=function(){let r=null;return this._forEachVisual(e=>{e instanceof Qf&&(r=e)}),r};le.prototype._getVisualForComplex=function(r){if(!r)return null;let e=null;return this._forEachComplexVisual(t=>{t.getComplex()===r&&(e=t)}),e};le.prototype.getVisuals=function(){return Object.keys(this._visuals)};le.prototype.getComplexVisualsCount=function(){let r=0;return this._forEachComplexVisual(()=>r++),r};le.prototype.getCurrentVisual=function(){return this._curVisualName};le.prototype.setCurrentVisual=function(r){this._visuals[r]&&(this._curVisualName=r)};le.prototype.run=function(){if(!this._running){if(this._running=!0,this._halting){this._halting=!1;return}this._objectControls.enable(!0),this._interpolator.resume(),this._requestAnimationFrame(()=>this._onTick())}};le.prototype.halt=function(){this._running&&(this._discardComponentEdit(),this._discardFragmentEdit(),this._objectControls.enable(!1),this._interpolator.pause(),this._halting=!0)};le.prototype.enableHotKeys=function(r){this._hotKeysEnabled=r,this._objectControls.enableHotkeys(r)};le.prototype._onResize=function(){const r=this._gfx;r&&(this._needRender=!0,r.width=this._container.clientWidth,r.height=this._container.clientHeight,r.camera.aspect=r.width/r.height,r.camera.setMinimalFov(te.now.camFov),r.camera.updateProjectionMatrix(),r.renderer.setSize(r.width,r.height),r.renderer2d.setSize(r.width,r.height),this.dispatchEvent({type:"resize"}))};le.prototype._resizeOffscreenBuffers=function(r,e,t){const n=this._gfx;t=t||"NONE";const i=t==="NONE"||t==="ANAGLYPH",s=i?1:.5;n.offscreenBuf.setSize(s*r,e),n.offscreenBuf2.setSize(s*r,e),n.offscreenBuf3.setSize(s*r,e),n.offscreenBuf4.setSize(s*r,e),n.offscreenBuf5&&n.offscreenBuf5.setSize(s*r,e),n.offscreenBuf6&&n.offscreenBuf6.setSize(s*r,e),n.offscreenBuf7&&n.offscreenBuf7.setSize(s*r,e),i&&(n.stereoBufL.setSize(r,e),n.stereoBufR.setSize(r,e))};le.prototype._onTick=function(){if(this._halting){this._running=!1,this._halting=!1;return}this._fps.update(),this._requestAnimationFrame(()=>this._onTick()),this._onUpdate(),this._needRender&&(this._onRender(),this._needRender=!te.now.suspendRender||te.now.stereo==="WEBVR")};le.prototype._getBSphereRadius=function(){let r=0;return this._forEachVisual(e=>{r=Math.max(r,e.getBoundaries().boundingSphere.radius)}),r*this._objectControls.getScale()};le.prototype.getOBB=(function(){const r=new x.Sphere,e=new x.Box3,t=new x.Box3,n=new x.Matrix4,i=[new x.Vector3,new x.Vector3,new x.Vector3,new x.Vector3];return function(s,o){t.makeEmpty(),this._forEachVisual(c=>{r.copy(c.getBoundaries().boundingSphere),r.applyMatrix4(c.matrixWorld).applyMatrix4(s),r.getBoundingBox(e),t.union(e)}),t.getCenter(o.center),n.copy(s).invert(),o.center.applyMatrix4(n);const{min:a}=t,{max:l}=t;i[0].set(a.x,a.y,a.z),i[1].set(l.x,a.y,a.z),i[2].set(a.x,l.y,a.z),i[3].set(a.x,a.y,l.z);for(let c=0,h=i.length;c<h;c++)i[c].applyMatrix4(n);o.halfSize.set(Math.abs(i[0].x-i[1].x),Math.abs(i[0].y-i[2].y),Math.abs(i[0].z-i[3].z)).multiplyScalar(.5)}})();le.prototype._updateFog=function(){const r=this._gfx;if(te.now.fog){if(typeof r.scene.fog>"u"||r.scene.fog===null){const e=Sh();r.scene.fog=new x.Fog(e),this._setUberMaterialValues({fog:te.now.fog})}KN(r.scene.fog,r.camera.position.z,this._getBSphereRadius())}else r.scene.fog&&(r.scene.fog=void 0,this._setUberMaterialValues({fog:te.now.fog}))};le.prototype._onUpdate=function(){this.isScriptingCommandAvailable!==void 0&&this.isScriptingCommandAvailable()&&!this._building&&this.callNextCmd(),this._objectControls.update(),this._forEachComplexVisual(r=>{r.getComplex().update()}),te.now.autobuild&&!this._loading.length&&!this._building&&this._needRebuild()&&this.rebuild(),!this._loading.length&&!this._building&&!this._needRebuild()&&this._updateView(),this._updateFog(),this._gfx.renderer.xr.enabled&&this.webVR.updateMoleculeScale()};le.prototype._onRender=function(){const r=this._gfx;r.scene.updateMatrixWorld(),r.camera.updateMatrixWorld(),this._clipPlaneUpdateValue(this._getBSphereRadius()),this._fogFarUpdateValue(),r.renderer.setRenderTarget(null),r.renderer.clear(),this._renderFrame(te.now.stereo)};le.prototype._renderFrame=(function(){const r=new DN,e=new x.Vector2;return function(t){const n=this._gfx,{renderer:i}=n;i.getSize(e),t!=="NONE"&&(n.camera.focus=n.camera.position.z,n.stereoCam.aspect=1,t==="ANAGLYPH"?n.stereoCam.update(n.camera):n.stereoCam.updateHalfSized(n.camera,te.now.camFov));const s=n.renderer.getPixelRatio();switch(this._resizeOffscreenBuffers(e.width*s,e.height*s,t),this._renderShadowMap(),t){case"WEBVR":case"NONE":this._renderScene(n.camera,!1);break;case"SIMPLE":case"DISTORTED":i.setScissorTest(!0),i.setScissor(0,0,e.width/2,e.height),i.setViewport(0,0,e.width/2,e.height),this._renderScene(this._gfx.stereoCam.cameraL,t==="DISTORTED"),i.setScissor(e.width/2,0,e.width/2,e.height),i.setViewport(e.width/2,0,e.width/2,e.height),this._renderScene(this._gfx.stereoCam.cameraR,t==="DISTORTED"),i.setScissorTest(!1);break;case"ANAGLYPH":this._renderScene(this._gfx.stereoCam.cameraL,!1,n.stereoBufL),this._renderScene(this._gfx.stereoCam.cameraR,!1,n.stereoBufR),i.setRenderTarget(null),r.uniforms.srcL.value=n.stereoBufL.texture,r.uniforms.srcR.value=n.stereoBufR.texture,n.renderer.renderScreenQuad(r);break}n.renderer2d.render(n.scene,n.camera),te.now.axes&&n.axes&&!n.renderer.xr.enabled&&n.axes.render(i)}})();le.prototype._onBgColorChanged=function(){const r=this._gfx,e=Sh();r&&(r.scene.fog&&r.scene.fog.color.set(e),r.renderer.setClearColor(te.now.bg.color,+!te.now.bg.transparent)),this._needRender=!0};le.prototype._onFogColorChanged=function(){const r=this._gfx,e=Sh();r&&r.scene.fog&&r.scene.fog.color.set(e),this._needRender=!0};le.prototype._setUberMaterialValues=function(r){this._gfx.root.traverse(e=>{(e instanceof x.Mesh||e instanceof x.LineSegments||e instanceof x.Line)&&e.material instanceof xi&&(e.material.setValues(r),e.material.needsUpdate=!0)})};le.prototype._enableMRT=function(r,e,t){const n=this._gfx,i=n.renderer.getContext(),s=i.getExtension("WEBGL_draw_buffers"),{properties:o}=n.renderer;if(!r){s.drawBuffersWEBGL([i.COLOR_ATTACHMENT0,null]);return}n.renderer.setRenderTarget(t);const a=o.get(t.texture).__webglTexture;i.bindTexture(i.TEXTURE_2D,a),n.renderer.setRenderTarget(e);const l=o.get(e).__webglFramebuffer,c=o.get(e.texture).__webglTexture;i.bindFramebuffer(i.FRAMEBUFFER,l),l.width=e.width,l.height=e.height,i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,c,0),i.framebufferTexture2D(i.FRAMEBUFFER,s.COLOR_ATTACHMENT1_WEBGL,i.TEXTURE_2D,a,0),s.drawBuffersWEBGL([i.COLOR_ATTACHMENT0,s.COLOR_ATTACHMENT1_WEBGL])};le.prototype._renderScene=(function(){return function(r,e,t){e=e||!1,t=t||null;const n=this._gfx;if(n.renderer.setClearColor(te.now.bg.color,+!te.now.bg.transparent),n.renderer.setRenderTarget(t),n.renderer.clear(),n.renderer.xr.enabled){n.renderer.render(n.scene,r);return}n.renderer.setClearColor(0,0),n.renderer.setRenderTarget(n.offscreenBuf4),n.renderer.clearColor(),n.renderer.setClearColor(te.now.bg.color,+!te.now.bg.transparent),n.renderer.setRenderTarget(n.offscreenBuf),n.renderer.clear();const i=this._getComplexVisual()!==null,s=this._getVolumeVisual(),o=i&&te.now.ao;o&&this._enableMRT(!0,n.offscreenBuf,n.offscreenBuf4),te.now.transparency==="prepass"?this._renderWithPrepassTransparency(r,n.offscreenBuf):te.now.transparency==="standard"&&(n.renderer.setRenderTarget(n.offscreenBuf),n.renderer.render(n.scene,r)),o&&this._enableMRT(!1,null,null);const a=i&&te.now.outline.on,l=i&&te.now.fxaa,c=s!==null&&s.getMesh().material!=null;let h=o||a||c||l||e?n.offscreenBuf2:t,u=n.offscreenBuf;o?(this._performAO(u,n.offscreenBuf4,n.offscreenBuf.depthTexture,h,n.offscreenBuf3,n.offscreenBuf2),!l&&!e&&!c&&!a&&(u=h,h=t,n.renderer.setRenderTarget(h),n.renderer.renderScreenQuadFromTex(u.texture,1))):(n.renderer.setRenderTarget(h),n.renderer.renderScreenQuadFromTex(u.texture,1)),a&&(u=h,h=c||l||e?n.offscreenBuf3:t,u!=null&&this._renderOutline(r,n.offscreenBuf,u,h)),this._renderSelection(r,n.offscreenBuf,h),c&&(n.renderer.setRenderTarget(n.offscreenBuf),n.renderer.renderScreenQuadFromTex(h.texture,1),h=n.offscreenBuf,this._renderVolume(s,r,h,n.volBFTex,n.volFFTex,n.volWFFTex),!l&&!e&&(n.renderer.setRenderTarget(t),n.renderer.renderScreenQuadFromTex(h.texture,1))),u=h,l&&(h=e?n.offscreenBuf4:t,this._performFXAA(u,h),u=h),e&&(h=t,this._performDistortion(u,h,!0))}})();le.prototype._performDistortion=(function(){const r=new x.Scene,e=new x.OrthographicCamera(-1,1,1,-1,-500,1e3),t=new x.RawShaderMaterial({uniforms:{srcTex:{type:"t",value:null},aberration:{type:"fv3",value:new x.Vector3(1)}},vertexShader:bs,fragmentShader:XN,transparent:!1,depthTest:!1,depthWrite:!1}),n=Je.buildDistorionMesh(10,10,te.now.debug.stereoBarrel);return r.add(new kn.Mesh(n,t)),function(i,s,o){this._gfx.renderer.setRenderTarget(s),this._gfx.renderer.clear(),o?(t.uniforms.srcTex.value=i.texture,t.uniforms.aberration.value.set(.995,1,1.01),this._gfx.renderer.render(r,e)):this._gfx.renderer.renderScreenQuadFromTexWithDistortion(i,te.now.debug.stereoBarrel)}})();le.prototype._renderOutline=(function(){const r=new Vy({depth:!0});return function(e,t,n,i){const o=this._gfx;r.uniforms.srcTex.value=n.texture,r.uniforms.srcDepthTex.value=t.depthTexture,r.uniforms.srcTexSize.value.set(t.width,t.height),r.uniforms.color.value=new x.Color(te.now.outline.color),r.uniforms.threshold.value=te.now.outline.threshold,r.uniforms.thickness.value=new x.Vector2(te.now.outline.thickness,te.now.outline.thickness),o.renderer.setRenderTarget(i),o.renderer.renderScreenQuad(r)}})();le.prototype._renderShadowMap=(function(){const r={minFilter:x.NearestFilter,magFilter:x.NearestFilter,format:x.RGBAFormat};return function(){if(!te.now.shadow.on)return;const e=this._gfx,t=e.renderer.getRenderTarget(),n=e.renderer.getActiveCubeFace(),i=e.renderer.getActiveMipmapLevel(),s=e.renderer.state;s.setBlending(x.NoBlending),s.buffers.color.setClear(1,1,1,1),s.buffers.depth.setTest(!0),s.setScissorTest(!1);for(let o=0;o<e.scene.children.length;o++)if(e.scene.children[o].type==="DirectionalLight"){const a=e.scene.children[o];a.shadow.map==null&&(a.shadow.map=new x.WebGLRenderTarget(a.shadow.mapSize.width,a.shadow.mapSize.height,r),a.shadow.camera.updateProjectionMatrix()),a.shadow.updateMatrices(a),e.renderer.setRenderTarget(a.shadow.map),e.renderer.clear(),e.renderer.render(e.scene,a.shadow.camera)}e.renderer.setRenderTarget(t,n,i)}})();le.prototype._hasSelectionToRender=function(){const r=this._gfx.selectionPivot;for(let e=0;e<r.children.length;e++)if(r.children[e].children.length>0)return!0;return!1};le.prototype._renderSelection=(function(){const r=new Vy;return function(e,t,n){const i=this,s=i._gfx;s.renderer.setClearColor("black",0),s.renderer.setRenderTarget(t),s.renderer.clear(!0,!1,!1),i._hasSelectionToRender()?(s.selectionRoot.matrix=s.root.matrix,s.selectionPivot.matrix=s.pivot.matrix,s.renderer.render(s.selectionScene,e)):s.renderer.renderDummyQuad(),s.renderer.setRenderTarget(n),s.renderer.renderScreenQuadFromTex(t.texture,.6),r.uniforms.srcTex.value=t.texture,r.uniforms.srcTexSize.value.set(t.width,t.height),s.renderer.renderScreenQuad(r)}})();le.prototype._checkVolumeRenderingSupport=function(r){if(!r)return!1;const e=this._gfx,t=e.renderer.getRenderTarget();e.renderer.setRenderTarget(r);const n=e.renderer.getContext(),i=n.checkFramebufferStatus(n.FRAMEBUFFER);return e.renderer.setRenderTarget(t),i!==n.FRAMEBUFFER_COMPLETE?(this.logger.warn("Device doesn't support electron density rendering"),!1):!0};le.prototype._renderVolume=(function(){const r=new Ac.BackFacePosMaterial,e=new Ac.FrontFacePosMaterial,t=new x.Matrix4().makeTranslation(.5,.5,.5),n=new x.Matrix4;let i;return function(s,o,a,l,c,h){const u=this._gfx;if(typeof i>"u"&&(i=this._checkVolumeRenderingSupport(l)),!i)return;const d=s.getMesh();d.rebuild(u.camera),u.renderer.setClearColor("black",0),u.renderer.setRenderTarget(l),u.renderer.clear(),u.renderer.setRenderTarget(c),u.renderer.clear(),u.renderer.setRenderTarget(h),u.renderer.clear(),u.renderer.setRenderTarget(l),o.layers.set(Je.LAYERS.VOLUME_BFPLANE),u.renderer.render(u.scene,o),o.layers.set(Je.LAYERS.VOLUME),u.scene.overrideMaterial=r,u.renderer.render(u.scene,o),u.renderer.setRenderTarget(c),o.layers.set(Je.LAYERS.VOLUME),u.scene.overrideMaterial=e,u.renderer.render(u.scene,o),u.scene.overrideMaterial=null,o.layers.set(Je.LAYERS.DEFAULT),n.copy(d.matrixWorld).invert(),xi.prototype.uberOptions.world2colorMatrix.multiplyMatrices(t,n),o.layers.set(Je.LAYERS.COLOR_FROM_POSITION),u.renderer.setRenderTarget(h),u.renderer.render(u.scene,o);const f=d.material;f.uniforms._BFRight.value=l.texture,f.uniforms._FFRight.value=c.texture,f.uniforms._WFFRight.value=h.texture,o.layers.set(Je.LAYERS.VOLUME),u.renderer.setRenderTarget(a),u.renderer.render(u.scene,o),o.layers.set(Je.LAYERS.DEFAULT)}})();le.prototype._renderWithPrepassTransparency=(function(){return function(r,e){const t=this._gfx;t.renderer.setRenderTarget(e),r.layers.set(Je.LAYERS.DEFAULT),t.renderer.render(t.scene,r),r.layers.set(Je.LAYERS.PREPASS_TRANSPARENT),t.renderer.getContext().colorMask(!1,!1,!1,!1),t.renderer.render(t.scene,r),t.renderer.getContext().colorMask(!0,!0,!0,!0),r.layers.set(Je.LAYERS.TRANSPARENT),t.renderer.render(t.scene,r),r.layers.set(Je.LAYERS.DEFAULT)}})();le.prototype._performFXAA=(function(){const r=new SN;return function(e,t){if(typeof e>"u"||typeof t>"u")return;const n=this._gfx;n.renderer.setClearColor(te.now.bg.color,+!te.now.bg.transparent),n.renderer.setRenderTarget(t),n.renderer.clear(),r.uniforms.srcTex.value=e.texture,r.uniforms.srcTexelSize.value.set(1/e.width,1/e.height),r.uniforms.bgColor.value.set(te.now.bg.color),r.bgTransparent!==te.now.bg.transparent&&(r.setValues({bgTransparent:te.now.bg.transparent}),r.needsUpdate=!0),n.renderer.renderScreenQuad(r)}})();le.prototype._performAO=(function(){const r=new AN,e=new RN,t=new LN,n=new x.Vector3;return function(i,s,o,a,l,c){if(!i||!s||!o||!a||!l||!c)return;const h=this._gfx,u=Math.tan(x.MathUtils.DEG2RAD*.5*h.camera.fov);r.uniforms.diffuseTexture.value=i.texture,r.uniforms.depthTexture.value=o,r.uniforms.normalTexture.value=s.texture,r.uniforms.srcTexelSize.value.set(1/i.width,1/i.height),r.uniforms.camNearFar.value.set(h.camera.near,h.camera.far),r.uniforms.projMatrix.value=h.camera.projectionMatrix,r.uniforms.aspectRatio.value=h.camera.aspect,r.uniforms.tanHalfFOV.value=u,h.root.matrix.extractScale(n),r.uniforms.kernelRadius.value=te.now.debug.ssaoKernelRadius*n.x,r.uniforms.depthThreshold.value=2*this._getBSphereRadius(),r.uniforms.factor.value=te.now.debug.ssaoFactor,h.renderer.setRenderTarget(c),h.renderer.renderScreenQuad(r),e.uniforms.aoMap.value=c.texture,e.uniforms.srcTexelSize.value.set(1/c.width,1/c.height),e.uniforms.depthTexture.value=o,h.renderer.setRenderTarget(l),h.renderer.renderScreenQuad(e),t.uniforms.aoMap.value=l.texture,t.uniforms.diffuseTexture.value=i.texture,t.uniforms.srcTexelSize.value.set(1/l.width,1/l.height),t.uniforms.depthTexture.value=o,t.uniforms.projMatrix.value=h.camera.projectionMatrix,t.uniforms.aspectRatio.value=h.camera.aspect,t.uniforms.tanHalfFOV.value=u;const{fog:d}=h.scene;d&&(t.uniforms.fogNearFar.value.set(d.near,d.far),t.uniforms.fogColor.value.set(d.color.r,d.color.g,d.color.b,te.now.fogAlpha)),(t.useFog!==te.now.fog||t.fogTransparent!==te.now.bg.transparent)&&(t.setValues({useFog:te.now.fog,fogTransparent:te.now.bg.transparent}),t.needsUpdate=!0),h.renderer.setRenderTarget(a),h.renderer.renderScreenQuad(t)}})();le.prototype.reset=function(){this._picker&&this._picker.reset(),this._lastPick=null,this._releaseAllVisuals(),this._setEditMode(Et.COMPLEX),this._resetObjects(),this._gfx&&(Je.clearTree(this._gfx.pivot),this._gfx.renderer2d.reset()),this.setNeedRender()};le.prototype._resetScene=function(){this._objectControls.reset(),this._objectControls.allowTranslation(!0),this._objectControls.allowAltObjFreeRotation(!0),this.resetReps(),this.resetPivot(),this.rebuildAll()};le.prototype.resetView=function(){this._picker&&this._picker.reset(),this._setEditMode(Et.COMPLEX),this._resetScene(),this._forEachComplexVisual(r=>{r.updateSelectionMask({}),r.rebuildSelectionGeometry()})};le.prototype._export=function(r){const e=de.default.head(gs.exporters.find({format:r}));if(!e)return this.logger.error("Could not find suitable exporter for this source"),Promise.reject(new Error("Could not find suitable exporter for this source"));if(this.dispatchEvent({type:"exporting"}),this._visuals[this._curVisualName]instanceof Bi){let t=null;return e.SourceClass===Bi?t=this._visuals[this._curVisualName]:e.SourceClass===Df&&(t=this._visuals[this._curVisualName]._complex),new e(t,{miewVersion:le.VERSION}).export().then(i=>i)}return this._visuals[this._curVisualName]instanceof Qf?Promise.reject(new Error("Sorry, exporter for volume data not implemented yet")):Promise.reject(new Error("Unexpected format of data"))};const QN=/^(?:(pdb|cif|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i,eO=/^(?:pc|pubchem):\s*([a-z]+)$/i,tO=/^([a-z][a-z\d\-+.]*):/i;function nO(r,e){if(!de.default.isString(r))return r;const t=QN.exec(r);if(t){let[,i="pdb",s]=t;switch(i=i.toLowerCase(),s=s.toUpperCase(),i){case"pdb":r=`https://files.rcsb.org/download/${s}.pdb`;break;case"cif":r=`https://files.rcsb.org/download/${s}.cif`;break;case"ccp4":r=`https://www.ebi.ac.uk/pdbe/coordinates/files/${s.toLowerCase()}.ccp4`;break;case"dsn6":r=`https://edmaps.rcsb.org/maps/${s.toLowerCase()}_2fofc.dsn6`;break;default:throw new Error("Unexpected data format shortcut")}return e.fileType=i,e.fileName=`${s}.${i}`,e.sourceType="url",r}const n=eO.exec(r);if(n){const i=n[1].toLowerCase();return r=`https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${i}/JSON?record_type=3d`,e.fileType="pubchem",e.fileName=`${i}.json`,e.sourceType="url",r}return(e.sourceType==="url"||e.sourceType===void 0)&&(e.sourceType="url",tO.test(r)||(r=be.resolveURL(r))),r}function iO(r){let{binary:e}=r;if(r.fileType!==void 0){const t=de.default.head(gs.parsers.find({format:r.fileType}));if(t)e=t.binary||!1;else throw new Error("Could not find suitable parser for this format")}if(e===void 0&&r.fileExt!==void 0){const t=de.default.head(gs.parsers.find({ext:r.fileExt}));t&&(e=t.binary||!1)}r.fileExt!==void 0&&r.fileExt.toLowerCase()===".man"&&(r.binary=!0,r.animation=!0),e!==void 0&&r.binary!==void 0&&r.binary!==e&&r.context.logger.warn("Overriding incorrect binary mode"),r.binary=e||!1}function sO(r,e,t){return new Promise(n=>{if(t.shouldCancel())throw new Error("Operation cancelled");t.notify({type:"fetching"}),r=nO(r,e);const i=de.default.head(gs.loaders.find({type:e.sourceType,source:r}));if(!i)throw new Error(Ld);const s=e.fileName||i.extractName(r);if(s){const[c,h]=be.splitFileName(s);de.default.defaults(e,{name:c,fileExt:h,fileName:s})}iO(e);let o=de.default.get(e,"preset.expression");if(!de.default.isUndefined(o)&&(o=JSON.parse(o),o&&o.settings)){const c=["singleUnit"];for(let h=0,u=c.length;h<u;++h){const d=c[h],f=de.default.get(o.settings,d);de.default.isUndefined(f)||te.set(d,f)}}const a=new i(r,e);a.context=e.context,t.addEventListener("cancel",()=>a.abort()),a.addEventListener("progress",c=>{c.lengthComputable&&c.total>0?o_(a.logger,"Fetching",c.loaded/c.total):o_(a.logger,"Fetching")}),console.time("fetch");const l=a.load().then(c=>(console.timeEnd("fetch"),e.context.logger.info("Fetching finished"),t.notify({type:"fetchingDone",data:c}),c)).catch(c=>{throw console.timeEnd("fetch"),e.context.logger.debug(c.message),c.stack&&e.context.logger.debug(c.stack),e.context.logger.error("Fetching failed"),t.notify({type:"fetchingDone",error:c}),c});n(l)})}function rO(r,e,t){if(t.shouldCancel())return Promise.reject(new Error("Operation cancelled"));t.notify({type:"parsing"});const n=de.default.head(gs.parsers.find({format:e.fileType,ext:e.fileExt,data:r}));if(!n)return Promise.reject(new Error("Could not find suitable parser"));const i=new n(r,e);return i.context=e.context,t.addEventListener("cancel",()=>i.abort()),console.time("parse"),i.parse().then(s=>(console.timeEnd("parse"),t.notify({type:"parsingDone",data:s}),s)).catch(s=>{throw console.timeEnd("parse"),e.error=s,e.context.logger.debug(s.message),s.stack&&e.context.logger.debug(s.stack),e.context.logger.error("Parsing failed"),t.notify({type:"parsingDone",error:s}),s})}le.prototype.load=function(r,e){e=de.default.merge({},e,{context:this}),this.settings.now.use.multiFile||(this._loading.length&&(this._loading.forEach(i=>{i.cancel()}),this._loading.length=0),e.animation||this.reset(!0)),this._interpolator.reset(),this.dispatchEvent({type:"loading",options:e,source:r});const t=new XT;this._loading.push(t),t.addEventListener("notification",i=>{this.dispatchEvent(i.slaveEvent)}),this._spinner.spin(this._container);const n=i=>{const s=this._loading.indexOf(t);return s!==-1&&this._loading.splice(s,1),this._spinner.stop(),this._refreshTitle(),t.notify({type:"loadingDone",anything:i}),i};return sO(r,e,t).then(i=>rO(i,e,t)).then(i=>{const s=this._onLoad(i,e);return n(s)}).catch(i=>{throw this.logger.error("Could not load data"),this.logger.debug(i),n(i)})};le.prototype.unload=function(r){this._removeVisual(r||this.getCurrentVisual()),this.resetPivot(),te.now.shadow.on&&this._updateShadowCamera()};le.prototype._startAnimation=function(r){this._stopAnimation();const e=this,t=this._getComplexVisual();if(t===null){this.logger.error("Unable to start animation - no molecule is loaded.");return}try{this._frameInfo=new _N(t.getComplex(),r,{onLoadStatusChanged(){e.dispatchEvent({type:"mdPlayerStateChanged",state:{isPlaying:e._isAnimating,isLoading:e._frameInfo?e._frameInfo.isLoading:!0}})},onError(n){e._stopAnimation(),e.logger.error(n)}})}catch{this.logger.error("Animation file does not fit to current complex!");return}this._continueAnimation()};le.prototype._pauseAnimation=function(){this._animInterval!==null&&(this._isAnimating=!1,clearInterval(this._animInterval),this._animInterval=null,this._frameInfo&&this.dispatchEvent({type:"mdPlayerStateChanged",state:{isPlaying:this._isAnimating,isLoading:this._frameInfo.isLoading}}))};le.prototype._continueAnimation=function(){this._isAnimating=!0;let r=1e3/te.now.maxfps;r=Number.isNaN(r)?0:r;const e=this,{pivot:t}=e._gfx,n=this._getComplexVisual();n&&(n.resetSelectionMask(),n.rebuildSelectionGeometry(),this._msgAtomInfo.style.opacity=0),this._animInterval=setInterval(()=>{if(e.dispatchEvent({type:"mdPlayerStateChanged",state:{isPlaying:e._isAnimating,isLoading:e._frameInfo.isLoading}}),e._frameInfo.frameIsReady){t.updateToFrame(e._frameInfo),e._updateObjsToFrame(e._frameInfo),e._refreshTitle(` Frame ${e._frameInfo._currFrame} of ${e._frameInfo._framesCount} time interval - ${e._frameInfo._timeStep}`);try{e._frameInfo.nextFrame()}catch{e.logger.error("Error during animation"),e._stopAnimation();return}e._needRender=!0}},r)};le.prototype._stopAnimation=function(){this._animInterval!==null&&(clearInterval(this._animInterval),this._frameInfo.disableEvents(),this._frameInfo=null,this._animInterval=null,this.dispatchEvent({type:"mdPlayerStateChanged",state:null}))};le.prototype._onLoad=function(r,e){const t=this._gfx;let n=null;if(e.animation)return this._refreshTitle(),this._startAnimation(r),null;if(this._stopAnimation(),(!e||!e.keepRepsInfo)&&(this._opts.reps=null,this._opts._objects=null),r.id==="Complex"){const i=r;e.fileName?i.name=i.name||r_(e.fileName).toUpperCase():e.amberFileName?i.name=i.name||r_(e.amberFileName).toUpperCase():i.name=`Dynamic ${e.fileType} molecule`,n=this._addVisual(new Bi(i.name,i)),this._curVisualName=n;const s=this.info();if(this.logger.info(`Parsed ${e.fileName} (${s.atoms} atoms, ${s.bonds} bonds, ${s.residues} residues, ${s.chains} chains).`),de.default.isNumber(this._opts.unit)&&i.setCurrentUnit(this._opts.unit),!e.preset)if(te.now.autoPreset)switch(e.fileType){case"cml":this.resetReps("small");break;case"pdb":case"mmtf":case"cif":JN(i)?this.resetReps("macro"):this.resetReps("small");break;default:this.resetReps("default");break}else this.resetReps("default")}else r.id==="Volume"&&(this.resetEd(),n=this._onLoadEd(r));return t.camera.updateProjectionMatrix(),this._updateFog(),t.root.resetTransform(),this.resetPivot(),this._objectControls.setScale(te.now.radiusToFit/this._getBSphereRadius()),this._resetObjects(),te.now.autoResolution&&this._tweakResolution(),te.now.shadow.on&&this._updateShadowCamera(),this._opts.view&&(this.view(this._opts.view),delete this._opts.view),this._refreshTitle(),n};le.prototype.resetEd=function(){this._edLoader&&(this._edLoader.abort(),this._edLoader=null),this._removeVisual(this._getVolumeVisual()),this._needRender=!0};le.prototype.loadEd=function(r){this.resetEd();const e=de.default.head(gs.loaders.find({source:r}));if(!e)return this.logger.error(Ld),Promise.reject(new Error(Ld));const t=this._edLoader=new e(r,{binary:!0});return t.context=this,t.load().then(n=>{const i=de.default.head(gs.parsers.find({format:"ccp4"}));if(!i)throw new Error(ZN);const s=new i(n);return s.context=this,s.parse().then(o=>{this._onLoadEd(o)})}).catch(n=>{this.logger.error("Could not load ED data"),this.logger.debug(n)})};le.prototype._onLoadEd=function(r){r.normalize();const e=new Qf("volume",r);e.getMesh().layers.set(Je.LAYERS.VOLUME);const t=this._addVisual(e);return this._needRender=!0,t};le.prototype._needRebuild=function(){let r=!1;return this._forEachComplexVisual(e=>{r=r||e.needsRebuild()}),r};le.prototype._rebuildObjects=function(){const r=this,e=this._gfx;let t,n;const i=[];for(t=0;t<e.pivot.children.length;++t){const s=e.pivot.children[t];s instanceof _a||i.push(s)}for(t=0;t<i.length;++t)i[t].parent.remove(i[t]);setTimeout(()=>{const s=r._objects;for(t=0,n=s.length;t<n;++t){const o=s[t];o.needsRebuild&&o.build(),o.getGeometry()&&e.pivot.add(o.getGeometry())}},10)};le.prototype.changeUnit=function(r,e){const t=this._getComplexVisual(e);if(!t)throw new Error("There is no complex to change!");function n(){const i=t?t.getComplex().getCurrentUnit():0,s=i>0?`Bio molecule ${i}`:"Asymmetric unit";return`Current unit: ${i} (${s})`}return r===void 0||(de.default.isString(r)&&(r=Math.max(parseInt(r,10),0)),t.getComplex().setCurrentUnit(r)&&(this._resetScene(),this._updateInfoPanel())),n()};le.prototype.rebuild=function(){if(this._building){this.logger.warn("Miew.rebuild(): already building!");return}this._building=!0,this.dispatchEvent({type:"rebuilding"}),this._rebuildObjects(),this._gfx.renderer2d.reset();const r=[];this._forEachComplexVisual(t=>{t.needsRebuild()&&r.push(t.rebuild().then(()=>new Promise(n=>{t.rebuildSelectionGeometry(),n()})))});const e=this;this._spinner.spin(this._container),Promise.all(r).then(()=>{e._spinner.stop(),e._needRender=!0,e._refreshTitle(),this.dispatchEvent({type:"buildingDone"}),e._building=!1})};le.prototype.rebuildAll=function(){this._forEachComplexVisual(r=>{r.setNeedsRebuild()})};le.prototype._refreshTitle=function(r){let e;r=r===void 0?"":r;const t=this._getComplexVisual();if(t){e=t.getComplex().name;const n=t.repGet(t.repCurrent());e+=n?`  ${n.mode.name} Mode`:""}else e=Object.keys(this._visuals).length>0?"Unknown":"No Data";e+=r,this.dispatchEvent({type:"titleChanged",data:e})};le.prototype.setNeedRender=function(){this._needRender=!0};le.prototype._extractRepresentation=function(){const r=[];this._forEachComplexVisual(e=>{if(e.getSelectionCount()===0)return;const t=e.buildSelectorFromMask(1<<e.getSelectionBit()),n=te.now.presets.default,i=e.repAdd({selector:t,mode:n[0].mode.id,colorer:n[0].colorer.id,material:n[0].material.id});if(!i){e.repCount()===Bi.NUM_REPRESENTATION_BITS&&this.logger.warn(`Number of representations is limited to ${Bi.NUM_REPRESENTATION_BITS}`);return}this.dispatchEvent({type:"repAdded",index:i.index,name:e.name}),e.repCurrent(i.index),r.push(e.name)}),r.length>0&&this.logger.report(`New representation from selection for complexes: ${r.join(", ")}`)};le.prototype._setReps=function(r){r=r||this._opts&&this._opts.reps||[],this._forEachComplexVisual(e=>e.resetReps(r))};le.prototype.applyPreset=function(r){const{presets:e}=te.now,t=[r||te.defaults.preset,te.defaults.preset,Object.keys(e)[0]];let n=null;for(let i=0;!n&&i<t.length;++i)te.set("preset",t[i]),n=e[te.now.preset],n||this.logger.warn(`Unknown preset "${te.now.preset}"`);this._setReps(n)};le.prototype.resetReps=function(r){const e=this._opts&&this._opts.reps;e?this._setReps(e):this.applyPreset(r)};le.prototype.repCount=function(r){const e=this._getComplexVisual(r);return e?e.repCount():0};le.prototype.repCurrent=function(r,e){const t=this._getComplexVisual(e),n=t?t.repCurrent(r):-1;return r&&n!==r&&this.logger.warn(`Representation ${r} was not found. Current rep remains unchanged.`),n};le.prototype.rep=function(r,e){const t=this._getComplexVisual("");if(!t)return null;const n=t.rep(r,e);return n.status==="created"?this.dispatchEvent({type:"repAdded",index:n.index,name:t.name}):n.status==="changed"&&this.dispatchEvent({type:"repChanged",index:n.index,name:t.name}),n.desc};le.prototype.repGet=function(r,e){const t=this._getComplexVisual(e);return t?t.repGet(r):null};le.prototype.repAdd=function(r,e){const t=this._getComplexVisual(e);if(!t)return-1;const n=t.repAdd(r);return n?(this.dispatchEvent({type:"repAdded",index:n.index,name:e}),n.index):-1};le.prototype.repRemove=function(r,e){const t=this._getComplexVisual(e);t&&(t.repRemove(r),this.dispatchEvent({type:"repRemoved",index:r,name:e}))};le.prototype.repHide=function(r,e,t){this._needRender=!0;const n=this._getComplexVisual(t);return n?n.repHide(r,e):null};le.prototype._setEditMode=function(r){this._editMode=r;const e=this._msgMode;if(e&&(e.style.opacity=r===Et.COMPLEX?0:1,r!==Et.COMPLEX)){const t=e.getElementsByTagName("p")[0];t.innerHTML=r===Et.COMPONENT?"COMPONENT EDIT MODE":"FRAGMENT EDIT MODE"}this.dispatchEvent({type:"editModeChanged",data:r===Et.COMPLEX})};le.prototype._enterComponentEditMode=function(){if(this._editMode!==Et.COMPLEX)return;const r=[];this._forEachComplexVisual(e=>{const t=e.beginComponentEdit();t&&r.push(t)}),r!==[]&&(this._editors=r,this.logger.info("COMPONENT EDIT MODE -- ON"),this._setEditMode(Et.COMPONENT),this._objectControls.keysTranslateObj(!0))};le.prototype._applyComponentEdit=function(){if(this._editMode===Et.COMPONENT){this._objectControls.stop(),this._objectControls.keysTranslateObj(!1);for(let r=0;r<this._editors.length;++r)this._editors[r].apply();this._editors=[],this.logger.info("COMPONENT EDIT MODE -- OFF (applied)"),this._setEditMode(Et.COMPLEX),this.rebuildAll()}};le.prototype._discardComponentEdit=function(){if(this._editMode===Et.COMPONENT){this._objectControls.stop(),this._objectControls.keysTranslateObj(!1);for(let r=0;r<this._editors.length;++r)this._editors[r].discard();this._editors=[],this.logger.info("COMPONENT EDIT MODE -- OFF (discarded)"),this._setEditMode(Et.COMPLEX),this._needRender=!0,this.rebuildAll()}};le.prototype._enterFragmentEditMode=function(){if(this._editMode!==Et.COMPLEX)return;const r=[];if(this._forEachComplexVisual(t=>{t instanceof Bi&&t.getSelectionCount()>0&&r.push(t)}),r.length!==1)return;const e=r[0].beginFragmentEdit();e&&(this._editors=[e],this.logger.info("FRAGMENT EDIT MODE -- ON (single bond)"),this._setEditMode(Et.FRAGMENT),this._objectControls.allowTranslation(!1),this._objectControls.allowAltObjFreeRotation(e.isFreeRotationAllowed()),this._needRender=!0)};le.prototype._applyFragmentEdit=function(){if(this._editMode===Et.FRAGMENT){this._objectControls.stop();for(let r=0;r<this._editors.length;++r)this._editors[r].apply();this._editors=[],this.logger.info("FRAGMENT EDIT MODE -- OFF (applied)"),this._setEditMode(Et.COMPLEX),this._objectControls.allowTranslation(!0),this._objectControls.allowAltObjFreeRotation(!0),this.rebuildAll()}};le.prototype._discardFragmentEdit=function(){if(this._editMode===Et.FRAGMENT){this._objectControls.stop();for(let r=0;r<this._editors.length;++r)this._editors[r].discard();this._editors=[],this.logger.info("FRAGMENT EDIT MODE -- OFF (discarded)"),this._setEditMode(Et.COMPLEX),this._objectControls.allowTranslation(!0),this._objectControls.allowAltObjFreeRotation(!0),this._needRender=!0}};le.prototype._onPick=function(r){if(!te.now.picking||this._animInterval!==null||this._editMode===Et.FRAGMENT||this._objectControls.isEditingAltObj())return;let e=null;r.obj.atom?(e=r.obj.atom.residue.getChain().getComplex(),this._lastPick=r.obj.atom):r.obj.residue?(e=r.obj.residue.getChain().getComplex(),this._lastPick=r.obj.residue):r.obj.chain?(e=r.obj.chain.getComplex(),this._lastPick=r.obj.chain):r.obj.molecule?(e=r.obj.molecule.complex,this._lastPick=r.obj.molecule):this._lastPick=null;function t(n){n.updateSelectionMask(r.obj),n.rebuildSelectionGeometry()}if(e){const n=this._getVisualForComplex(e);n&&(t(n),this._needRender=!0)}else this._forEachComplexVisual(t),this._needRender=!0;this._updateInfoPanel(),this.dispatchEvent(r)};le.prototype._onKeyDown=function(r){if(!(!this._running||!this._hotKeysEnabled)){if(te.now.editing)switch(r.code){case"KeyC":this._enterComponentEditMode();break;case"KeyF":this._enterFragmentEditMode();break;case"KeyA":switch(this._editMode){case Et.COMPONENT:this._applyComponentEdit();break;case Et.FRAGMENT:this._applyFragmentEdit();break}break;case"KeyD":switch(this._editMode){case Et.COMPONENT:this._discardComponentEdit();break;case Et.FRAGMENT:this._discardFragmentEdit();break}break}switch(r.code){case"NumpadAdd":r.altKey&&(r.preventDefault(),r.stopPropagation(),this._forEachComplexVisual(e=>{e.expandSelection(),e.rebuildSelectionGeometry()}),this._updateInfoPanel(),this._needRender=!0);break;case"NumpadSubtract":r.altKey&&(r.preventDefault(),r.stopPropagation(),this._forEachComplexVisual(e=>{e.shrinkSelection(),e.rebuildSelectionGeometry()}),this._updateInfoPanel(),this._needRender=!0);break}}};le.prototype._onKeyUp=function(r){!this._running||!this._hotKeysEnabled||r.code==="KeyX"&&this._extractRepresentation()};le.prototype._updateInfoPanel=function(){const r=this._msgAtomInfo.getElementsByTagName("p")[0];let e,t,n=0;for(this._forEachComplexVisual(l=>{n+=l.getSelectionCount()});r.firstChild;)r.removeChild(r.firstChild);if(n===0){this._msgAtomInfo.style.opacity=0;return}let i=`${String(n)} atom${n!==1?"s":""} selected`;this._lastPick!==null&&(i+=", the last pick:");let s="",o="",a="";if(this._lastPick instanceof jN){e=this._lastPick,t=e.residue,o=e.name;const l=e.location!==32?String.fromCharCode(e.location):"";s=`${e.element.fullName} #${e.serial}${l}:       ${t._chain._name}.${t._type._name}${t._sequence}${t._icode.trim()}.`,s+=o,a=`Coord: (${e.position.x.toFixed(2).toString()},     ${e.position.y.toFixed(2).toString()},     ${e.position.z.toFixed(2).toString()})`}else this._lastPick instanceof YN?(t=this._lastPick,s=`${t._type._fullName}:       ${t._chain._name}.${t._type._name}${t._sequence}${t._icode.trim()}`):this._lastPick instanceof qN?s=`chain ${this._lastPick._name}`:this._lastPick instanceof $N&&(s=`molecule ${this._lastPick._name}`);r.appendChild(document.createTextNode(i)),s!==""&&(r.appendChild(document.createElement("br")),r.appendChild(document.createTextNode(s))),a!==""&&(r.appendChild(document.createElement("br")),r.appendChild(document.createTextNode(a))),this._msgAtomInfo.style.opacity=1};le.prototype._getAltObj=function(){if(this._editors){let r=null;for(let e=0;e<this._editors.length;++e){const t=this._editors[e].getAltObj();if(t.objects.length>0){if(r){r=null;break}r=t}}if(r)return r}return{objects:[],pivot:new x.Vector3(0,0,0)}};le.prototype.resetPivot=(function(){const r=new x.Box3,e=new x.Vector3;return function(){r.makeEmpty(),this._forEachVisual(t=>{r.union(t.getBoundaries().boundingBox)}),r.getCenter(e),this._objectControls.setPivot(e.negate()),this.dispatchEvent({type:"transform"})}})();le.prototype.setPivotResidue=(function(){const r=new x.Vector3;return function(e){const t=this._getVisualForComplex(e.getChain().getComplex());if(t){if(e._controlPoint)r.copy(e._controlPoint);else{let n=0,i=0,s=0;const o=e._atoms.length;for(let a=0;a<o;++a){const l=e._atoms[a].position;n+=l.x/o,i+=l.y/o,s+=l.z/o}r.set(n,i,s)}r.applyMatrix4(t.matrix).negate(),this._objectControls.setPivot(r),this.dispatchEvent({type:"transform"})}}})();le.prototype.setPivotAtom=(function(){const r=new x.Vector3;return function(e){const t=this._getVisualForComplex(e.residue.getChain().getComplex());t&&(r.copy(e.position),r.applyMatrix4(t.matrix).negate(),this._objectControls.setPivot(r),this.dispatchEvent({type:"transform"}))}})();le.prototype.getSelectionCenter=(function(){const r=new x.Vector3(0,0,0);return function(e,t,n){e.set(0,0,0);let i=0;return this._forEachComplexVisual(s=>{s.getSelectionCenter(r,t,n||s.getSelectionBit())&&(e.add(r),i++)}),i===0?!1:(e.divideScalar(i),e.negate(),!0)}})();le.prototype.setPivotSubset=(function(){const r=new x.Vector3(0,0,0);function e(n,i){return n.mask&1<<i}function t(n,i){return i.selector.includesAtom(n)}return function(n){const i=n?t:e;this.getSelectionCenter(r,i,n)?(this._objectControls.setPivot(r),this.dispatchEvent({type:"transform"})):this.logger.warn("selection is empty. Center operation not performed")}})();le.prototype.screenshot=function(r,e){const t=this._gfx,n=t.renderer.domElement.width,i=t.renderer.domElement.height;function s(c){return Math.tan(x.MathUtils.degToRad(.5*c))}function o(c){return x.MathUtils.radToDeg(Math.atan(c))*2}function a(){let c;if(be.getBrowser()===be.browserType.SAFARI){const u=document.createElement("canvas"),d=u.getContext("2d");u.width=r===void 0?n:r,u.height=e===void 0?i:e,d.drawImage(t.renderer.domElement,0,0,u.width,u.height),c=u.toDataURL("image/png")}else c=t.renderer.domElement.toDataURL("image/png");return c}e=e||r;let l;if(r===void 0&&e===void 0||r===n&&e===i)l=a();else{const c=t.camera.aspect,h=t.camera.fov,u=s(t.camera.fov),d=Math.min(t.width,t.height),f=u*d/t.height,p=r/e;t.renderer.setPixelRatio(1),t.camera.aspect=p,t.camera.fov=o(f/Math.min(p,1)),t.camera.updateProjectionMatrix(),t.renderer.setDrawingBufferSize(r,e,1),this._renderFrame(te.now.stereo),l=a(),t.renderer.setPixelRatio(window.devicePixelRatio),t.camera.aspect=c,t.camera.fov=h,t.camera.updateProjectionMatrix(),t.renderer.setDrawingBufferSize(t.width,t.height,window.devicePixelRatio),this._needRender=!0}return l};le.prototype.screenshotSave=function(r,e,t){const n=this.screenshot(e,t);be.shotDownload(n,r)};le.prototype.save=function(r){this._export(r.fileType).then(e=>{const t=this._visuals[this._curVisualName]._complex.name;be.download(e,t,r.fileType),this._refreshTitle(),this.dispatchEvent({type:"exportingDone"})}).catch(e=>{this.logger.error("Could not export data"),this.logger.debug(e),this._refreshTitle(),this.dispatchEvent({type:"exportingDone",error:e})})};le.prototype._tweakResolution=function(){const r=[["poor",100],["low",500],["medium",1e3],["high",5e3],["ultra",Number.MAX_VALUE]];let e=0;if(this._forEachComplexVisual(t=>{e+=t.getComplex().getAtomCount()}),e>0){const t=this._gfxScore*1e6/e;for(let n=0;n<r.length;++n)if(t<r[n][1]){this._autoChangeResolution(r[n][0]);break}}};le.prototype._autoChangeResolution=function(r){r!==te.now.resolution&&this.logger.report(`Your rendering resolution was changed to "${r}" for best performance.`),te.now.resolution=r};le.prototype.saveSettings=function(){this._cookies.setCookie(this._opts.settingsCookie,JSON.stringify(this.settings.getDiffs(!0)))};le.prototype.restoreSettings=function(){try{const r=this._cookies.getCookie(this._opts.settingsCookie),e=r?JSON.parse(r):{};this.settings.applyDiffs(e,!0)}catch(r){this.logger.error(`Cookies parse error: ${r.message}`)}};le.prototype.resetSettings=function(){this.settings.reset()};le.prototype.setOptions=function(r){typeof r=="string"&&(r=le.options.fromAttr(r)),r.reps&&(this._opts.reps=null),de.default.merge(this._opts,r),r.settings&&this.set(r.settings),this._opts._objects=r._objects,this._resetObjects(),r.load&&this.load(r.load,{fileType:r.type}),r.preset&&(te.now.preset=r.preset),r.reps&&this.resetReps(r.preset),this._opts.view&&(this.view(this._opts.view),delete this._opts.view);const e=this._getComplexVisual();e&&(e.getComplex().resetCurrentUnit(),de.default.isNumber(r.unit)&&e.getComplex().setCurrentUnit(r.unit),this.resetView(),this.rebuildAll())};le.prototype.info=function(r){const e=this._getComplexVisual(r);if(!e)return{};const t=e.getComplex(),{metadata:n}=t;return{id:n.id||t.name||"UNKNOWN",title:n.title&&n.title.join(" ")||"UNKNOWN DATA",atoms:t.getAtomCount(),bonds:t.getBondCount(),residues:t.getResidueCount(),chains:t.getChainCount()}};le.prototype.addObject=function(r,e){let t=null;if(r.type===s_.prototype.type&&(t=s_),t===null)throw new Error(`Unknown scene object type - ${r.type}`);try{const n=new t(r.params,r.opts);this._addSceneObject(n)}catch(n){if(!e)this.logger.debug(`Error during scene object creation: ${n.message}`);else throw n}this._needRender=!0};le.prototype._addSceneObject=function(r){const e=this._getComplexVisual();r.build&&e&&(r.build(e.getComplex()),this._gfx.pivot.add(r.getGeometry()));const t=this._objects;t[t.length]=r};le.prototype._updateObjsToFrame=function(r){const e=this._objects;for(let t=0,n=e.length;t<n;++t)e[t].updateToFrame&&e[t].updateToFrame(r)};le.prototype._resetObjects=function(){const r=this._opts._objects;if(this._objects=[],r)for(let e=0,t=r.length;e<t;++e)this.addObject(r[e],!1)};le.prototype.removeObject=function(r){const e=this._objects[r];if(!e)throw new Error(`Scene object with index ${r} does not exist`);e.destroy(),this._objects.splice(r,1),this._needRender=!0};le.prototype.getURL=function(r){return Ef.toURL(this.getState(de.default.defaults(r,{compact:!0,settings:!1,view:!1})))};le.prototype.getScript=function(r){return Ef.toScript(this.getState(de.default.defaults(r,{compact:!0,settings:!0,view:!0})))};le.prototype._compareReps=function(r,e){const t={};let n=0;r&&(n=r.repCount());const i=te.defaults.presets[te.now.preset];let s=e;i===void 0||i.length>n?(s=!1,t.preset="empty"):te.now.preset!==te.defaults.preset&&(t.preset=te.now.preset);const o=[];let a=!0;for(let l=0,c=n;l<c;++l)o[l]=r.repGet(l).compare(s?i[l]:null),de.default.isEmpty(o[l])||(a=!1);return a||(t.reps=o),t};le.prototype.getState=function(r){const e={};r=de.default.defaults(r,{compact:!0,settings:!1,view:!1});const t=this._getComplexVisual();if(t!==null){const o=t.getComplex(),{metadata:a}=o;if(a.id){const c=a.format?`${a.format}:`:"";e.load=c+a.id}const l=o.getCurrentUnit();l!==1&&(e.unit=l)}const n=this._compareReps(t,r.compact);n.preset&&(e.preset=n.preset),n.reps&&(e.reps=n.reps);const i=this._objects,s=[];for(let o=0,a=i.length;o<a;++o)s[o]=i[o].identify();if(i.length>0&&(e._objects=s),r.view&&(e.view=this.view()),r.settings){const o=this.settings.getDiffs(!1);de.default.isEmpty(o)||(e.settings=o)}return e};le.prototype.get=function(r,e){return te.get(r,e)};le.prototype._clipPlaneUpdateValue=function(r){const e=Math.max(this._gfx.camera.position.z-r*te.now.draft.clipPlaneFactor,te.now.camNear),t={clipPlaneValue:e};this._forEachComplexVisual(n=>{n.setUberOptions(t)});for(let n=0,i=this._objects.length;n<i;++n){const s=this._objects[n];s._line&&s._line.material.setUberOptions(t)}this._picker!==null&&(this._picker.clipPlaneValue=e)};le.prototype._fogFarUpdateValue=function(){this._picker!==null&&(this._gfx.scene.fog?this._picker.fogFarValue=this._gfx.scene.fog.far:this._picker.fogFarValue=void 0)};le.prototype._updateShadowmapMeshes=function(r){this._forEachComplexVisual(e=>{const t=e._reprList;for(let n=0,i=t.length;n<i;++n){const s=t[n];r(s.geo,s.material)}})};le.prototype._updateMaterials=function(r){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,t=arguments.length>2&&arguments[2]!==void 0?arguments[2]:void 0;this._forEachComplexVisual(n=>n.setMaterialValues(r,e,t));for(let n=0,i=this._objects.length;n<i;++n){const s=this._objects[n];s._line&&(s._line.material.setValues(r),s._line.material.needsUpdate=!0)}};le.prototype._fogAlphaChanged=function(){this._forEachComplexVisual(r=>{r.setUberOptions({fogAlpha:te.now.fogAlpha})})};le.prototype._embedWebXR=function(){if(te.now.stereo!=="WEBVR"){this.webVR&&this.webVR.disable(),this.webVR=null;return}this.webVR||(this.webVR=new WN(()=>{this._requestAnimationFrame(()=>this._onTick()),this._needRender=!0,this._onResize()})),this.webVR.enable(this._gfx)};le.prototype._initOnSettingsChanged=function(){const r=(e,t)=>{e=de.default.isArray(e)?e:[e],e.forEach(n=>{this.settings.addEventListener(`change:${n}`,t)})};r("modes.VD.frame",()=>{const e=this._getVolumeVisual();e!==null&&(e.showFrame(te.now.modes.VD.frame),this._needRender=!0)}),r("modes.VD.isoMode",()=>{const e=this._getVolumeVisual();e!==null&&(e.getMesh().material.updateDefines(),this._needRender=!0)}),r("bg.color",()=>{this._onBgColorChanged()}),r("ao",()=>{if(te.now.ao&&!Gy(this._gfx.renderer.getContext()))this.logger.warn("Your device or browser does not support ao"),te.set("ao",!1);else{const e={normalsToGBuffer:te.now.ao};this._setUberMaterialValues(e)}}),r("zSprites",()=>{te.now.zSprites&&!ky(this._gfx.renderer.getContext())&&(this.logger.warn("Your device or browser does not support zSprites"),te.set("zSprites",!1)),this.rebuildAll()}),r("fogColor",()=>{this._onFogColorChanged()}),r("fogColorEnable",()=>{this._onFogColorChanged()}),r("bg.transparent",e=>{const t=this._gfx;t&&t.renderer.setClearColor(te.now.bg.color,+!te.now.bg.transparent),this._updateMaterials({fogTransparent:e.value}),this.rebuildAll()}),r("draft.clipPlane",e=>{this._updateMaterials({clipPlane:e.value}),this.rebuildAll()}),r("shadow.on",e=>{const t={shadowmap:e.value,shadowmapType:te.now.shadow.type},n=this._gfx;n&&(n.renderer.shadowMap.enabled=!!t.shadowmap),this._updateMaterials(t,!0),t.shadowmap?(this._updateShadowCamera(),this._updateShadowmapMeshes(io.createShadowmapMaterial)):this._updateShadowmapMeshes(io.removeShadowmapMaterial),this._needRender=!0}),r("shadow.type",e=>{te.now.shadow.on&&(this._updateMaterials({shadowmapType:e.value},!0),this._needRender=!0)}),r("shadow.radius",e=>{for(let t=0;t<this._gfx.scene.children.length;t++)if(this._gfx.scene.children[t].shadow!==void 0){const n=this._gfx.scene.children[t];n.shadow.radius=e.value,this._needRender=!0}}),r("fps",()=>{this._fps.show(te.now.fps)}),r(["fog","fogNearFactor","fogFarFactor"],()=>{this._updateFog(),this._needRender=!0}),r("fogAlpha",()=>{const{fogAlpha:e}=te.now;(e<0||e>1)&&this.logger.warn("fogAlpha must belong range [0,1]"),this._fogAlphaChanged(),this._needRender=!0}),r("autoResolution",e=>{e.value&&!this._gfxScore&&this.logger.warn("Benchmarks are missed, autoresolution will not work! Autoresolution should be set during miew startup.")}),r("stereo",()=>{this._embedWebXR(te.now.stereo==="WEBVR"),this._needRender=!0}),r(["transparency","palette"],()=>{this.rebuildAll()}),r("resolution",()=>{this.rebuildAll();const e=this._getVolumeVisual();e&&(e.getMesh().material.updateDefines(),this._needRender=!0)}),r(["axes","fxaa","ao","outline.on","outline.color","outline.threshold","outline.thickness"],()=>{this._needRender=!0})};le.prototype.set=function(r,e){te.set(r,e)};le.prototype.select=function(r,e){const t=this._getComplexVisual();if(!t)return;let n=r;de.default.isString(r)&&(n=Tc.parse(r).selector),t.select(n,e),this._lastPick=null,this._updateInfoPanel(),this._needRender=!0};const Ou="1";le.prototype.view=function(r){const e=this,{pivot:t}=this._gfx;let n=[];const i="ZXY";function s(){const a=t.position,l=e._objectControls.getScale()/te.now.radiusToFit,c=new x.Euler;return c.setFromQuaternion(e._objectControls.getOrientation(),i),n=[a.x,a.y,a.z,l,c.x,c.y,c.z],Ou+be.arrayToBase64(n,Float32Array)}function o(){r.length===40&&(r=`0${r}`);const a=r[0];if(n=be.arrayFromBase64(r.substr(1),Float32Array),a!==Ou)if(a==="0")n[3]/=8;else{e.logger.warn(`Encoded view version mismatch, stored as ${a} vs ${Ou} expected`);return}const l=e._interpolator,c=l.createView();c.position.copy(t.position),c.scale=e._objectControls.getScale(),c.orientation.copy(e._objectControls.getOrientation());const h=l.createView();h.position.set(n[0],n[1],n[2]),e._getComplexVisual()&&h.position.sub(e._getComplexVisual().position),h.scale=n[3],h.orientation.setFromEuler(new x.Euler(n[4],n[5],n[6],i)),l.setup(c,h)}return typeof r>"u"?s():(o(),r)};le.prototype._updateView=function(){const r=this,{pivot:e}=this._gfx,t=this._interpolator;if(t.wasStarted()||t.start(),!t.isMoving())return;const n=t.getCurrentView();if(n.success){const i=n.view;e.position.copy(i.position),r._objectControls.setScale(i.scale*te.now.radiusToFit),r._objectControls.setOrientation(i.orientation),this.dispatchEvent({type:"transform"}),r._needRender=!0}};le.prototype.translate=function(r,e,t){this._objectControls.translatePivot(r,e,t),this.dispatchEvent({type:"transform"}),this._needRender=!0};le.prototype.rotate=function(r,e,t){this._objectControls.rotate(new x.Quaternion().setFromEuler(new x.Euler(r,e,t,"XYZ"))),this.dispatchEvent({type:"transform"}),this._needRender=!0};le.prototype.scale=function(r){if(r<=0)throw new RangeError("Scale should be greater than zero");this._objectControls.scale(r),this.dispatchEvent({type:"transform"}),this._needRender=!0};le.prototype.center=function(r){if(r===void 0){this.setPivotSubset(),this._needRender=!0;return}if(r.obj!==void 0&&("atom"in r.obj||"residue"in r.obj)){"atom"in r.obj?this.setPivotAtom(r.obj.atom):this.setPivotResidue(r.obj.residue),this._needRender=!0;return}if(r.obj===void 0&&r!==""){const e=Tc.parse(r);if(e.error===void 0){this.setPivotSubset(e),this._needRender=!0;return}}this.resetPivot(),this._needRender=!0};le.prototype.within=function(r,e){const t=this._getComplexVisual();if(!t)return Tc.None();r instanceof String&&(r=Tc.parse(r));const n=t.within(r,e);return n&&(t.rebuildSelectionGeometry(),this._needRender=!0),n};le.prototype.projected=function(r,e){const t=this._getComplexVisual(e);if(!t)return!1;const n=t.getComplex().getAtomByFullname(r);if(n===null)return!1;const i=n.position.clone();return this._gfx.pivot.updateMatrixWorldRecursive(),this._gfx.camera.updateMatrixWorldRecursive(),this._gfx.pivot.localToWorld(i),i.project(this._gfx.camera),{x:(i.x+1)*.5*this._gfx.width,y:(1-i.y)*.5*this._gfx.height}};le.prototype.dssp=function(r){const e=this._getComplexVisual(r);e&&(e.getComplex().dssp(),e._reprList.forEach(t=>{(t.mode.id==="CA"||t.colorer.id==="SS")&&(t.needsRebuild=!0)}))};le.prototype.exportCML=function(){const r=this;function e(s){const o=new x.Vector3,a=new x.Vector3,l=new x.Vector3;s.extractBasis(o,a,l),o.normalize(),a.normalize(),l.normalize();const c=new x.Matrix4;return c.identity(),c.makeBasis(o,a,l),c}function t(s){const{root:o}=r._gfx,a=e(o.matrixWorld),l=new x.Vector4(0,0,0,0),c=new x.Vector4(0,0,0,0);let h=null,u=null;s.forEachAtom(d=>{d.xmlNodeRef&&d.xmlNodeRef.xmlNode&&(h=d.xmlNodeRef.xmlNode,u=d.position,l.set(u.x,u.y,u.z,1),l.applyMatrix4(a),h.setAttribute("x3",l.x.toString()),h.setAttribute("y3",l.y.toString()),h.setAttribute("z3",l.z.toString()),h.removeAttribute("x2"),h.removeAttribute("y2"))}),s.forEachSGroup(d=>{if(d.xmlNodeRef&&d.xmlNodeRef.xmlNode){h=d.xmlNodeRef.xmlNode,u=d.getPosition(),l.set(u.x,u.y,u.z,1);const f=d.getCentralPoint();f===null?l.applyMatrix4(a):(c.set(f.x,f.y,f.z,0),l.add(c),l.applyMatrix4(a),c.set(f.x,f.y,f.z,1),c.applyMatrix4(a),l.sub(c)),h.setAttribute("x",l.x.toString()),h.setAttribute("y",l.y.toString()),h.setAttribute("z",l.z.toString())}})}const n=r._getComplexVisual(),i=n?n.getComplex():null;return i&&i.originalCML?(t(i),new XMLSerializer().serializeToString(i.originalCML)):null};le.prototype.motm=function(){te.set({fogColorEnable:!0,fogColor:0,outline:{on:!0,threshold:.01},bg:{color:16777215}}),this._forEachComplexVisual(r=>{const e=[],t=r.getComplex(),n=lo.get(te.now.palette);for(let i=0;i<t.getChainCount();i++){const s=t._chains[i]._name,o=n.getChainColor(s);e[i]={selector:`chain ${s}`,mode:"VW",colorer:["CB",{color:o,factor:.9}],material:"FL"}}r.resetReps(e)})};le.prototype.VERSION="0.11.1";de.default.assign(le,{VERSION:le.prototype.VERSION,registeredPlugins:[],chem:Bt,io:gs,modes:pc,colorers:mc,materials:no,palettes:lo,options:Ef,settings:te,utils:be,gfx:{Representation:Rd},thirdParty:{lodash:de.default,three:x}});const hr=le;var us=xn(89);const _p={$help:["Rendering mode shortcut","    BS - balls and sticks mode","    LN - lines mode","    LC - licorice mode","    VW - van der waals mode","    TR - trace mode","    TU - tube mode","    CA - cartoon mode","    SA - isosurface mode","    QS - quick surface mode","    SE - solvent excluded mode","    TX - text mode"],BS:{$help:["   Balls and sticks","      aromrad = <number> #aromatic radius","      atom = <number>    #atom radius","      bond = <number>    #bond radius","      multibond = <bool> #use multibond","      showarom = <bool>  #show aromatic",`      space = <number>   #space value
`]},CA:{$help:["   Cartoon","      arrow = <number>   #arrow size","      depth = <number>   #depth of surface","      heightSegmentsRatio = <number>","      radius = <number>  #tube radius","      tension = <number> #",`      width = <number>  #secondary width
`]},LN:{$help:["   Lines","      atom = <number>    #atom radius","      chunkarom = <number>","      multibond = <bool> #use multibond","      showarom = <bool>  #show aromatic",`      offsarom = <number>
`]},LC:{$help:["   Licorice","      aromrad = <number> #aromatic radius","      bond = <number>    #bond radius","      multibond = <bool> #use multibond","      showarom = <bool>  #show aromatic",`      space = <number>   #space value
`]},VW:{$help:["   Van der Waals",`      nothing
`]},TR:{$help:["   Trace",`      radius = <number>  #tube radius
`]},TU:{$help:["   Tube","      heightSegmentsRatio = <number>","      radius = <number>  #tube radius",`      tension = <number> 
`]},SA:{$help:["   Surface",`      zClip = <bool> #clip z plane
`]},QS:{$help:["   Quick surface","      isoValue = <number>","      scale = <number>","      wireframe = <bool>",`      zClip = <bool> #clip z plane
`]},SE:{$help:["   Solvent excluded surface",`      zClip = <bool> #clip z plane
`]},TX:{$help:["   Text mode",'      template = <format string> string that can include "{{ id }}"',"          it will be replaced by value, id can be one of next:",`          serial, name, type, sequence, residue, chain, hetatm, water
`,'      horizontalAlign = <string> {"left", "right", "center"}','      verticalAlign = <string> {"top", "bottom", "middle"}',"      dx = <number> #offset along x","      dy = <number> #offset along y","      dz = <number> #offset along z","      fg = <string> #text color modificator","           could be keyword, named color or hex","      fg = <string> #back color modificator","           could be keyword, named color or hex","      showBg = <bool> #if set show background","           plate under text"]}},yp={$help:["Coloring mode shortcut","    EL - color by element","    CH - color by chain","    SQ - color by sequence","    RT - color by residue type","    SS - color by secondary structure","    UN - uniform"],UN:{$help:["Parameters of coloring modes customization","   Uniform",`      color = <number|color> #RGB->HEX->dec
`],color:{$help:Object.keys(lo.get(te.now.palette).namedColors).sort().join(`
`)}}},Hy={$help:["Material shortcut","    DF - diffuse","    TR - transparent","    SF - soft plastic","    PL - glossy plastic","    ME - metal","    GL - glass"]},a_={$help:["Short (packed) representation description as a set of variables","    s=<EXPRESSION>","        selector property","    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]","        render mode property","    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]","        color mode property","    mt=<MATERIAL_ID>","        material property"],s:{$help:"Selection expression string as it is in menu->representations->selection"},m:_p,c:yp,mt:Hy},l_={$help:["Parameters of rendering modes customization: modes","Parameters of colorer customization: colorers","Autobuild: autobuild = (<number>|<bool>)"],modes:_p,colorers:yp},oO={$help:["help (<cmd name>| <path to property>)","You can get detailed information about command options",`   using "help cmd.opt.opt.[...]"
`,"   you can use one line comments","   everything started from (#|//) will be skipped",`   Example: >build //some comment
`,"List of available commands:"],reset:{$help:["Reload current object, delete all representations","    Nothing will work until load new object"]},load:{$help:["load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])","    Load new pdb object from selected source"],PDBID:{$help:"pdb id in remote molecule database"},URL:{$help:"url to source file"},f:{$help:["open file system dialog to fetch local file","optionally you can determine trajectory file","via URL for *.top model"]}},clear:{$help:"No args. Clear terminal"},add:{$help:["add [<REP_NAME>] [<DESCRIPTION>]","    Add new item to representation set with","    default or <DESCRIPTION> params"],REP_NAME:{$help:"Identifier string [_,a-z,A-Z,0-9] can not start from digit"},DESCRIPTION:a_},rep:{$help:["rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]","    set current representation by name or index","    edit current representation by <DESCRIPTION>"],REP_NAME:{$help:["Identifier string [_,a-z,A-Z,0-9] can not start from digit","Must be declared before"]},REP_INDEX:{$help:"Index of available representation"},DESCRIPTION:a_},remove:{$help:["remove (<REP_NAME>|<REP_INDEX>)","Remove representation by name or index"],REP_NAME:{$help:["Identifier string [_,a-z,A-Z,0-9] can not start from digit","Must be declared before"]},REP_INDEX:{$help:"Index of available representation"}},selector:{$help:["selector <EXPRESSION>","   set selector from EXPRESSION to current representation"],EXPRESSION:{$help:"Selection expression string as it is in menu->representations->selection"}},mode:{$help:["mode <MODE_ID> [<PARAMETER>=<VALUE>...]","   set rendering mode and apply parameters to current representation"],MODE_ID:_p},color:{$help:["color <COLORER_ID> [<PARAMETER>=<VALUE>...]","   set colorer and apply parameters to current representation"],COLORER_ID:yp},material:{$help:["material <MATERIAL_ID>","   set material to current representation"],MATERIAL_ID:Hy},build:{$help:"build help str",add:{$help:"build.add",new:{$help:["add.new","add.new new line 1","add.new new line 2","add.new new line 3"]}},del:{$help:"build.del"}},list:{$help:["list [-e|-s|<REP_NAME>|<REP_INDEX>]","Print representations if no args print list of representations","    -e expand list and show all representations","    -s show all user-registered selectors","    <REP_NAME>|<REP_INDEX> show only current representation"]},hide:{$help:["hide (<REP_NAME>|<REP_INDEX>)","Hide representation referenced in args"]},show:{$help:["show (<REP_NAME>|<REP_INDEX>)","Show representation referenced in args"]},get:{$help:["get <PARAMETER>","Print <PARAMETER> value","    <PARAMETER> - path to option use get.PARAMETER to get more info"],PARAMETER:l_},set:{$help:["set <PARAMETER> <VALUE>","Set <PARAMETER> with <VALUE>","    <PARAMETER> - path to option use set.PARAMETER to get more info"],PARAMETER:l_},set_save:{$help:["set_save","Save current settings to cookie"]},set_restore:{$help:["set_restore","Load and apply settings from cookie"]},set_reset:{$help:["set_reset","Reset current settings to the defaults"]},preset:{$help:["preset [<PRESET>]","Reset current representation or set preset to <PRESET>"],PRESET:{$help:["default","wire","small","macro"]}},unit:{$help:["unit [<unit_id>]","Change current biological structure view. Zero <unit_id> value means asymmetric unit,","positive values set an assembly with corresponding number.","Being called with no parameters command prints current unit information."]},view:{$help:["view [<ENCODED_VIEW>]","Get current encoded view or set if ENCODED_VIEW placed as argument"],ENCODED_VIEW:{$help:["encoded view matrix string (binary code)"]}},rotate:{$help:["rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...","Rotate scene"]},scale:{$help:["scale <SCALE>","Scale scene"]},select:{$help:["select <SELECTOR_STRING> [as <SELECTOR_NAME>]","Select atoms using selector defined in SELECTOR_STRING","    and if SELECTOR_NAME is defined register it in viewer","    you can use it later as a complex selector"]},within:{$help:["within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>","Build within named selector","    DISTANCE        <number>","    SELECTOR_STRING <string(selection language)>","    SELECTOR_NAME   <identifier>"]},url:{$help:["url [-s] [-v]","Report URL encoded scene","    if -s set that include settings in the URL","    if -v set that include view in the URL"]},screenshot:{$help:["screenshot [<WIDTH> [<HEIGHT>]]","Make a screenshot of the scene","    WIDTH  <number> in pixels","    HEIGHT <number> in pixels, equal to WIDTH by default"]},line:{$help:["line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]","Draw dashed line between two specified atoms"]},removeobj:{$help:["removeobj <id>","Remove scene object by its index. Indices could be obtained by <listobj> command"]},listobj:{$help:["listobj","Display the list of all existing scene objects"]}},Du=oO,{chem:{selectors:xp},modes:aO,colorers:lO,materials:cO,palettes:c_,options:hO,settings:nc}=hr;function uO(){}const Wy=(function(){const r=new uO;return function(){return r}})();class dO{constructor(){this.representationMap={},this.representationID={}}get(e){return this.representationMap[e]||this.representationID[e]||"<no name>"}add(e,t){if(e===-1)return"Can not create representation: there is no data";if(t!==void 0)if(!this.representationMap.hasOwnProperty(e))this.representationMap[e.toString()]=t,this.representationID[t]=e.toString();else return"This name has already existed, registered without name";return`Representation ${e} successfully added`}remove(e){e&&this.representationID.hasOwnProperty(e)&&(delete this.representationMap[this.representationID[e]],delete this.representationID[e]);const t=Object.keys(this.representationID).sort();for(const n in t)if(t.hasOwnProperty(n)){const i=t[n];i>e&&(this.representationID[i-1]=this.representationID[i],this.representationMap[this.representationID[i]]-=1,delete this.representationID[i])}}clear(){this.representationMap={},this.representationID={}}}const fO=new dO;function Cc(r){const t={s:"selector",m:"mode",c:"colorer",mt:"material",mode:"modes",color:"colorers",colorer:"colorers",select:"selector",material:"materials",selector:"selector"}[r];return t===void 0?r:t}class pO{list(e,t,n){let i="";if(e&&t!==void 0&&(n===void 0||n==="-e")){const s=e.repCount();for(let o=0;o<s;o++)i+=this.listRep(e,t,o,n)}return i}listRep(e,t,n,i){let s="";const o=e.repGet(n);if(!o)return Ut.warn(`Rep ${n} does not exist!`),s;const a=n,l=t.get(a),{mode:c,colorer:h}=o,u=o.selectorString,d=o.materialPreset;return s+=`#${a} : ${c.name}${l==="<no name>"?"":`, ${l}`}
`,i!==void 0&&(s+=`    selection : "${u}"
`,s+=`    mode      : (${c.id}), ${c.name}
`,s+=`    colorer   : (${h.id}), ${h.name}
`,s+=`    material  : (${d.id}), ${d.name}
`),s}listSelector(e,t){let n="";for(const i in t)t.hasOwnProperty(i)&&(n+=`${i} : "${t[i]}"
`);return n}listObjs(e){const t=e._objects;if(!t||!Array.isArray(t)||t.length===0)return"There are no objects on the scene";const n=[];for(let i=0,s=t.length;i<s;++i)n[i]=`${i}: ${t[i].toString()}`;return n.join(`
`)}joinHelpStr(e){return e instanceof Array?e.join(`
`):e}help(e){if(de.default.isUndefined(e))return`${this.joinHelpStr(Du.$help)}
${de.default.slice(de.default.sortBy(de.default.keys(Du)),1).join(", ")}
`;const t=de.default.get(Du,e);return de.default.isUndefined(t)?this.help():`${this.joinHelpStr(t.$help)}
`}load(e,t){if(e===void 0||t===void 0||t==="-f")return;e.awaitWhileCMDisInProcess();const n=()=>e.finishAwaitingCMDInProcess();e.load(t).then(n,n)}checkArg(e,t,n){if(e!==void 0&&t!==void 0){if(Cc(e)==="selector"){const a=xp.parse(t);if(a.error!==void 0)throw{message:a.error};return n!==void 0&&n?a.selector:t}const i={colorers:lO,modes:aO,materials:cO};let s=e,o;for(;s!==o;)o=s,s=Cc(o);if(i[s].get(t)===void 0)throw{message:`${t} is not existed in ${s}`};return t}return Wy}propagateProp(e,t){if(e!==void 0){let n={};const i=hO.adapters[typeof de.default.get(nc.defaults,e)];if(i===void 0)throw{message:`${e} is not existed`};if((e.endsWith(".color")||e.endsWith(".baseColor")||e.endsWith(".EL.carbon"))&&typeof t!="number"&&(t=c_.get(nc.now.palette).getNamedColor(t)),e.endsWith(".fg")||e.endsWith(".bg"))if(typeof t!="number"){const s=c_.get(nc.now.palette).getNamedColor(t,!0);s!==void 0&&(t=`0x${s.toString(16)}`)}else t=`0x${t.toString(16)}`;if(e.endsWith(".template")&&(t=t.replace(/\\n/g,`
`)),t!==void 0&&i(t)!==t&&i(t)!==t>0)throw n={message:`${e} must be a "${typeof de.default.get(nc.defaults,e)}"`},n}return t}unquoteString(e){return be.unquoteString(e)}}const mO=new pO;function gO(r,e){const t={};return t[r]=e,t}function bh(r){if(r instanceof this.constructor)return r;r instanceof Array?this._values=r.slice(0):r?this._values=[r]:this._values=[]}bh.prototype.append=function(r){const e=this._values;return e[e.length]=r,this};bh.prototype.remove=function(r){const e=this._values,t=e.indexOf(r);return t>=0&&e.splice(t,1),this};bh.prototype.toJSO=function(r,e,t){const n={},i=this._values;for(let s=0,o=i.length;s<o;++s)de.default.set(n,i[s].id,r.propagateProp(`${Cc(e)}.${t}.${i[s].id}`,i[s].val));return n};function _O(r,e){this.id=r,this.val=e}const Sn=Object.create({});Sn.Arg=_O;Sn.ArgList=bh;Sn.miew=null;Sn.echo=null;Sn.representations=fO;Sn.utils=mO;Sn._=de.default;Sn.CreateObjectPair=gO;Sn.keyRemap=Cc;Sn.Context=xp.Context;Sn.ClearContext=xp.ClearContext;Sn.NULL=Wy;Sn.notimplemented=function(){return this.NULL};hr.prototype.script=function(r,e,t){us.parser.yy.miew=this,us.parser.yy.echo=e,us.parser.yy.error=t,this.cmdQueue===void 0&&(this.cmdQueue=[]),this.commandInAction===void 0&&(this.commandInAction=!1),this.cmdQueue=this.cmdQueue.concat(r.split(`
`))};hr.prototype.awaitWhileCMDisInProcess=function(){this.commandInAction=!0};hr.prototype.finishAwaitingCMDInProcess=function(){this.commandInAction=!1};hr.prototype.isScriptingCommandAvailable=function(){return this.commandInAction!==void 0&&!this.commandInAction&&this.cmdQueue!==void 0&&this.cmdQueue.length>0};hr.prototype.callNextCmd=function(){if(this.isScriptingCommandAvailable()){const r=this.cmdQueue.shift(),e={};e.success=!1;try{us.parser.parse(r),e.success=!0}catch(t){e.error=t.message,us.parser.yy.error(e.error),this.finishAwaitingCMDInProcess()}return e}return""};us.parser.yy=Sn;us.parser.yy.parseError=us.parser.parseError;const yO=hr;var xO=v0.A,vO={536:r=>{r.exports=function(e){var t=[];return t.toString=function(){return this.map((function(n){var i="",s=n[5]!==void 0;return n[4]&&(i+="@supports (".concat(n[4],") {")),n[2]&&(i+="@media ".concat(n[2]," {")),s&&(i+="@layer".concat(n[5].length>0?" ".concat(n[5]):""," {")),i+=e(n),s&&(i+="}"),n[2]&&(i+="}"),n[4]&&(i+="}"),i})).join("")},t.i=function(n,i,s,o,a){typeof n=="string"&&(n=[[null,n,void 0]]);var l={};if(s)for(var c=0;c<this.length;c++){var h=this[c][0];h!=null&&(l[h]=!0)}for(var u=0;u<n.length;u++){var d=[].concat(n[u]);s&&l[d[0]]||(a!==void 0&&(d[5]===void 0||(d[1]="@layer".concat(d[5].length>0?" ".concat(d[5]):""," {").concat(d[1],"}")),d[5]=a),i&&(d[2]&&(d[1]="@media ".concat(d[2]," {").concat(d[1],"}")),d[2]=i),o&&(d[4]?(d[1]="@supports (".concat(d[4],") {").concat(d[1],"}"),d[4]=o):d[4]="".concat(o)),t.push(d))}},t}},784:r=>{r.exports=function(e){var t=e[1],n=e[3];if(!n)return t;if(typeof btoa=="function"){var i=btoa(unescape(encodeURIComponent(JSON.stringify(n)))),s="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(i),o="/*# ".concat(s," */");return[t].concat([o]).join(`
`)}return[t].join(`
`)}},32:(r,e,t)=>{t.d(e,{A:()=>l,z:()=>a});var n=t(784),i=t.n(n),s=t(536),o=t.n(s)()(i());o.push([r.id,`.DVOOardsIBZOO3FaW5Nw {
  width: 100%;
  height: 100%;
}
`,"",{version:3,sources:["webpack://./src/Viewer.module.scss"],names:[],mappings:"AAAA;EACE,WAAW;EACX,YAAY;AACd",sourcesContent:[`.root {\r
  width: 100%;\r
  height: 100%;\r
}\r
`],sourceRoot:""}]);var a="DVOOardsIBZOO3FaW5Nw";const l=o},920:(r,e,t)=>{t.d(e,{A:()=>a});var n=t(784),i=t.n(n),s=t(536),o=t.n(s)()(i());o.push([r.id,`@keyframes spinner-line-fade-more {
  0%, 100% {
    opacity: 0; /* minimum opacity */
  }
  1% {
    opacity: 1;
  }
}

@keyframes spinner-line-fade-quick {
  0%, 39%, 100% {
    opacity: 0.25; /* minimum opacity */
  }
  40% {
    opacity: 1;
  }
}

@keyframes spinner-line-fade-default {
  0%, 100% {
    opacity: 0.22; /* minimum opacity */
  }
  1% {
    opacity: 1;
  }
}

@keyframes spinner-line-shrink {
  0%, 25%, 100% {
    /* minimum scale and opacity */
    transform: scale(0.5);
    opacity: 0.25;
  }
  26% {
    transform: scale(1);
    opacity: 1;
  }
}

.miew-canvas > canvas {
  display: block;
  width: 100%;
  height: 100%;
}

.miew-container,
.miew-canvas {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: relative;
}

.miew-message {
  /* trick for centered error-reporting*/
  background-color: #ccc;
  display: table;
  width: 100%;
  height: 100%;
}

.miew-message p {
    display: table-cell;
    vertical-align: middle;
    text-align: center;
    font-size: large;
  }

.mode-message {
  position: absolute;
  top: 10px;
  right: 10px;
  border-radius: 4px;
  color: silver;
  background-color: rgba(64, 64, 64, 0.75);
  display: flex;
  align-items: left;
  justify-content: left;
  opacity: 0;
}

.atom-info {
  margin: 10px;
  text-align: left;
}

.overlay {
  pointer-events: none;
}
`,"",{version:3,sources:["webpack://./../miew/dist/Miew.css"],names:[],mappings:"AAAA;EACE;IACE,UAAU,EAAE,oBAAoB;EAClC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,aAAa,EAAE,oBAAoB;EACrC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,aAAa,EAAE,oBAAoB;EACrC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,8BAA8B;IAC9B,qBAAqB;IACrB,aAAa;EACf;EACA;IACE,mBAAmB;IACnB,UAAU;EACZ;AACF;;AAEA;EACE,cAAc;EACd,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,sCAAsC;EACtC,sBAAsB;EACtB,cAAc;EACd,WAAW;EACX,YAAY;AACd;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,kBAAkB;IAClB,gBAAgB;EAClB;;AAEF;EACE,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,kBAAkB;EAClB,aAAa;EACb,wCAAwC;EACxC,aAAa;EACb,iBAAiB;EACjB,qBAAqB;EACrB,UAAU;AACZ;;AAEA;EACE,YAAY;EACZ,gBAAgB;AAClB;;AAEA;EACE,oBAAoB;AACtB",sourcesContent:[`@keyframes spinner-line-fade-more {
  0%, 100% {
    opacity: 0; /* minimum opacity */
  }
  1% {
    opacity: 1;
  }
}

@keyframes spinner-line-fade-quick {
  0%, 39%, 100% {
    opacity: 0.25; /* minimum opacity */
  }
  40% {
    opacity: 1;
  }
}

@keyframes spinner-line-fade-default {
  0%, 100% {
    opacity: 0.22; /* minimum opacity */
  }
  1% {
    opacity: 1;
  }
}

@keyframes spinner-line-shrink {
  0%, 25%, 100% {
    /* minimum scale and opacity */
    transform: scale(0.5);
    opacity: 0.25;
  }
  26% {
    transform: scale(1);
    opacity: 1;
  }
}

.miew-canvas > canvas {\r
  display: block;\r
  width: 100%;\r
  height: 100%;\r
}

.miew-container,\r
.miew-canvas {\r
  width: 100%;\r
  height: 100%;\r
  overflow: hidden;\r
  position: relative;\r
}

.miew-message {\r
  /* trick for centered error-reporting*/\r
  background-color: #ccc;\r
  display: table;\r
  width: 100%;\r
  height: 100%;\r
}

.miew-message p {\r
    display: table-cell;\r
    vertical-align: middle;\r
    text-align: center;\r
    font-size: large;\r
  }

.mode-message {\r
  position: absolute;\r
  top: 10px;\r
  right: 10px;\r
  border-radius: 4px;\r
  color: silver;\r
  background-color: rgba(64, 64, 64, 0.75);\r
  display: flex;\r
  align-items: left;\r
  justify-content: left;\r
  opacity: 0;\r
}

.atom-info {\r
  margin: 10px;\r
  text-align: left;\r
}

.overlay {\r
  pointer-events: none;\r
}\r
`],sourceRoot:""}]);const a=o},591:r=>{var e=[];function t(s){for(var o=-1,a=0;a<e.length;a++)if(e[a].identifier===s){o=a;break}return o}function n(s,o){for(var a={},l=[],c=0;c<s.length;c++){var h=s[c],u=o.base?h[0]+o.base:h[0],d=a[u]||0,f="".concat(u," ").concat(d);a[u]=d+1;var p=t(f),_={css:h[1],media:h[2],sourceMap:h[3],supports:h[4],layer:h[5]};if(p!==-1)e[p].references++,e[p].updater(_);else{var g=i(_,o);o.byIndex=c,e.splice(c,0,{identifier:f,updater:g,references:1})}l.push(f)}return l}function i(s,o){var a=o.domAPI(o);return a.update(s),function(l){if(l){if(l.css===s.css&&l.media===s.media&&l.sourceMap===s.sourceMap&&l.supports===s.supports&&l.layer===s.layer)return;a.update(s=l)}else a.remove()}}r.exports=function(s,o){var a=n(s=s||[],o=o||{});return function(l){l=l||[];for(var c=0;c<a.length;c++){var h=t(a[c]);e[h].references--}for(var u=n(l,o),d=0;d<a.length;d++){var f=t(a[d]);e[f].references===0&&(e[f].updater(),e.splice(f,1))}a=u}}},128:r=>{var e={};r.exports=function(t,n){var i=(function(s){if(e[s]===void 0){var o=document.querySelector(s);if(window.HTMLIFrameElement&&o instanceof window.HTMLIFrameElement)try{o=o.contentDocument.head}catch{o=null}e[s]=o}return e[s]})(t);if(!i)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");i.appendChild(n)}},51:r=>{r.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},855:(r,e,t)=>{r.exports=function(n){var i=t.nc;i&&n.setAttribute("nonce",i)}},740:r=>{r.exports=function(e){if(typeof document>"u")return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){(function(i,s,o){var a="";o.supports&&(a+="@supports (".concat(o.supports,") {")),o.media&&(a+="@media ".concat(o.media," {"));var l=o.layer!==void 0;l&&(a+="@layer".concat(o.layer.length>0?" ".concat(o.layer):""," {")),a+=o.css,l&&(a+="}"),o.media&&(a+="}"),o.supports&&(a+="}");var c=o.sourceMap;c&&typeof btoa<"u"&&(a+=`
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(c))))," */")),s.styleTagTransform(a,i,s.options)})(t,e,n)},remove:function(){(function(n){if(n.parentNode===null)return!1;n.parentNode.removeChild(n)})(t)}}}},656:r=>{r.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}}},h_={};function bt(r){var e=h_[r];if(e!==void 0)return e.exports;var t=h_[r]={id:r,exports:{}};return vO[r](t,t.exports,bt),t.exports}bt.n=r=>{var e=r&&r.__esModule?()=>r.default:()=>r;return bt.d(e,{a:e}),e},bt.d=(r,e)=>{for(var t in e)bt.o(e,t)&&!bt.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:e[t]})},bt.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),bt.nc=void 0;var Xy={};bt.d(Xy,{A:()=>CO});const SO=(u_={default:()=>xO},Uu={},bt.d(Uu,u_),Uu);var u_,Uu;const ic=(r=>{var e={};return bt.d(e,r),e})({default:()=>ex,useLayoutEffect:()=>bp.useLayoutEffect,useRef:()=>bp.useRef});var bO=bt(591),jy=bt.n(bO),wO=bt(740),Yy=bt.n(wO),MO=bt(128),qy=bt.n(MO),AO=bt(855),$y=bt.n(AO),EO=bt(51),Zy=bt.n(EO),TO=bt(656),Ky=bt.n(TO),Wo=bt(32),jr={};jr.styleTagTransform=Ky(),jr.setAttributes=$y(),jr.insert=qy().bind(null,"head"),jr.domAPI=Yy(),jr.insertStyleElement=Zy(),jy()(Wo.A,jr),Wo.A&&Wo.A.locals&&Wo.A.locals;var sc=bt(920),Yr={};function CO(r){let{onInit:e,options:t}=r;const n=(0,ic.useRef)(),i=(0,ic.useRef)();return(0,ic.useLayoutEffect)((()=>{const s={axes:!1,fps:!1,...t?.settings};return(function(o,a,l){if(!o.current){const c=new SO.default(a);c.init()&&(o.current=c,c.run(),typeof l=="function"&&l(c))}})(n,{...t,container:i.current,settings:s},e),()=>(function(o){o.current&&o.current.term(),o.current=null})(n)}),[e,t]),ic.default.createElement("div",{className:Wo.z,ref:i},"Viewer")}Yr.styleTagTransform=Ky(),Yr.setAttributes=$y(),Yr.insert=qy().bind(null,"head"),Yr.domAPI=Yy(),Yr.insertStyleElement=Zy(),jy()(sc.A,Yr),sc.A&&sc.A.locals&&sc.A.locals;var e4=Xy.A;export{e4 as default};
